<div    style="color:00FF60;font-family:optima;font-size:88pt;position:absolute;top:84pt">
<center>
The Next Revolution is Efficient Code
</center>
</div>



<div style=font-family:Times;position:absolute;top:0">

<center>

<h1>masmx.7r3A</h1>

<div	style="color:C0C0FF;font-family:optima;font-size:24">
The Watchmaker's Craft of Programming
<br>
<br>
</div>

<i>
Copyright Tim Cox, 2015<br>

This document describes the masmx.7r3A target-independent meta-assembler
<br>
The masmx.7r3A meta-assembler is free software licensed with the GNU General Public Licence Version 3
<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>


<h1>The Free Meta Assembler</h1>



</center>

<h2>What's masmx?</h2>

<p>
masmx is a freeware meta-assembler for any target

&nbsp;&nbsp;&nbsp;&nbsp;

<a	href="http://timmilescox.github.io/masmx/">-----&gt;masm7r3A Downloads Page</a>
<a	style="color:FF0000;right:100pt;position:absolute">
        <u>Changes from 7r3 to 7r3A</u><br>
        masmx.7r3A revises and makes more consistent the assembly<br>
        of hierarchically structured and named code and data. Earlier<br>
        application code needs no changes<br>

<a	href="#strools"
	style=right:100pt;position:absolute>
	Structured Code
</a>
</a>

<p>
Developed as a cross-assembler for embedded targets<br>
masmx ready-made binaries run as 32-bit programs on all popular PCs<br>

<div    style="color:A0A0A0">
<blockquote>

masmx saves electronics and energy, and may be used as the substance of thin-layer compilers.<br>
masmx makes the miniature more possible, and can multiply the performance of giant servers up to fivefold.

</blockquote>
</div>

<p>
Freeware means free access to the downloadable source

<p>
masmx is easy to use

<p>
masmx can assemble absolute system images in one step from source.

<p>
masmx can assemble relocatable code and has an internal linker.

<p>
The cumulative linker constructs each program section as absolute or as a new relocatable

<p>
Integers and floating numbers are any format and size up to 192 bits.<br>
192 bits are not excessive because systems already compute and exchange 128-bit numbers

<div	style="color:A0A0A0">
<blockquote>

Maximum memory space depends on target architecture. The highest address where masmx
can assemble and load code is

	<blockquote>
	0FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF
	</blockquote>

(4 tera-peta-peta-petaquanta or 4096 exa-exa-exaquanta or 4-giga-yotta-yottaquanta<br>
of words or bytes, whichever the target address quantum is)

<p>
Memories this large are not immediately expected.
However very large address spaces are often populated in part,<br>
with system memory at low-order addresses and boot or peripheral logic
at the highest addresses

</blockquote>
</div>


<p>
Segmented memory, base-displacement addressing, preprogrammed physical
memory relocation and memory address translation are all supported

<p>
masmx also assembles images for the simplest 8-bit architectures

<p>
masmx has a slender native syntax, and interprets all other assembly
source code syntax.
All existing source code assembles unchanged

<p>
Intermediate binary encoding and target S-Records or I-Records are in text

<p>
The accompanying masmx definition headers for 8051 and for PowerPC
are field proven in live commercial use.

<p>
Innovations in target architecture are tracked with updates in macro language.
Anyone who understands the target architecture can do this.

<p>
User interface is a shell or command prompt

<p>
Binaries for all popular developer platforms are downloadable. Installation = copy the binaries

&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://timmilescox.github.io/masmx/">&lt;-----Downloads Page</a>

<p>
masmx source code is in git and download zip. Build for new developer platforms is a one-line shell command

 


<h2>Why do you want it?</h2>


<p>
masmx gives minute control of the construction and location of code and data.

<p>
Typical masmx targets are low-power targets where as few instructions
as possible are executed.

<div    style="color:A0A0A0">
<blockquote>

Language compilers can be reinvented to generate a common macro-assembly language for all targets<br>
See <a href="#roadmap">Appendix C: Road Map</a>, <a href="#languages">Appendix D: High Level Languages</a><br>
Compiler/target portation becomes instantaneous<br>
Language maps to target-independent macro names. These macro names map to target-specific macro text<br>
Any PC has a developer toolchain for any target
</blockquote>
</div>

<p>
Complex EPROM and Flash structures may be described in a few cryptic lines of source code.

<p>
The maximum integer, floating point and address radix of 192 bits make
masmx a toolchain for experimental large architectures,<br>
or for multi-architecture systems with special hardware modules.

<p>
masmx is also a toolchain for the smallest architectures. The supplied definition header for 8051<br>
has been used on mission-critical projects by prestige clients.

<p>
32-bit and 64-bit PowerPC assemblies with incremental and absolute linking are illustrated<br>
in Section 9 of this manual. masmx has generated PowerPC RT kernels with the same macro text.

<p>
Target architecture definitions are source code include files.

<p>
This manual shows how to use masmx for any architecture present or future.

<p>
For assistance building macro definition text for a new target, contact masmx@gmx.ch.

<p>
masmx may be hosted on MAC OS X PowerPC G4, MAC OS X Intel ix86, Sun SPARC Solaris,<br>
Ubuntu Linux x86, MS DOS and MS Windows 32-bit.
Consult the <a href="http://TimMilesCox.github.io/masmx/rel_note.txt">release note</a>
for actual delivered binaries


<pre>


1.  <a href="#cando">What masmx can do</a>							1

    1.	<a href="#any">Any Target Architecture</a>						1.1
    2.	<a href="#syntax">Any Input Syntax</a>
	1  <a href="#legacy">Legacy Source Code Unchanged</a>					1.2.1
    	2  <a href="#notate1">Number and Character String Notation</a>				1.2.2
    3.	<a href="#anyword">Any Word Size</a>							1.3
    4.	<a href="#anydress">Any Address Space</a>						1.4
    5.	<a href="#anyfloat">Any Floating Point Format</a>					1.5
    6.  <a href="#strip1">Structured Data and Repeat Data</a>					1.6
	1.  <a href="#stridata">Structured Data</a>						1.6.1
	2.  <a href="#stribata">Bit-Aligned Structured Data</a>					1.6.2
    	3.  <a href="#bitaccess">Accessing Bit-Aligned Structured Data</a>			1.6.3
	4.  <a href="#strip2">Repeat Data</a>							1.6.4
	5.  <a href="#streaf">Functionally Compartmented Name Spaces</a>			1.6.5
    7.	<a href="#strun">Run-Time Algorithm Plotting</a>					1.7

2.  <a href="#developer">Developer Environment</a>						2

3.  <a href="#start">Getting started</a>							3

4.  <a href="#sourceline">The Assembly Language Source Line</a>					4

    1.	<a href="#labels">Labels</a>								4.1

    2.	<a href="#expression">Expressions</a>							4.2
	1.  <a href="#operator">Operators</a>							4.2.1
	2.  <a href="#xtoken">Tokens</a>							4.2.2
	    1.	<a href="#notate2">Number Strings</a>						4.2.2.1
		1.  <a href="#nstring">masmx Native Number and String Notation</a>		4.2.2.1.1
		2.  <a href="#cstring">C Language Number and String Notation</a>		4.2.2.1.2
		3.  <a href="#motorola">Motorola Old Number Notation</a>			4.2.2.1.3
		4.  <a href="#suffix">Suffix-Determined Number Notation</a>			4.2.2.1.4
	    2.	<a href="#labelref">Label References</a>					4.2.2.2
	    3.	<a href="#ifunction">masmx Internal Functions</a>				4.2.2.3
	    4.	<a href="#func_macro">Function Macro Reference</a>				4.2.2.4
	    5.	<a href="#argument_ref">Macro Parameter Reference</a>				4.2.2.5

    3.	<a href="#command">The Command Field</a>						4.3
	1.  <a href="#directive">Directives</a>							4.3.1
	2.  <a href="#constant">Storage Constants</a>						4.3.2
	3.  <a href="#nconstant">Number Constants</a>						4.3.3
	4.  <a href="#commas">Split Number Constants</a>					4.3.4
	5.  <a href="#text_string">Text Strings</a>						4.3.5
	6.  <a href="#form">$form Items</a>							4.3.6
	7.  <a href="#proc_call">$proc Macro Calls: Instructions and Structures</a>		4.3.7

    4.  <a href="#argument">The Argument Field</a>						4.4
	1.  <a href="#xargument">Argument Expressions</a>					4.4.1
	2.  <a href="#largument">Literal Arguments</a>						4.4.2

    5.  <a href="#literals">Literals</a>							4.5
	1.  <a href="#literal_is">A literal is</a>						4.5.1
	2.  <a href="#literal_pool">Literal Pools</a>						4.5.2
	3.  <a href="#automatic">Automatic Literals</a>						4.5.3
	4.  <a href="#iflag_lit">Indirection Flag on a Literal</a>				4.5.4
	5.  <a href="#lpooltag">Literal Pool Tags</a>						4.5.5
	6.  <a href="#ldirective">$lit Directive</a>						4.5.6
	7.  <a href="#lnested">Nested Literals</a>						4.5.7
    
    6.  <a href="#fmacro">Function Macros</a>							4.6
	1.  <a href="#fmacrois">A Function Macro is</a>						4.6.1
	2.  <a href="#fmacdi">Directives used Constructing Functions</a>			4.6.2
	    1.	Sfunc	<a href="#fmache">Function Head</a>					4.6.2.1
		1.  <a href="#fmac2pass">Second-Pass-Only Functions</a>				4.6.2.1.1
		2.  <a href="#fmacni">Non-Idempotent Functions</a>				4.6.2.1.2
		3.  <a href="#fmacdisp">Functions affecting Program Displacements</a>		4.6.2.1.3
     	    2.	$name	<a href="#fmacname">Entry Point and Value Tag</a>			4.6.2.2
	    3.	$return	<a href="#fmacret">Value of Result</a>					4.6.2.3
	    4.	$end	<a href="#fmacend">Function Foot</a>					4.6.2.4
	3.  <a href="#fmacode">Code Generated During Function Evaluation</a>			4.6.3

    7.  <a href="#internalf">masmx Internal Functions in Detail</a>			 	4.7

	1.  $	<a href="#location_c">location counter</a>					4.7.1
	    1.  $	<a href="#thisloc">this location counter</a>				4.7.1.1
	    2.  $(..)	<a href="#alocator">named location counter</a>				4.7.1.2

	2.  $a	<a href="#absolute">absolute address</a>					4.7.2
	    1.	$a	<a href="#absolute_here">current absolute address</a>			4.7.2.1
	    2.	$a(..)	<a href="#absolute_there">absolute value of expression</a>			4.7.2.2

	3.  $b	<a href="#sectionbase">section base address</a>					4.7.3
                    	  
	4.  $bank_index	<a href="#bix">current memory block identifier</a>			4.7.4

	5.  $n		<a href="#sname">short token for macro entry name value</a>		4.7.5

	6.  $net(..)	<a href="#snet">unrelocated value of expression</a>			4.7.6

	7.  $o(..)	<a href="#oflag">value of an option flag</a>				4.7.7

	8.  $r	<a href="#region">region</a>							4.7.8
	    1.	$r	<a href="#thisregion">identity of current location counter</a>		4.7.8.1
	    2.	$r(..)	<a href="#thatregion">locator of named target</a>				4.7.8.2

	9.  $rel(..)	<a href="#relocation">relocation factor</a>				4.7.9
	    1.	$rel	<a href="#relocat_here">current relocation factor</a>			4.7.9.1
	    2.  $rel(..) <a href="#relocat_there">relocation factor of named locator</a>		4.7.9.2

	10. $t(..)	<a href="#labeltyp">type of a label</a>					4.7.10
	    1.		<a href="#lt_undefined">undefined</a>					4.7.10.1
	    2.		<a href="#lt_location">location</a>					4.7.10.2
	    3.		<a href="#lt_equ">$equ</a>						4.7.10.3
	    4.		<a href="#lt_set">$set</a>						4.7.10.4
	    5.		<a href="#lt_equf">$equf</a>						4.7.10.5
	    6.		<a href="#lt_directive">$directive</a>					4.7.10.6
	    7.		<a href="#lt_function">$function</a> (of masmx)				4.7.10.7
	    8.		<a href="#lt_proc">$proc</a> (macro)					4.7.10.8
	    9.		<a href="#lt_name">$name</a>						4.7.10.9
	    10. 	<a href="#lt_func">$func</a> (macro)					4.7.10.10
	    11. 	<a href="#lt_form">$form</a>						4.7.10.11
	    12. 	<a href="#lt_user">user assigned label types</a>			4.7.10.12

	11. $zenith	<a href="#zenith">high address of section + literals</a>		4.7.11
	    1.	$zenith		<a href="#zenith">this section</a>				4.7.11.1
	    2.	$zenith(..)	<a href="#azenith">named section</a>				4.7.11.2


5.  <a href="#structure">Iterated Code and Structured Data</a>					5

    1.	<a href="#domac">$do and macros</a>							5.1

    2.	<a href="#stradata">Structured Data and Structured Code Name Spaces</a>			5.2

	1. <a href="#strools">Rules of Structured Spaces</a>					5.2.1

	2.  <a href="#wstradata">Word-Aligned Structures $tree / $branch..$root</a>		5.2.2
	    1.  <a href="#tree_root">Structures $tree..$root</a>					5.2.2.1
	    2.  <a href="#branch_root">Overlaid Structures $branch..$root</a>			5.2.2.2
	    4.  <a href="#name_space">Structured Code Name Spaces</a>				5.2.2.3
		    

	3.  <a href="#bstradata">Bit-Aligned Structures</a>					5.2.3
	    1.	<a href="#record_root">Bit-Aligned Data $record..$root</a>				5.2.3.1
	    2.  <a href="#record_macro">Macro Code Access to Bit-Aligned Fields and Groups</a>	5.2.3.2
	    3.	<a href="#record_overlay">Overlaid Structures $record,$branch</a>			5.2.3.3
	    4.	<a href="#signed_bitfield">Signed Bit Fields</a>					5.2.3.4
	    5.	<a href="#record_float">$record compressed floating constant arrays</a>		5.2.3.5

6.  <a href="#algors">Run-Time Algorithm Plotter</a>						6

    1.  <a href="#ialgors">Run-Time Integer Algorithm Plotter</a>				6.1
    2.  <a href="#fpalgors">Run-Time Floating Algorithm Plotter</a>				6.2


7.  <a href="#sections">Constructing Program Sections</a>					7

    1.  <a href="#abslocs">Absolute Location Counters</a>					7.1

	1.  <a href="#sabslocs">Simple Absolute Location Counters</a>				7.7.1

	2.  <a href="#breakpoint">Breakpointed Location Counters</a>				7.1.2
	    1.  <a href="#abreakpt">Physical Address Offset</a>					7.1.2.1
	    2.  <a href="#vbreakpt">Breakpointed Location Counters: -v Option</a>		7.1.2.2

	3.  <a href="#bdflat">Simple Location Counter without Breakpoint</a>
	    	    <a href="#bdflat">Base+Displacement in Flat Address Spaces</a>		7.1.3

	4.  <a href="#bdbreakpt">Breakpointed Location Counters</a>
             	    <a href="#bdbreakpt">Base+Displacement in Translated Address Spaces</a>	7.1.4

	5.  <a href="#voidsection">Void Sections</a>						7.1.5

	6.  <a href="#giantspace">Breakpointed Location Counters: Giant Address Spaces</a>	7.1.6

	    1.  <a href="#giantdirect">Very Large Direct Addressed Sections</a>			7.1.6.1

	    2.  <a href="#bdgiant">Very Large Load Address Base-Displacement Examples</a>	7.1.6.2

		1.  <a href="#staticbdg">Giant Absolute Address Base-Displacement</a>
		    <a href="#staticbdg">Static Reference Example</a>				7.1.6.2.1

		2.  <a href="#dynamicbdg">Giant Absolute Address Base-Displacement</a>
		    <a href="#dynamicbdg">Dynamic Reference Example</a>				7.1.6.2.2

	7.   <a href="#lptag">Literal Pool Tag</a>						7.1.7

    2.  <a href="#relocate">Relocatable Location Counters</a>					7.2



8.  <a href="#directive">masmx Directives</a>							8

    1.	<a href="#ascii">$ascii</a>		set character code to ASCII			8.1
    2.	<a href="#awidth">$awidth</a>		set address width				8.2
    3.	<a href="#blank">$blank</a>		set the globality of a future label		8.3
    4.	<a href="#branch">$branch</a>		branch of a structured name space		8.4
    5.	<a href="#byte">$byte</a>		set the width of a text byte			8.5

    6.	<a href="#characteristic">$characteristic</a>		set floating exponent field size	8.6

    7.	<a href="#cont_char">$cont_char</a>	change line continue character			8.7
    8.	<a href="#data_code">$data_code</a>	define/select character string code points	8.8
    9.	<a href="#do">$do</a>		generate repeated code				8.9
    10.	<a href="#else">$else</a>		conditional assembly				8.10
    11.	<a href="#elseif">$elseif</a>		conditional assembly				8.11
    12.	<a href="#end">$end</a>		foot of macro or assembly			8.12
    13.	<a href="#endif">$endif</a>		conditional assembly				8.13
    14.	<a href="#equ">$equ</a>		assign a value to label				8.14
    15.	<a href="#equf">$equf</a>		assign a list of values to label		8.15
    16.	<a href="#exit">$exit</a>		abandon assembly with a message			8.16
    17.	<a href="#flag">$flag</a>		diagnostic, mark assembly in error		8.17

    18.	<a href="#flagf">$flagf</a>		first pass diagnostic, mark assembly in error	8.18

    19.	<a href="#floating_point">$floating_point</a> set default floating number size		8.19

    20.	<a href="#form">$form</a>		bit fields layout template			8.20

    21.	<a href="#func">$func</a>		user macro to produce an operand value		8.21
    22.	<a href="#hex">$hex</a>		set binary notation to hex			8.23

    23.	<a href="#if">$if</a>		conditional assembly				8.23

    24.	<a href="#include">$include</a>	include a source file or a binary file		8.24

	1.  <a href="#include">$include</a>		read a nested source file		8.24.1

	2.  <a href="#include_b">$include,$binary</a> 	linking directive:
				read a text-encoded binary file
				process its relocation information
				output the linked code			8.24.2

	3.  <a href="#include_v">$include,$void</a>	linking directive:
				include addresses from a text-encoded
				binary file, but no code from it	8.24.3

    25.	<a href="#info">$info</a>			linking directive:			8.25

	1.  <a href="#info">$info,$offset</a>	update tuple of relocation information	8.25.1

	2.  <a href="#info_range">$info,$range_check</a>
	    <a href="#info_range">$info,$range_check1</a>

			request linker Automatic range-checking
			of an updated field of output binary		8.25.2

    26.	<a href="#linewidth">$linewidth</a>	control layout in text encoded binary		8.26

    27.	<a href="#list">$list</a>								8.27
	1.  <a href="#list">$list <i>include_depth</i></a>
				set file include depth for listing	8.27.1
	2.  <a href="#list_0">$list 0</a>	suppress list and labels export			8.27.2

    28.	<a href="#lit">$lit</a>		select default location counter for literals
			optionally declare literal tag			8.28

    29.	<a href="#load">$load</a>		linking directive:
			write revised binary information in
			output text-encoded binary file			8.30

    30.	<a href="#lterm">$lterm</a>		change comment character			8.30
    31.	<a href="#name">$name</a>		macro call name and value			8.31
    32.	<a href="#nop">$nop</a>		do nothing [+ comment]				8.32
    33.	<a href="#note">$note</a>		informative diagnostic, not error		8.33
    34.	<a href="#notef">$notef</a>		first pass informative diagnostic		8.34
    35.	<a href="#octal">$octal</a>		set binary notation to octal			8.35
    36.	<a href="#path">$path</a>		alter include path				8.36
    37.	<a href="#plist">$plist</a>		nest depth for listing macro expansion		8.37
    38.	<a href="#proc">$proc</a>		head of procedural macro			8.38

    39.	<a href="#pushrel">$pushrel</a>	linking directive:

			scan a relocation tuple applied to a
			word group in the text-encoded binary.

			Stack an unresolved relocation tuple
			for replay to the $map linking macro		8.39

    40.	<a href="#quantum">$quantum</a>	set address quantum				8.40

    41.	<a href="#quote">$quote</a>		change quote mark				8.41


    42.	<a href="#record">$record</a>								8.42

	1.  <a href="#record">$record</a>		bit-aligned data structures		8.42.1
	2.  <a href="#record_b">$record,$branch</a>	bit-aligned structure overlay		8.42.2

    43.	<a href="#res">$res</a>		declare a storage buffer			8.43

    44.	<a href="#return">$return</a>								8.44

	1.  <a href="#return">$return</a>	return a value from a $func macro		8.44.1
	2.  <a href="#preturn">$return</a>	return from a $proc macro			8.44.2

    45.	<a href="#root">$root</a>		end of a structured name space which was	
			begun with $tree, $branch or $record		8.45

    46.	<a href="#set">$set</a>		assign value to a reassignable label		8.46

    47.	<a href="#set_option">$set_option</a>							8.47

	1.		<a href="#set_option">set option flags</a>				8.47.1

	2.		<a href="#set_interact">Interaction of Run Options</a>
			<a href="#set_interact">and $list / $plist Directives</a>			8.47.2

    48.	<a href="#snap">$snap</a>		list the label table				8.48

	1.  $snap		load order or -y sorted			8.48.1
	2.  $snap,[1]	2	dynamic labels table			8.43.2
	3.  $snap	3	list labels [and macro text]		8.48.3
	4.  $snap, 1		1st pass				8.43.4

    49.	<a href="#sterm">$sterm</a>		set the substring sentinel symbol		8.49
    50.	<a href="#store">$store</a>		set the default output file name		8.50

    51.	<a href="#suffix_directive">$suffix</a>		suffix-determined  number string notation	8.51

    52.	<a href="#text">$text</a>		translate input text patterns			8.52

    53.	<a href="#trace">$trace</a>		display value of expression			8.53
	1.  $trace	2nd pass display				8.53.1
	2.  $trace, 1	display both passes				8.53.2

    54.	<a href="#tree">$tree</a>		head of structured name space			8.54

    55.	<a href="#twoscomp">$twos_complement</a>						8.55
	1.  $twos_complement	1	2s complement, default		8.55.1
	2.  $twos_complement	0	1s complement			8.55.2


    56.	<a href="#word">$word</a>		declare size of target computer word		8.56
    57.	<a href="#xqt_i">$xqt_i</a>		run-time integer algorithm plotter		8.57
    58.	<a href="#xqt_fp">$xqt_fp</a>		run-time floating algorithm plotter		8.58
    59.	<a href="#zcp">$zero_code_point</a>  character string escaped zero value		8.59



9.  <a href="#file_formats">Output File Formats, Relocation and Linking</a>
    Giant Address Spaces, Interfacing with GNU Tools			9

    1.	<a href="#txo">Text Encoded Binary Format, S-Records and Intel Hex Records</a>	9.1

    2.	<a href="#linking">Relocation, Linking, Giant Address Space</a>
	<a href="#linking">and Interfacing with GNU Tools</a>					9.2

	1.  <a href="#relinfo">Relocation Information in Text Encoded Binary</a>		9.2.1

	2.  <a href="#linkbasic">masmx Linking in Principle</a>					9.2.2

	3.  <a href="#linkdems">Demonstration Links</a>						9.2.3

	    1.	<a href="#link1">The Simplest Link</a>					9.2.3.1

	    2.	<a href="#link2">Link Collected by Sections</a>				9.2.3.2

	    3.	<a href="#link3">Link Specific Segments</a>					9.2.3.3

	    4.	<a href="#link4">Link an Output Relocatable</a>				9.2.3.4

	    5.	<a href="#link5">Link an Accumulated Relocatable</a>
		<a href="#link5">plus a New Relocatable</a>					9.2.3.5

	    6.	<a href="#link6">Incremental Link</a>					9.2.3.6

	    7.	<a href="#link7">Link in Giant Address Space</a>				9.2.3.7

	    8.	<a href="#link8">Incremental Link in Giant Address Space</a>			9.2.3.8

	    9.	<a href="#link9">Linking with Void Inclusion</a>				9.2.3.9

	    10.	<a href="#link10">Linking with void Inclusion</a>
		<a href="#link10">in Giant Address Space</a>					9.2.3.10


10. <a href="#describe">Describing Target Architecture in Text</a>				10

    1.  <a href="#describe1">Establishing Your Syntax</a>					10.1
    2.	<a href="#describe2">Describing the Target Architecture</a>				10.2
	1.  <a href="#architecture">$word, $byte, $quantum, $awidth</a>				10.2.1
	2.  <a href="#macro">$form, $proc, $name, $end</a>					10.2.2
	    1.	<a href="#uform">The $form Template</a>					10.2.2.1
	    2.	<a href="#uproc">The $proc Header</a>					10.2.2.2
	    3.	<a href="#uname">The $name Entry Point</a>					10.2.2.3
	    4.	<a href="#uend">The $end Macro Footer</a>					10.2.2.4
	    5.  <a href="#usample">Minimal Instruction Macro Example</a>			10.2.2.5
	    6.	<a href="#u2passproc">The Two-pass $proc</a>					10.2.2.6
	    7.	<a href="#uprocaside">The Out of Line $proc</a>					10.2.2.7
	    8.	<a href="#unested">Nested Macro Descriptions</a>				10.2.2.8
    3.  <a href="#legacyx">Synthesising Legacy Automatic Macros</a>				10.3
	1.  <a href="#legacyfun">Synthesising Legacy Functional Macros</a>			10.3.1
	2.  <a href="#legacycom">Synthesising Legacy Command Macros</a>				10.3.2

11. <a href="#afloat">Alternative Floating Formats</a>					11
    1.	<a href="#masmxfloat">masmx Floating Format</a>						11.1
    2.  <a href="#fdemens">Floating Format Dimensions</a>					11.2
	1.  <a href="#fdemens1">Floating Number Size</a>					11.2.1
	2.  <a href="#fdemens2">Exponent Field Size</a>						11.2.2
    3.	<a href="#ieeefloat">IEEE754 Floating Values</a>						11.3
	1.  <a href="#fpdifferences">Differences between masmx Floating Format and IEEE754 Floating Formats</a>
									11.3.1
	2.  <a href="#ieeemacro">Macro Language generating IEEE754 Floating Constants</a>	11.3.2




Appendix A: <a href="#commandline">masmx Command Line</a>
	 A.a:	<a href="#clopts">Command Line Option Flags</a>
	 A.b:	<a href="#uclopts">Switch and Trace Option Flags for Developer Use</a>

Appendix B: <a href="#whatsnew">What's new in 7r3?</a>
Appendix C: <a href="#roadmap">The masmx Product Road Map</a>
Appendix D: <a href="#languages">masmx's Potential for High Level Languages</a>

Appendix E: <a href="#fixing">Tuning Macro Language and Fixing Problems</a>
	 E.1:	<a href="#paramrefix">Fixing a Macro Parameter Reference</a>
	 E.2:	<a href="#labelrefix">Label Cannot Be Referenced</a>
	 E.3:	<a href="#labelrefind">Changed Label Value Disappears</a>
	 E.4:	<a href="#walkingmacro">Tracing Macro Expansion</a>
	 E.5:	<a href="#alias_fun">Aliasing masmx Internal Functions</a>
	 E.6:	<a href="#labelshifted">Diagnostic about a Label Address or Literal Table Start Address</a>
	 E.7:	<a href="#labelhidden">Label fails to be Exported</a>

Appendix F: <a href="#targets">Target Descriptions</a>
	 F.1:	<a href="#8051">8051</a>
	 F.2:	<a href="#powerpc">PowerPC</a>

	 F.3:	<a href="#definitions">Definition Examples</a>
	 F.3.1:	<a href="#coldfire">ColdFire</a>
	 F.4:	<a href="#alignments">Byte-Addressing Machines with 32 and 64 Bit Bus</a>
		<a href="#alignments">Managing Alignments</a>

Appendix G: <a href="#disclaimer">Disclaimer and Contact</a>

</pre>


<a	name="cando"/>
<h1>1: masmx Can Do</h1>

<a	name="any"/>
<h2>1.1: Any Target Architecture</h2>

<p>
Target architecture is described to masmx in macro language. See


	<blockquote>
	<a href="#start">3:  Getting Started</a><br><br>

	<a href="#describe2">10.2: Describing the Target Architecture</a><br><br>
	<a href="#describe">10: Describing Target Architecture in Text</a>
	</blockquote>

<a	name="syntax"/>
<h2>1.2: Any Syntax</h2>

<a	name="legacy"/>
<h3>1.2.1: Legacy Source Code Unchanged</h3>

<p>
Include files define imported syntax to masmx.
Existing source code assembles unchanged

<p>
masmx interprets imported notation for code, data and even
arithmetic and manipulation operators 

<p>
See  <a href="#describe1">10.1: Establishing your Syntax</a>


<a	name="notate1"/>
<h3>1.2.2:  Number String and Character String Notation</h3>


Number and character strings are assembled in
<a href="#nstring">masmx native notation</a>,
<a href="#cstring">C-Language notation</a>,<br>
<a href="#motorola">Motorola Old Notation</a> or
<a href="#suffix">suffix-determined notation</a>

<p>
See <a href="#notate2">4.2.2.1: Number Strings</a> and <a href="#expression">4.2: Expressions</a>

<a	name="anyword"/>
<h2>1.3: masmx is for Any Word Size</h2>


<p>
Code and data are assembled in multiples of words. Directive $word
defines the size of a word from 1 to 192 bits

<p>
Integer and floating values are computed to 192-bit precision

<p>
Integer constants occupy by default their containing number of words


<a      name="anydress"/>
<p>
<h2>1.4: masmx is for Any Address Space</h2>

masmx assembles absolute or relocatable code

<p>
masmx can construct absolute arrays and instruction segments to fit
in address spaces up to 1*/192 bits.

<p>
Absolute and relocatable object code may be incremented
with new source or relocatable code

<p>
A masmx link is an assembly which uses masmx linker features.
Text-encoded-binary files are included<br>plus macro
text which processes text-encoded-binary.
See <a href="#linkbasic">9.2.2: masmx Linking in Principle</a>

<p>
The memory space in programs may be larger than any known file systems,<br>
if load code distribution in target memory is below saturation<br>
to the degree that the developer platform file system contains it

<p>
Base-displacement addressing modes are supported for accessing data or code<br>
at high effective addresses beyond the direct-address range of instruction sets.<br>
Data segments in 32-bit and 64-bit PowerPC<br>are an example of base-displacement addressing.<br>
See <a href="#sections">7: Constructing Program Sections</a>

<a      name="anyfloat"/>
<h2>1.5: masmx is for Any Floating Point Format</h2>

masmx default floating constant size is 96 bits rounded from 192 bits

<p>
Internally generated 192-bit floating values have 23-bit midpointed exponent
and 168-bit fractional mantissa
<pre>

	__________________________________________________________________
	|s|190 exponent 168|167          mantissa                       0|
	|_|________________|_____________________________________________|

</pre>
Negative polarity is represented with the entire value in 1s complement

<p>
Floating constants are by default rounded with three guard bits 111. This rounding pattern can be<br>
replaced on the command line and during assembly with one the the four option flags <a href="#optro">-EFGH</a>.<br>
Asserting one of these options overrides the previously opted rounding pattern

<p>
Size, layout and representation of floating constants are programmable. Floating constant values are<br>
 derived from masmx 192-bit internal floating values. There is no restriction on target representations.<br>
Macro code can achieve any representation

<p>
Supplied macros generate <a href="#ieeemacro">IEEE754</a> floating constants in 32-bit,
64-bit and 128-bit formats,<br>
and in the popular non-IEEE754 80-bit representation

<p>
IEEE754 floating formats have an unrepresented integral bit. A sign flag alone 
represents polarity.
<pre>


	_____________________________________
	|s|exponent|mantissa fractional part|
	|_|________|________________________|
	          ^
	         |1| <- the unrepresented normalising integral bit

</pre>
For a given value IEEE754 formats encode the exponent at 2 less than masmx
native format
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	$word	32
	$quantum 8
	1.875	. masmx format positive value
	-1.875	. masmx format negative value
	$list	0
	$include ieee754.def
	$list
	ieee754_64	1.875	. ieee754 format positive value
	ieee754_64	-1.875	. ieee754 format negative value
	$end
  :                            1  $word 32
  :                            2  $quantum 8
00:00000000 400001F00000000000000000
                              +3  1.875 . masmx format positive value
00:0000000C BFFFFE0FFFFFFFFFFFFFFFFF
                              +4  -1.875 . masmx format negative value
  :                            90  $list
00:00000018 3FFE000000000000  +91  ieee754_64 1.875 . ieee754 format positive value
00:00000020 BFFE000000000000  +92  ieee754_64 -1.875 . ieee754 format negative value
  :                            93  $end
:$(00):00000000:00000028 
 
</pre>
The included macro package for generating IEEE754 constants is explained in<br>
section <a href="#ieeefloat">11.3: IEEE754 Floating Values</a>


<a      name="strip1"/>
<h2>1.6: Structured Data and Structured Code Name Spaces</h2>

<a      name="stridata"/>
<h3>1.6.1:  Structured Data</h3>

masmx can construct complex hierarchical data.
See <a href="#structure">5: Iterated Coded and Structured Data</a>


<a      name="stribata"/>
<h3>1.6.2: Bit-Aligned Structured Data</h3>

masmx can construct and label complex hierarchical data which does not map to the target architecture<br>
but instead groups and overlays bit-fields of arbitrarily large size.
See <a href="#bstradata">5.2.3: Bit-Aligned Structures</a><br>
masmx solves a problem which has produced noticeable difficulty for compiler writers


<a      name="bitaccess"/>
<h3>1.6.3: Accessing Bit-Aligned Structured Data</h3>

masmx naming techniques allow macro code to read and write complex bit-aligned data.
See <a href="#record_macro">5.2.3.2: Macro Code Access to Bit-Aligned Structures</a><br>
This feature handles bit-field structures and overlays of any complexity consistently and efficiently

<a      name="strip2"/>
<h3>1.6.4: Repeat Data</h3>

masmx generates repeating data and data structures with the $do directive and subscripted labels.<br>
See <a href="#structure">5.1: $do and Macros</a> and <a href="#labels">4.1:Labels</a>


<a      name="streaf"/>
<h3>1.6.5: Functionally Compartmented Name Spaces</h3>


Hierarchic label structures can be used to compartment name spaces like languages structured by function.<br>
See <a	href="#name_space">5.2.2.4: Structured Code Name Spaces</a>



<a      name="strun"/>
<h2>1.7: Run-Time Algorithm Plotting</h2>


Directives $xqt_i and $xqt_fp combine with target-specific macro language to translate algorithmic expressions<br>
with run-time variable tokens into an instruction plan.
See <a href="#ialgors">6.1: Run-Time Integer Algorithm Plotter</a> and<br>
<a href="#fpalgors">6.2: Run-Time Floating Algorithm Plotter</a>

<p>
This feature is more compiler-like than assembler-like and allows algorithms involving run-time variables<br>
to be coded in the form of algebraic expressions


<a      name="developer"/>
<h1>2: Developer Environment</h1>

masmx developer environment is a shell

<p>
Assembly examples in this document are captures from the Unix
bash shell

<p>
masmx on Microsoft platforms runs with the simple shell
sometimes called the DOS screen or command prompt

<p>
The command line is documented at <a href="#commandline">Appendix A: masmx Command Line</a>


<a      name="start"/>
<h1>3: Getting Started</h1>

masmx does not know a computer architecture when it begins to run. 
The developer begins the initial source file with a line like:
<pre>

	$include        target.def

</pre>
Initially masmx knows directives ($include is a directive) 
and some special names representing internal functions, like $ 
which means "location counter"

<p>
Wrappers may be constructed to include headers without altering
existing source. File includes may be extensively nested
<pre>

	$list	0
	$include	target.def
	$list	2
	$include	existing_application.msm

</pre>
masmx internal directives and functions can be aliased to suit existing code.
Directives of other assemblers can also be constructed as macros

<p>
A definition file included at the head of the assembly defines: 

	<blockquote>

	assembly language syntax<br><br>

	directive and function rename and resynthesis<br><br>

	computer word size, up to 192 bits<br><br>

	initial data byte size<br><br>

	target data code, default ASCII<br><br>
 
	address space<br><br>

	address quantum<br><br>

	any address space segmentation or partitioning<br><br>

	register sets and names<br><br>

	instruction set<br><br>

	any pseudo-instructions used to generate constants<br><br>

	integer encoding and floating point formats<br><br>

	</blockquote>


See <a href="#describe1">10.1: Establishing Syntax</a>,
<a href="#describe2">10.2: Describing Target Architecture</a>,
<a href="#legacyx">10.3: Synthesising Legacy Macros</a>

<a      name="sourceline"/>
<h1>4: The Assembly Language Source Line</h1>

<p>
The line of assembly language code has an arbitrary number of fields
<pre>

[label]	[command]	[argument1[,argument1_subfield2,...]]	[argumentN[,argumentN_subfield2,...]]	[. comment ]

</pre>
Lines may be continued. The default continuation symbol ; can be changed with directive $cont_char
<pre>

[label]	[command]	[argument1[,argument1_subfield2,...]]	;
			[argument2[,argument1_subfield2,...]]	;
			[argumentN[,argumentN_subfield2,...]] 

</pre>

Argument subfields may be divided into substrings with the current $sterm symbol
<pre>

	[command]	[substring[:substring][, substring:substring..]]	[argument2..

</pre>

See <a href="#argument_ref">4.2.2.5: Macro Parameters</a>


<a	name="labels"/>
<h2>4.1: Labels</h2>

A label starts in column one and ends in whitespace. A label may contain
<pre>

	letters digits $ _ ? ! @ :

</pre>
and a label starts with a letter or [ _ ? ! @ : ]

<p>
: in this list of legal label characters represents the substring separator which is
default colon : but may be another value, often period . 

<p>
If for example period . is chosen for substring character
<pre>

	$sterm	'.'

</pre>
then the list of legal label characters becomes
<pre>

	letters digits $ _ ? ! @ .

</pre>
and a label starts with a letter or [ _ ? ! @ . ]

<p>
A reference containing substring separator may reference a simple label or a structured location.
See <a href="#stradata">5.2: Structured Data and Structured Code Name Spaces</a>

<p>
A label may also start with $ and is then declared in quotes
<pre>

"$mylabel"

</pre>

<div    style="color:A0A0A0">
<blockquote>
$ in column one is a location counter switch.<br>
A location counter switch is a program section control with syntax <b>$(number[:attributes])</b><br>
See <a href="#sections">7: Constructing Program Sections</a>
</blockquote>
</div>

<p>
A label declared in quotes starts with anything and contains anything

<p>
Without case-sensitive <a href="#option_k">option -k</a> all labels and references are translated to uppercase

<p>
A label may have an arbitrary number of subscripts
<pre>

<i>label(5,7,600)</i>

</pre>
Each subscripted instance is a different label

<p>
Reference to a subscripted label which does not exist
retrieves the count of similar labels with one subscript more 

<p>
A label <i>label_stem(<b>4,1,20</b>)</i> is for example the
count of labels <i>label_stem(<b>4,1,20</b>,&xi;)</i>

<pre>
        <i>
        label_stem(<b>4,1,20</b>,5)<br>
        label_stem(<b>4,1,20</b>,20)<br>
        ...</i>

</pre>

If no instances exist either, then the reference has the value of zero because it
counts an empty set

<p>
There is no requirement for label subscripts to fill a number space
continuously or evenly
<p>
Subscripted labels need not be in ascending order or any order, but may be
generated by loop control
<pre>

MANY	$set	65536

index	$do	MANY,a_name(MANY+1-index)	99*index

</pre>
The assembler normalises subscript integer expressions to a decimal
digit string when inserting or referencing subscripted labels.

<p>
For example, the first two repeats of the $do above generate
<pre>

a_name(65536)	99*1
a_name(65535)	99*2

</pre>
and the last three generate
<pre>

a_name(3)	99*65534
a_name(2)	99*65535
a_name(1)	99*65536

</pre>
Macros generate and use labels which are discarded at the end of the macro expansion.<br>
Labels only remain available to the invoking level of assembly if they are promoted with trailing asterisk
<pre>

$ masmx -lnxk visible visible
MASMX 7r3
3/visible.msm
  :                            1 macro1*	$proc
  :                            2 	macro2
  :                            3 visible* $equ	invisible
  :                            4 	$end
  :                            5 
  :                            6 macro2* $proc
  :                            7 macro3* $proc
  :                            8 manifest****
  :                            9 private***
  :                            10 unseen
  :                            11 invisible**
  :                            12 	$end
  :                            13 	macro3
  :                            14 	$end
  :                            15 
  :                            16 $(14:0E000)
  :                            17 	macro1
  :                            18 	$end
macro1=:P1:0:000000
macro2=:P1:0:000001
manifest+=$0E:00E000
private=$0E:00E000
visible=00E000
visible.msm=0<000003
:$(0E):00E000:00E000 
visible.msm: object code 47 bytes: 0 errors: 0 undefined labels
$
$ cat visible.txo

+manifest:$0E:00E000
:$0E*000000:00E000:00E000
$

</pre>
<p>
One asterisk is added to promote a label one  macro level. An asterisk at the main
assembly level externalises the label

<p>
A label declared at the main assembly with <b>$set</b> directive cannot accidentally
be exported from the assembly by subsequent sets.<br>
<b>$set</b> labels may be changed in value but a label global to the assembly
cannot be changed to an exported label

<p>
Macros can therefore use many asterisks to make sure they are updating a
global <b>$set</b> label and not a nested macro-local <b>$set</b> label.<br>
A label name initially set to the inclusion level of the main assembly is
not accidentally exported. In this sample assembly the output file<br>
does not contain an exported label, or in this case anything at all
<pre>

$ masmx attestor -lnx
MASMX 7r3
3/attestor.msm
*EOF*
  :                            1 "$$local"	$set	1
  :                            2 
  :                            3 outward*	$proc
  :                            4 "$$local"******	$set	2
  :                            5 		$end
  :                            6 
  :                            7 		outward
  :                            8 
*EOF*
$$LOCAL=000002
OUTWARD=:P1:0:000000
attestor.msm=0<000003

attestor.msm: object code 0 bytes: 0 errors: 0 undefined labels
$ cat temp.txo
$


</pre>

<a      name="expression"/>
<h2>4.2: Expressions</h2>
<a      name="operator"/>
<h3>4.2.1: Operators</h3>
	
Operators by rank are
<pre>

	()

	^=	=

	^&gt;	&gt;

	^&lt;	&lt;

	--

	++

	/*

	*/	*/-

	**

	*+	*-

	+	-

	*	/	//	///

	&plusmn;	^unary

</pre>
Operators in the same rank have left-to-right precedence as they are
encountered in the expression

<p>
Operators of higher rank are evaluated first and operated last.<br>
An expression generates an integer until a decimal exponent operator *+ *- is actioned or a
decimal point is encountered

<p>
The operators are 
<pre>


	_________________________________________
	|	=	|	equal		|	=  : 1 else 0
	|_______________|_______________________|
	|	^=	|	unequal		|	=  : 0 else 1
	|_______________|_______________________|
	|	&gt;	|	greater		|	&gt;  : 1 else 0
	|_______________|_______________________|
	|	&lt;	|	less		|	&lt;  : 1 else 0
	|_______________|_______________________|
	|	^&gt;	|	not greater	|	&gt;  : 0 else 1
	|_______________|_______________________|
	|	^&lt;	|	not less	|	&lt;  : 0 else 1
	|_______________|_______________________|
	|	--	|	XOR		|
	|_______________|_______________________|
	|	++	|	OR		|
	|_______________|_______________________|
	|	/*	|	shift right	|
	|_______________|_______________________|
	|	*/	|	shift left	|
	|_______________|_______________________|
	|	*/-	| right	shift algebraic	|
	|_______________|_______________________|
	|	**	|	AND		|			
	|_______________|_______________________|		
	|	*+	|      +decimal exponent|
	|_______________|_______________________|	decimal scale operators *+ *- exponentiate
	|	*-	|      -decimal exponent|	one integer value decimally by another, or
	|_______________|_______________________|	a fraction string by a decimal scale
	|	+	|	PLUS		|
	|_______________|_______________________|
	|	-	|	MINUS		|
	|_______________|_______________________|
	|	*	|	MULTIPLY	|
	|_______________|_______________________|
	|	/	|	DIVIDE		|
	|_______________|_______________________|
	|	//	|	covered quotient|
	|_______________|_______________________|
	|	///	|	remainder	|
	|_______________|_______________________|

							^unary is 1s complement
							for scope of unary + - ^ see <a href="#nconstant">number constants</a>

Only	+	PLUS
	-	MINUS
	**	AND
	/*	SHIFT RIGHT
	*/-	SHIFT RIGHT ALGEBRAIC may be applied to relocatable tokens


	+ PLUS - MINUS may operate without restriction on mixed relocatable
	and absolute tokens	

	The token left of ** AND may be relocatable, not the mask. AND applied
	to a relocatable token suppresses range checking at the link step

	SHIFT RIGHT and SHIFT RIGHT ALGEBRAIC shift the final relocated value
	A shift count may not be relocatable

	/* SHIFT RIGHT shifts the relocated value logically right and range-checks unsigned

	shift left operator */ with negative shift count is SHIFT RIGHT ALGEBRAIC.
	Range check at link is signed. The target field contains at least one sign bit.
	The relocated value is shifted right algebraically


$ ../masmx relarith -lnk
MASMX 7r3
3/relarith.msm
*EOF*
  :                            1 	$word		32
  :                            2 	$quantum	8
  :                            3 
  :                            4 ABSOLUTE	$equ	-4096
  :                            5 MINUS8		$equ	-8
  :                            6 $(5:*1)
  :                            7 relocatable	$res	1
  :                            8 $(6:06000)
  :                            9 
(+05:00000000/*10)20+
06:00006000 00000000          +10 	+	relocatable*/-16	. signed range check after relocation
  :                            11 					. shift right algebraic 16 positions
  :                            12 
(+05)20+
06:00006004 00000000          +13 	+	relocatable*/-0		. signed range check after relocation
  :                            14 					. shift no positions
  :                            15 
(+05:00000000/*10)20+
06:00006008 00000000          +16 	+	relocatable*/(-16)	. signed range check after relocation
  :                            17 					. shift right algebraic 16 positions
  :                            18 
06:0000600C FFFFFFF0          +19 	+	ABSOLUTE*/MINUS8	. shift right algebraic 8 positions at assembly time
06:00006010 FFFFFFF0          +20 	+	ABSOLUTE*/-8		. shift right algebraic 8 positions at assembly time
06:00006014 00FFFFF0          +21 	+	0FFFFF000/*8		. shift right logical 8 positions at assembly time	
  :                            22 
(+05:00000000/*08)20
06:00006018 00000000          +23 	+	relocatable/*8		. unsigned range check after relocation
  :                            24 					. shift right logical 8 positions
  :                            25 
(+05:00000000/*0c)20+
[+0000:00000000/*0c]20+
06:0000601C 00000000          +26 	+	relocatable+EXTERNAL*/-12 . signed range check after relocation
  :                            27 					. shift right algebraic 12 positions
  :                            28 
(+05:00000000/*08)20+
06:00006020 00000000          +29 	+	relocatable*/MINUS8	. signed range check after relocation
  :                            30 					. shift right algebraic 8 positions
*EOF*
:$(05):00000000:00000001 :$(06):00006000:00006024 


</pre>


<a      name="xtoken"/>
<h3>4.2.2: Tokens</h3>

<a      name="notate2"/>
<h4>4.2.2.1: Number Strings</h4>

<a      name="nstring"/>
<h4>4.2.2.1.1: masmx Native Number and String Notation</h4>

Native masmx interprets number strings with leading zero as hex or
octal, depending <a href="#octal">$octal</a>
or default <a href="#hex">$hex</a> directives. Leading digit
1..9 means decimal

<p>
By default 1000 and 03e8 mean one thousand

<p>
With directive $octal <a href="#octal">$octal</a> 1000 and 01750 mean one thousand
<pre>

	$octal		.	numbers with leading zero are octal
	.
	.
	$hex		.	numbers with leading zero are hex again

</pre>
<p>
character strings are space filled to containing word in absence
of -z Flag. Escaped values are typed as integers between quoted
substrings as
<pre>

	"substring":INTEGER_EXPRESSION:"substring"

</pre>
If the substring delimiter is changed with for example
<pre>

	$sterm	'.'

</pre>
then escape sequence is
<pre>

	"substring".INTEGER_EXPRESSION."substring"

</pre>
A digit string starting \ is bit-pattern
<pre>


$ masmx -ln
MASMX 7r3
0/-INPUT>>
	40960++2560++0aa0000++\10101010
        $end
00:000000 000000AAAAAA        +1  40960++2560++0aa0000++\10101010
  :                            2  $end


</pre>

<p>

Characters in apostrophe are right justified value strings

<p>
Each character produces its value in the current data code and
$byte size, default 8 bits
<pre>


MASMX 7r3
3/immediat.msm
*EOF*
  :                            1         $word   32
00:00000000 0000006168657245  +2         'ahere'-32
*EOF*
:$(00):00000000:00000002 
immediat.msm: object code 62 bytes: 0 errors: 0 undefined labels


</pre>
The default data code $ascii means more exactly characters unchanged from source input and may therefore be<br>
ASCII extended to Roman-8 or UTF-8. These have the same code points 0..127 as ASCII

<p>
Character value string tokens are available to expressions whatever the
current number string notation

<p>
See also directives <a href="#ascii">8.1 $ascii</a>,
<a href="#data_code">8.8: $data_code</a> and
<a href="#byte">8.5: $byte</a>

<p>
If apostrophe has been chosen as the quote character, a command
token starting apostrophe is a left-justified byte string<br>
and not an integer value string, but quoted tokens in expressions are value
strings, not labels
<pre>

$ masmx -lnkz
MASMX 7r3
0/-INPUT>>
	$word		16
	$quantum	8
	$awidth		24
	$quote		''''
QDELIM='
$(10:0A0000)
place
	+place		. label reference
	+'place'	. value string
	'place'		. byte string
	$end
  :                            1  $word  16
  :                            2  $quantum 8
  :                            3  $awidth  24
  :                            4  $quote  ''''
  :                            5 $(10:0A0000)
  :                            6 place
0A:0A0000 000A0000            +7  +place   . label reference
0A:0A0004 00706C616365        +8  +'place' . value string
0A:0A000A 706C61636500        +9  'place'  . byte string
  :                            10  $end
:$(0A):0A0000:0A0010 


</pre>
If quote symbol remains at default " then a value string ' is recognised
at the start of the command field and quoted labels are recognised in
expressions

<p>
It is not in simple cases necessary to reference labels in quotes, but macro
text in some circumstances must

<pre>

$ masmx -lnkz
MASMX 7r3
0/-INPUT>>
	$word		16
	$quantum	8
	$awidth		24
$(10:0A0000)
place
	+place		. label reference
	+'place'	. value string
	'place'		. value string
	+"place"	. label reference
	"place"		. byte string
	$end
  :                            1  $word  16
  :                            2  $quantum 8
  :                            3  $awidth  24
  :                            4 $(10:0A0000)
  :                            5 place
0A:0A0000 000A0000            +6  +place    . label reference
0A:0A0004 00706C616365        +7  +'place'  . value string
0A:0A000A 00706C616365        +8  'place'   . value string
0A:0A0010 000A0000            +9  +"place"  . label reference
0A:0A0014 706C61636500        +10  "place"  . byte string
  :                            11  $end
:$(0A):0A0000:0A001A 

</pre>

Option -m <a href="#motorola">4.2.2.1.3: Motorola Old Number Notation</a> masks labels
beginning with $ or @ unless they are referenced in quotes



<a      name="cstring"/>
<h4>4.2.2.1.2:  C-Language Number and Character String Notation</h4>

With Assembly Flag -c 1000 and 0x3e8 both mean one thousand and
leading zero without x or X is octal

<p>
-c Flag also zero-fills character strings to containing word unless
-z Flag is also asserted

<p>
-c Flag interprets character string \escaped values in both strings
and apostrophe-bounded value-string numbers 
<pre>

$ ~/masmx -lnkc
MASMX 7r3
0/-INPUT>>
	$word	64
	$quantum 8
	'ab\000c'
	"xy\xAAz"
	$end
  :                            1  $word 64
  :                            2  $quantum 8
00:00000000 0000000061620063  +3  'ab\000c'
00:00000008 7879AA7A00000000  +4  "xy\xAAz"
  :                            5  $end
:$(00):00000000:00000010 

</pre>

<a	name="motorola"/>
<h4>4.2.2.1.3:  Motorola Old Number Notation</h4>

Flag -m interprets
<pre>

	$hex
	@octal
	%bit_image

</pre> 
<a      name="suffix"/>
<h4>4.2.2.1.4:  Suffix-Determined Number Notation</h4>

Directive $suffix 2 interprets a notation flag
[<a style="color:blue">H h O o Q q B b D d</a>] after the number string
<pre>

	trailing H as hex
	trailing O or Q as octal
	trailing B as bit image
	trailing D as decimal <a style="color:blue">default</a>

</pre>
Directive $suffix 1 defaults leading zero to hex

<p>
Storage constant numbers in all notations may also have a storage  
words suffix [s d l t q p h o].<br>
See <a href="#nconstant">4.3.3: Number Constants</a>
and <a href="#suffix_directive">8.51: $suffix</a> directive


<a      name="labelref"/>
<h4>4.2.2.2: Label References</h4>


Labels of any type (storage location line labels, equates, function
macro names, $do loop tags) may be referenced in expressions
<pre>

	+       this*that+the_other

</pre>
Most labels return an absolute or a relocatable value. Some labels work
functionally and return a computed value.<br>
See <a href="#ifunction">4.2.2.3: masmx-Supplied Functions</a>
and <a href="#func_macro">4.2.2.4 Function Macro Reference</a>

<p>
Labels may be bounded with quotes on reference
<pre>

$ masmx -lnkz
MASMX 7r3
0/-INPUT>>
ab	$equ	40
	+"ab"		. a number expression with label reference
	"ab"		. a string
	'ab'		. a number expression
	$end
  :                            1 ab $equ 40
00:000000 000028              +2  +"ab"  . a number expression with label reference
00:000001 616200              +3  "ab"   . a string
00:000002 006162              +4  'ab'   . a number expression
  :                            5  $end
:$(00):000000:000003 

</pre>
A command field bounded with quotes is not an expression but a
left-justified string of arbitrary length space or zero padded to
containing word

<p>
If $quote has been changed to ' apostrophe, labels in ' will not be detected in expressions.
The character values between ' are right justified<br>
as values juxtaposed at current $byte size and translated from input to current data code,
default 8-bits and ASCII.<br>
See also directives <a href="#data_code">8.8 $data_code</a> and <a href="#byte">8.5 $byte</a>
<pre>


$ masmx -lnkz
MASMX 7r3
0/-INPUT>>
ab	$equ	40
	$quote	''''
QDELIM='
	+'ab'		. a number
	'ab'		. a string
	$end
  :                            1 ab $equ 40
  :                            2  $quote ''''
00:000000 006162              +3  +'ab'  . a number
00:000001 616200              +4  'ab'  . a string
  :                            5  $end
:$(00):000000:000002 


</pre>


<a      name="ifunction"/>
<h4>4.2.2.3: masmx-Supplied Functions</h4>

See also <a href="#internalf">4.7: masmx Internal Functions in Detail</a>

<p>

<p>
All labels internal to masmx, these internal function names and also
<a href="#Directives">directives plus subcommand names</a>
may <i>always</i> be referenced in lowercase.<br>
With <a href="#option_k">option -k</a> masmx-supplied names may <i>only</i>
be referenced in lowercase

<p>
Internal functions are in summary

<pre>


	$		<a href="#location_c">current location counter value</a>

	$(..)		<a href="#alocator">named location counter value</a>

	$a		<a href="#absolute">absolute value of current location counter</a>

			$a is similar to $ except

				$a can generate absolute constants of
				locations in base-displacement sections

				an argument to $a(..) is an expression
 				not a location counter identity

				an expression should start with
				an identifier in the target section: + a(<i>label</i>)

	$a(..)		<a href="#absolute_there">absolute value of expression</a>
                    	  
	$b		<a href="#sectionbase">start address of current program section</a>

			in link $include,$binary
			$b is relocated start address of the segment
                    	  
	$bank_index	<a href="#bix">current memory block identifier</a>
			where breakpoint addresses are used

	$n		<a href="#sname">macro call name</a>
			retrieves low-order 32 bits of
			<i>macro_label</i>(0, 0) value

	$net(..)	<a href="#snet">unrelocated value of expression</a>

	$o(..)		<a href="#oflag">value of an option flag</a>

	$r		<a href="#region">current location counter identity</a>

	$r(..)		<a href="#thatregion">location counter identity of named address</a>

	$rel		<a href="#relocation">relocation alignment of current program section</a>
			returns zero for absolute sections and nonzero
			for relocatable sections

	$rel(..)	<a href="#relocat_there">relocation alignment of named program section</a>
			returns zero for absolute sections and nonzero
			for relocatable sections

	$t(..)		<a href="#labeltyp">label type</a>

	$zenith		<a href="#zenith">high address of current section + literals</a>

	$zenith(..)	<a href="#azenith">high address of named section + literals</a>

</pre>
<a      name="func_macro"/>
<h4>4.2.2.4: Function Macro Reference</h4>

Function macros deliver a value to assembly-time expressions

<p>
Here a function log2 returns the power 2 which covers the value of the input integer

<p>
Lines 2..8 are the function macro. The other lines invoke it

<pre>

$ masmx log2.msm -lnkx
MASMX 7r3
3/log2.msm
*EOF*
  :                            1 
  :                            2 f	$func
  :                            3 log2*	$name
  :                            4 fulcrum	$set	f(1, 1)-1
  :                            5 	$do	fulcrum<1,	$return	0
  :                            6 log	$do	48,	$do	1*/log>fulcrum,	$return	log
  :                            7 	$return	-1
  :                            8 	$end
  :                            9 
  :                            10 log2:zero	$equ	log2(0)
  :                            11 log2:1		$equ	log2(1)
  :                            12 log2:2		$equ	log2(2)
  :                            13 log2:3		$equ	log2(3)
  :                            14 log2:15		$equ	log2(15)
  :                            15 log2:16		$equ	log2(16)
  :                            16 log2:17		$equ	log2(17)
  :                            17 log2:16383	$equ	log2(16383)
  :                            18 log2:16384	$equ	log2(16384)
  :                            19 log2:16385	$equ	log2(16385)
  :                            20 
*EOF*
log2=:N65:F:0:000000
log2:zero=000000
log2:1=000000
log2:2=$00:000001
log2:3=$00:000002
log2:15=$00:000004
log2:16=$00:000004
log2:17=$00:000005
log2:16383=$00:00000E
log2:16384=$00:00000E
log2:16385=$00:00000F
log2.msm=0<000003


</pre>

The assembly at <a href="#dotted">4.2.2.5</a> shows a function macro $net_ipv4 delivering a value which represents<br>
a network address composed from dotted decimal text

<p>
For more information on the construction of function macros see 4.2.5: Function Macros


<a      name="argument_ref"/>
<h4>4.2.2.5: Macro Parameter Reference</h4>


Macro actual arguments are accessed by using the label of 
the containing macro in a functional way
<pre>

p       $proc
add*    $name   1
	iform   p(0, 1), p(1, 1), p(1, 2)
	$end

</pre>
Actual arguments map to these reference paraforms when the $proc label is, for example, p 
<pre>


	command[,subcommand]	[argument[,argument,..]]	[argument[,..

	p(0,0)[, p(0, 2)]	[p(1, 1)[,p(1, 2),..]]		[p(2, 1)[,..


</pre>
The command is the first call-line word after any whitespace.
It is subfield zero of field 0, <i>macro_label</i>(0, 0)


<p>
A subcommand on the command is <i>macro_label</i>(0, 2)

<p>
Argument field numbers and their subfield numbers ascend from 1

<p>
The first subfield of the second argument field is referenced <i>macro_label</i>(2, 1)

<p>
Fields are separated by spaces. Subfields in a field are 
separated by a comma,[ and spaces]


<a	name="dotted">
<p>
There may also be substrings of subfields, separated by the 
substring character, default :

<p>
Here substrings have been counted and assembled as constants
containing network socket addresses

<p>
The $proc callname $net_socket is in the command field in order to generate a
constant.<br>
$net_socket obtains the value of the network part of the address
by referencing $func macro $net_ipv4

<p>
The default $sterm value : is temporarily changed to . for scanning dotted decimal
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
        $word	16
	$quantum 8

f       $func
"$net_ipv4"* $name

net     $set    0
        $sterm  '.'

?       $do     f(1, 1:),;
net     $set    net*/8++f(1, 1:?)

        $sterm  ':'

        $return net
        $end


"$netp" $form   32, 16

p       $proc
"$net_socket"* $name
        $netp   $net_ipv4(p(1, 1:1)), p(1, 1:2)
        $end

address_A	$net_socket	172.29.7.9:8080
address_B	$net_socket	172.29.6.8:23
	$end
  :                            1  $word 16
  :                            2  $quantum 8
  :                            3 
  :                            4 f       $func
  :                            5 "$net_ipv4"* $name
  :                            6 
  :                            7 net     $set    0
  :                            8         $sterm  '.'
  :                            9 
  :                            10 ?       $do     f(1, 1:),net     $set    net*/8++f(1, 1:?)
  :                            11 
  :                            12         $sterm  ':'
  :                            13 
  :                            14         $return net
  :                            15         $end
  :                            16 
  :                            17 
  :                            18 "$netp" $form   32, 16
  :                            19 
  :                            20 p       $proc
  :                            21 "$net_socket"* $name
  :                            22         $netp   $net_ipv4(p(1, 1:1)), p(1, 1:2)
  :                            23         $end
  :                            24 
00:0000 AC1D07091F90          +25 address_A $net_socket 172.29.7.9:8080
00:0006 AC1D06080017          +26 address_B $net_socket 172.29.6.8:23
  :                            27  $end
:$(00):0000:000C 



</pre>


<a      name="command"/>
<h2>4.3: The Command Field</h2>


The command field (the first field which is preceded by any
whitespace) can contain a directive, a constant,<br>
a name of a $proc macro, or the name of a $form template.
<pre>

[label] <i>command</i> [arguments]

</pre>



<a      name="directive"/>
<h3>4.3.1 Directives</h3>


Directives are commands to the assembler. They are listed in Section <a href="#Directives">8: masmx Directives</a>

<p>
Some directives control assembly settings, for example
<pre>

	$word		<i>BITS</i>
	$quantum	<i>BITS</i>
	$list		<i>INCLUDE_DEPTH</i>

</pre>
Others declare labels
<pre>

<i>label1</i>	$set	<i>VALUE</i>
<i>label2</i>	$equf	<i>VALUE1</i>, <i>VALUE2..</i>
<i>label</i>	$equ	<i>VALUE</i>
<i>label3</i>	$name	<i>VALUE</i>

</pre>
Others govern conditional assembly
<pre>

	$if		<i>CONDITION</i>
	$elseif		<i>CONDITION</i>
	$else
	$endif

</pre>
And other directives frame macros

<p>
All labels internal to masmx,
<a href="#Directives">directives plus masmx-supplied subcommand names</a> and
<a href="#ifunction">masmx internal functions</a> may <i>always</i> be referenced in lowercase.<br>
With <a href="#option_k">option -k</a> masmx-supplied names may <i>only</i> be referenced in lowercase


<p>
All directives may  be aliased to other names using the $equ directive,
and frequently are, for example
<pre>

.equ    $equ,"$directive"       "$equ"
.macro  $equ,"$directive"       "$proc"
.macend $equ,"$directive"       "$end"

</pre>
Quotes are used in these PowerPC examples in case flag -m (Motorola old number notation) is opted.<br>
The quotes force the "$xxxxxx" tokens to be seen as labels and not as hex strings.

<p>
Four directives, $word, $byte, $awidth, $quantum, work functionally in expressions and return the value which they have set

<p>
Both user macro functions and masmx internal functions need to
be in quotes to rename their functionality. Otherwise they work
functionally
<pre>

BYTE	$equ		    $byte  . BYTE equals the actual byte size in bits
setbyte	$equ,"$directive"  "$byte" . setbyte is the same directive (and function) as $byte

</pre>
<p>
See also <a href="#option_m">option -m</a>,
<a href="#motorola">Motorola old Number Notation (4.2.2.1.3)</a>, and
<a href="#option_Q">option -Q</a>

<p>

A token in the command field only begins with a quote if it is a <a href="#text_string">text string (4.3.5)</a>

<p>
Directive names and macro names always are recognised in the command field without quotes

<p>
All labels internal to masmx, <a href="#Directives">directives plus subfunction names</a> and
<a href="#ifunction">masmx internal functions</a> may <i>always</i> be referenced in lowercase.<br>
With <a href="#option_k">option -k</a> masmx-supplied names may <i>only</i> be referenced in lowercase

<p>
Number storage constants start with a digit, sign or single quote, or have the name
of a macro


<a      name="constant"/>
<h3>4.3.2: Storage Constants</h3>

For complex data constants see <a href="#structure"> 5: Iterated Code and Structured Data</a>
and <a href="#proc_call">4.3.7: $proc Macro Calls: Instructions and Structures</a> 

<p>
Simple data constants may be integers, microstructures of bit fields, 
floating numbers or text strings.


<a      name="nconstant"/>
<h3>4.3.3 Number Constants</h3>

Number items start with a digit, a unary operator or character values in apostrophe
<pre>

	+	INSTANCES*FACTOR
	15
	-8.5
	'xy'

</pre>

<p>
Unary + - ^ prepended to the first token of the constant expression
exerts polarity only on the first token

<p>
Unary + - ^ separated from the constant expression by whitespace
exerts polarity over the whole expression
<pre>


$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word		16
	$quantum	8

	1.875
	-2-2
	-	2-2
	$end
  :                            1  $word  16
  :                            2  $quantum 8
  :                            3 
00:0000 400001F00000000000000000
                              +4  1.875
00:000C FFFC                  +5  -2-2
00:000E 0000                  +6  - 2-2
  :                            7  $end
:$(00):0000:0010 

</pre>
Constants in apostrophe are character string values serving as numbers

<p>
The bytes are right-justified in the current data code and juxtaposed at the current $byte size
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	16
	$quantum 8     
$(12:65536)
	'abc'
	$data_code	97,65	. generate A for a
	'abc'
	$byte	12
	'abc'
	$ascii			. switch back to plain ASCII
	'abc'
	$byte	8
	'abc'++1*/28
	$end
  :                            1  $word 16
  :                            2  $quantum 8     
  :                            3 $(12:65536)
0C:10000 00616263              +4  'abc'
  :                            5  $data_code 97,65 . generate A for a
0C:10004 00416263              +6  'abc'
  :                            7  $byte 12
0C:10008 41062063              +8  'abc'
  :                            9  $ascii   . switch back to plain ASCII
0C:1000C 61062063              +10  'abc'
  :                            11  $byte 8
0C:10010 10616263              +12  'abc'++1*/28
  :                            13  $end
:$(0C):10000:10014 

</pre>
Number storage values are in canonical byte order, and the only way to change that is by implementing<br>
number constant commands (often with names like DW and DD) as macros.

<p>
Integer constants are self-sizing but may be tagged to determine their size in target storage.<br>
Assembly selects a default size for floating constants but the constant may be tagged to determine a different size
<pre>

	<i>expression:</i><a style = color:red>s</a>            . one storage word
	<i>expression:</i><a style = color:red>d</a>            . two storage words: or expression:<a style = color:red>L</a>
	<i>expression:</i><a style = color:red>t</a>            . three storage words
	<i>expression:</i><a style = color:red>q</a>            . four storage words
	<i>expression:</i><a style = color:red>p</a>            . five storage words
	<i>expression:</i><a style = color:red>h</a>            . six storage words
	<i>expression:</i><a style = color:red>Z</a>            . seven storage words
	<i>expression:</i><a style = color:red>o</a>            . eight storage words

</pre>
Size tags are case-independent irrespective of -k option.<br>
: colon is only necessary to disambiguate where
<pre>

	the last token in the expression is a label

	the last token in the expression is hexadecimal
	and the targeted storage two words

</pre>
It is never wrong to include : colon.
Parentheses round expressions and quotes round label references
can also disambiguate

Integers occupy their containing number of words in the absence of a length tag
<pre>

$ masmx ctest -lnk
MASMX 7r3
3/ctest.msm
*EOF*
  :                            1         $word   16
00:0000 00010000              +2         4096*16
00:0002 00100000              +3         4096*256
00:0004 01000000              +4         4096*4096
  :                            5 
  :                            6 likely  $equ    15        
  :                            7 what    $equ    3
  :                            8 how     $equ    -256
  :                            9 
00:0006 FFF0                  +10         ^       likely
00:0007 FFF3                  +11         ^likely++what
00:0008 FF03                  +12         ^likely**how++what
  :                            13 
00:0009 0060                  +14         100-4
00:000A 0005                  +15         100/20
00:000B 0005                  +16         +       99//20
00:000C 0004                  +17         80//20
00:000D 0005                  +18         81//20
00:000E 0013                  +19         99///20
00:000F 004162636465666768696A6B6C6D6E6F
                              +20         'abcdefghijklmno'-(32*/(('o'-'a')*8))
00:0017 FFFF0000              +21         -       4096*16
00:0019 FFF00000              +22         -       4096*256
00:001B FF000000              +23         -       4096*4096
00:001D FFA0                  +24         -       100-4
00:001E FFFB                  +25         -       100/20
00:001F FFFB                  +26         -       99//20
00:0020 FFED                  +27         -       99///20
00:0021 0001                  +28         2>1
00:0022 0000                  +29         +       1>2
00:0023 00380000              +30         0700000/*1
00:0025 700000000000000000000000000000000000000000000000
                              +31         0700000*/168
00:0031 380000000000000000000000000000000000000000000000
                              +32         +(0700000*/168)/*1
00:003D 700000000000000000000000000000000000000000000000
                              +33         7*/188
00:0049 0001                  +34         +       1<(7*/188)
00:004A 0000                  +35         +       1>(7*/188)
  :                            36 
00:004B 0063                  +37         99
00:004C 00000063              +38         +       99d
00:004E 000000000063          +39         +       99t
00:0051 0000000000000063      +40         99q
00:0055 00000000000000000063  +41         99p
00:005A 000000000000000000000063
                              +42         +       99h
00:0060 00000000000000000000000000000063
                              +43         99o
00:0068 FF88                  +44         +  (-8)*likely
00:0069 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF88
                              +45         +  (-8)*likely:o
00:0071 000F4240              +46         1000000
00:0073 01000000              +47         01000000
00:0075 000F4240              +48         1000000:l
00:0077 4240                  +49         1000000:s
  :                            50 
*EOF*
:$(00):0000:0078 


</pre>

If the last token in the expression is a label instead of a number string
then any length override must be preceded by colon, parenthesis or quote
<pre>

	+       <i>expression</i>:D
	+(<i>expression</i>)q
	+	"<i>label</i>"h

</pre>
Words flag D after a hex string also needs separation
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	16
	01d
	01:d  
	$end
  :                            1  $word 16
00:0000 001D                  +2  01d
00:0001 00000001              +3  01:d  
  :                            4  $end
:$(00):0000:0003 

</pre>
$suffix-determined number notation (<a href="#suffix">4.2.2.1.4</a>)
masks length flags [d q h o]<br> if the length flag is not separated.
Fraction strings containing decimal point are decimal and a suffix<br>
is interpreted as size in words and not as notation
<pre>

$ masmx suffix -lnk
MASMX 7r3
3/suffix.msm
CONT_CHAR=
LTERM=;
*EOF*
  :                            1 	$suffix	2
  :                            2 	$cont_char 0
  :                            3 	$lterm ';'
  :                            4 	$word	16
  :                            5 	$quantum 8
  :                            6 	$floating_point	80
  :                            7 	$characteristic	16
  :                            8 	$characteristic,64 12
  :                            9 
00:0000 007B                  +10 	123		; decimal notation, self-sizing
00:0002 00000000000000000000007B
                              +11 	+(123d)h	; decimal notation, hexaword
00:000E 123D                  +12 	123dh		; hex notation, self-sized
00:0010 00EA                  +13 	234		; decimal notation, self-sized
00:0012 009C                  +14 	234o		; octal
00:0014 009C                  +15 	234os		; single word octal
00:0016 0000009C              +16 	234ol		; octal double word
00:001A 0000001D              +17 	01dh:d		; hex double word
  :                            18 
00:001E 401C000000000000      +19 	1.5q		; fraction string, no notation suffix, quad
00:0026 40259502F90000000000  +20 	010q*+0ah	; octal mantissa, hex exponent, default 80 bits
00:0030 40259502F90000000000  +21 	8*+10		; same thing, just testing
00:003A 400007C80000000000000000
                              +22 	1.0h*+10b	; fraction string always decimal, hexaword
  :                            23 			; but bit-pattern exponent, result = 100
  :                            24 
*EOF*
:$(00):0000:0046 


</pre>
<p>
Floating point items are not auto-sized like integers.

<p>
Assembly selects a default size in words for floating constants <a href="#floating_point">$floating_point</a>.<br>
A size tag after the mantissa overrides the default
<pre>

        +(MANTISSA)[<a style="color:red">s d l t q p h z o</a>][{*+|*-}SCALE]

<a style="color:red">s S</a> for single (one word)
<a style="color:red">d D l L</a> for double
<a style="color:red">t T</a> for triple
<a style="color:red">q Q</a> for quadword
<a style="color:red">p P</a> for pentaword
<a style="color:red">h H</a> for hexaword
<a style="color:red">z Z</a> for heptaword
<a style="color:red">o O</a> for octaword

</pre>
<p>
These trailing letters may be upper or lower case and may have a
colon before them or parenthesis or quote, to avoid catenation
with label references
<pre>

67.5t

        +MANTISSA:<a style="color:red">q</a>*+1200000

        +(MANTISSA)<a style="color:red">p</a>*+800

        20*"MANTISSA"<a style="color:red">d</a>*+307

</pre>
Period may only appear in a decimal digit string. Where period
appears the scale notation [ e e+ e- E E+ E- ] can be typed in
place of the masmx scale operator <b>*+</b> or <b>*-</b>

<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
        $word           16
        $quantum        8
        $awidth         32
        $characteristic,64      16

expression      $equ    100
downscale       $equ    2

        1.6384d*+4
        +       expression:q*-downscale
        +       1.000000006768:pe+1200000
        $end
  :                            1  $word  16
  :                            2  $quantum 8
  :                            3  $awidth  32
  :                            4         $characteristic,64 16
  :                            5
  :                            6 expression $equ 100
  :                            7 downscale $equ 2
  :                            8
00:00000000 40F80000          +9  1.6384d*+4
00:00000004 4001800000000000  +10  + expression:q*-downscale
00:0000000C 7CD38AD1F1D10E50078D
                              +11  + 1.000000006768:pe+1200000
  :                            12  $end
:$(00):00000000:00000016


</pre>
<p>
Where period does not appear, only <b>*+</b> or <b>*-</b> scale
operator and not [ e e+ e- E E+ E- ] indicates a floating point number.

<pre>

        1.75
        175*-2

        298.5e1262611

</pre>

<p>
Floating numbers can be cached as label values and manipulated bitwise
into the floating format of the target architecture
<pre>

floating_value	$set	16384.0e+1000000

</pre>
A <a href="#set">$set,<i>subcommand</i></a> value can override the default
floating number size and mantissa rounding position.<br>
See also <a href="#fdemens">11.2: Floating Format Dimensions</a>

<p>
masmx internal floating precision is 192 bits with 168-bit simple fraction and 23-bit<br>
midpointed binary exponent equivalent in range to decimal exponents [+|-]1262611
<pre>


	191	     168 167							       0
	________________________________________________________________	_________
	|s|   exponent	|		fraction-only mantissa				|
	|_|_____________|_______________________________________________	________|


</pre>
masmx default floating numbers are a 192-bit value rounded to 96 bits,
with 72-bit simple fraction and 23-bit midpointed scale
<pre>

	95	      72 71					       0
	_________________________________________________________________
	|s|   exponent	|		fraction-only mantissa		|
	|_|_____________|_______________________________________________|


</pre>
Negative numbers are represented in 1s complement
<pre>

MASMX 7r3
3/fs32.msm
*EOF*
  :                            1 	$word	32
  :                            2 
00:00000000 400001C00000000000000000
                              +3         1.5
00:00000003 BFFFFE3FFFFFFFFFFFFFFFFF
                              +4         -	1.5
00:00000006 72B049CD0D73CF08E04D576E
                              +5         1.5*+1000000
00:00000009 0D4FB9B3C73F219697B1274F
                              +6         1.5*-1000000
*EOF*
:$(00):00000000:0000000C 

</pre>
The directive <a href="#floating_point">$floating_point</a> changes the default
96-bit total size of the stored floating-point constant

<p>
The <a href="#characteristic">$characteristic</a> directive sets the
characteristic size for a given floating <i>number_size</i>
<pre>

	$characteristic,<i>number_size</i>	<i>characteristic_width</i>

</pre>
Without <i>number_size</i> subcommand, <i>characteristic_width</i> is the characteristic field size<br>
applied to floating numbers of the current default size

<p>
characteristic width is the scale field + sign, or everything except the mantissa.<br>
So for example a target which supports the 80-bit coprocessor format with 15-bit exponent might have
<pre>

	$floating_point	80
	$characteristic	16

</pre>
$characteristic 8 means one sign bit and seven exponent bits:
<pre>


MASMX/24592 1r1X
FP32.msm 5
*EOF*  :                        1:         $word   32
  :                        2:         $floating_point 32
  :                        3:         $characteristic 8
  :                        4:         $characteristic,64 16
  :                        5:         $characteristic,128 20
  :                        6: 
00:00000000 41C00000      +7         +       1.5
00:00000001 4001C00000000000+8         +       1.5d
00:00000003 40001C00000000000000000000000000
			 +9         +       1.5q
*EOF*:$(00):00000000:00000007 


</pre>
The structure
<pre>

	mid-pointed-exponent/normalised-fractional-mantissa/1s-complement

</pre>
can be escaped with macro language

<p>
Macros supplied in this package generate IEEE754 floating constants. 

<p>
See <a href="#ieeefloat">11.3: IEEE754 Floating Values</a>

<p>
This example generates storage constants of value 1.375e+1200000 in masmx-internal format typed in various source syntax.<br>
A size override h for hexaword follows the fraction in each number, so the stored constants are all 192 bits
instead of the default 96 bits
<pre>


$ masmx -ln
MASMX 7r3
0/-INPUT>>
        $word   32
                1.375h*+1200000
                1.375he+1200000
                1375h*+1199997
floatup $set	137.5he1199998
floataway $set	1.375he1200000
floatalong $set 1.375h*+1200000
        +       floatup
        +       floataway
        +       floatalong
        $end
  :                            1         $word   32
00:00000000 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +2                 1.375h*+1200000
00:00000006 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +3                 1.375he+1200000
00:0000000C 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +4                 1375h*+1199997
  :                            5 floatup $set 137.5he1199998
  :                            6 floataway $set 1.375he1200000
  :                            7 floatalong $set 1.375h*+1200000
00:00000012 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +8         +       floatup
00:00000018 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +9         +       floataway
00:0000001E 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +10         +       floatalong
  :                            11         $end
:$(00):00000000:00000024 


</pre>
The decimal scale operator not only adds scale to a fraction string, but may also join two integer expressions<br>
to construct a floating number, with the mantissa taken from the left and the exponent from the right. Any length<br>
override is typed after the fraction and before the *+ *- operator
<pre>

$ masmx floating -lnky
MASMX 7r3
3/floating.msm
  :                            1 
  :                            2 	$word	48		. the word size of the target
  :                            3 				. processor architecture
  :                            4 
  :                            5 	$floating_point 96	. the default size of a floating constant
  :                            6 				. = 2 words
  :                            7 
  :                            8 	$characteristic		24	. the characteristic field width
  :                            9 					. for a 2-word floating number
  :                            10 					. 24 bits is the maximum characteristic
  :                            11 
  :                            12 	$characteristic,48	12	. the characteristic field width
  :                            13 					. for a 1-word floating number
  :                            14 
  :                            15 one     $equ    1
  :                            16 
00:000000000000 3FFFFDCCCCCCCCCCCCCCCCCD
                              +17 		1*-1		. floating recognised from operator
  :                            18 				. current default floating size
  :                            19 
00:000000000002 3FDCCCCCCCCD  +20 		1s*-one		. floating recognised from operator
  :                            21 				. single-word override
  :                            22 
  :                            23 
00:000000000003 3FFFFDCCCCCCCCCCCCCCCCCD
                              +24 		0.1		. floating recognised from fraction string
00:000000000005 3FDCCCCCCCCD  +25 		0.1s		. floating recognised from fraction string
  :                            26 				. single word override, 12-bit characteristic
  :                            27 
00:000000000006 3FFFFDCCCCCCCCCCCCCCCCCD
                              +28 		1.0e-1		. fraction string followed by e+ e- punctuation
  :                            29 
00:000000000008 3FFFFDCCCCCCCCCCCCCCCCCD
                              +30 	+	one*-one	. floating recognised from operator
  :                            31 				. mantissa / exponent expressions
  :                            32 				. contain any integer tokens
  :                            33 
00:00000000000A 3FDCCCCCCCCD  +34 		1s*-1		. expression sizes and rounds at
  :                            35 				. one-word override
  :                            36 
  :                            37 
00:00000000000B 3FFFFDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCD
                              +38         	1q*-one		. four-word override
  :                            39 
00:00000000000F 3FDCCCCCCCCD  +40 		1.0s*-one  	. exponent string can be any integer tokens
  :                            41 
00:000000000010 401800000000404A00000000407C8000000040AFA0000000
                              +42 		1s*+0, 1s*+1, 1s*+2, 1s*+3q	. four words,
  :                            43 						. four floating numbers
  :                            44 
  :                            45 tagged	$equ	163.84e+2
00:000000000014 40000F800000000000000000
                              +46 	+	tagged
  :                            47 
  :                            48 	$end
:$(00):000000000000:000000000016 


</pre>

<a      name="commas"/>
<h3>4.3.4: Split Number Constants</h3>


A split number constant is a small list of equal size fields. The size of the total is one word.<br>
The suffixes [d l t q p h o] can make the size  two, three, four, five, six or eight words.

<p>
Split number constants have commas between the fields
<pre>

$ masmx commas -lnk
MASMX 7r3
3/commas.msm
*EOF*
  :                            1         $word   48
00:000000000000 41C03DCD41F0  +2 		1.5, 1*-1, +1.875
00:000000000001 40CCCD40E667  +3 		0.8, 0.9
00:000000000002 666677778888  +4                 06666, 07777, 08888
00:000000000003 0A0B0C0D0E0F  +5                 10, 11, 12, 13, 14, 15
00:000000000004 FFF00AFFF00B  +6                 -1, +10, -1, +11
00:000000000005 123456789ABC  +7                 1,2,3,4,5,6,7,8,9,10,11,12
  :                            8 left    $equ    0aaaaaaaaaaaaaaaaaaaaa
  :                            9 centre  $equ    0bbbbbbbbbbbbbbbbbbbbb
  :                            10 right   $equ    0ccccccccccccccccccccc
  :                            11 
00:000000000006 AAAACCCCBBBB  +12         +       left, right, centre
00:000000000007 AAAAAAAACCCCCCCCBBBBBBBB
                              +13         +       left, right, centre:d   
00:000000000009 AAAAAAAAAAAAAAAACCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBB
                              +14         +       left, right, centre:q
00:00000000000D BE3FC232BE0F  +15 		-1.5, -1*-1, -1.875
00:00000000000E BF3332BF1998  +16 		-0.8, -0.9   
*EOF*
:$(00):000000000000:00000000000F 

</pre>
If the number of fields does not divide into the total size,
zero-filled slack bits are generated at the top.

<p>
Floating numbers are rounded to field size. Here eight 24-bit floating values are generated
in one line of 192 bits,<br>then twelve 16-bit floating values are generated in a another line
of 192 bits<br>
The letter x at each line end separates the last number from the hexaword flag. Each number
must derive its size for rounding automatically from the target field size

<pre>

$ masmx paxels -lnk
MASMX 7r3
3/paxels.msm
*EOF*
  :                            1 	$set_option	"F"
  :                            2 	$word		32
00:00000000 41C00041CCCD41D99A41E66741F3334280004286673DCCCD
                              +3 	1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 0.1x:h
00:00000006 418044A047C84AFA40E740CD40B3409A40803FCD3F9A3ECD
                              +4 	1*+0, 1*+1, 1*+2, 1*+3, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2x:h
  :                            5 
*EOF*
:$(00):00000000:0000000C 


</pre>

Non-native masmx format floating numbers are retrieved from $func macros in compressed
floating arrays

<p>
For IEEE754 format,
macro text requests each number from masmx one bit larger than the target field,<br>
to force rounding on the true mantissa including the suppressed normalising bit.<br>
See <a href="#ieeefloat">11.3: IEEE754 Floating Values</a>
<pre>

$ masmx -lnk fieee754
MASMX 7r3
3/fieee754.msm
CONT_CHAR=|
*EOF*
  :                            1 	$word		32
  :                            2 	$cont_char	'|'
  :                            3 	$set_option	"F"
  :                            4 
  :                            5 	$list		2
  :                            6: 	$include	fieee754.def
  :                            1 
  :                            2 f		$func
  :                            3 fieee754_24*	$name	8*/8++24
  :                            4 fieee754_32*	$name	9*/8++32
  :                            5 fieee754_64*	$name	12*/8++64
  :                            6 fieee754_128*	$name	16*/8++128
  :                            7 
  :                            8 __BITS		$set	f(0, 0)**255
  :                            9 __CHARACTERISTIC_BITS	$set	f(0, 0)/*8
  :                            10 __MANTISSA_BITS	$set	__BITS-__CHARACTERISTIC_BITS
  :                            11 
  :                            12 		$nop	size and rounding are already done from the field size+1
  :                            13 		$nop	isolate the sign and set exponent.mantissa to magnitude
  :                            14 
  :                            15 __NUMBER	$set,__BITS+1	f(1, 1)
  :                            16 __SIGNS		$set	__NUMBER*/-__BITS
  :                            17 __NUMBER	$set	__NUMBER--__SIGNS
  :                            18 
  :                            19 		$do	$o('V'),	$snap	2
  :                            20 
  :                            21 		$nop	adjust the characteristic magnitude
  :                            22 		$nop	truncate the integer bit. slide the exponent over it
  :                            23 
  :                            24 		$do	__NUMBER^=0,__NUMBER	$set	__NUMBER-(2*/__MANTISSA_BITS+1)
  :                            25 
  :                            26 
                                		$return	__SIGNS**1*/__BITS-1++|
                                			(__NUMBER/*__MANTISSA_BITS+1)*/__MANTISSA_BITS++|
  :                            29 			__NUMBER**((1*/__MANTISSA_BITS)-1)
  :                            30 
  :                            31 		$end
  :                            32 
  :                            7 
                                	+	fieee754_24(-0.0), fieee754_24(1.6), fieee754_24(1.7), fieee754_24(1.8), |
00:00000000 8000003F999A3FB3333FCCCD3FE667C00000400CCD3B999A
                              +9 		fieee754_24(1.9), fieee754_24(-2.0), fieee754_24(2.1), fieee754_24(0.1)x:h
  :                            10 
*EOF*
:$(00):00000000:00000006 

</pre>





<a	name="strings"/>
<a      name="text_string"/>
<h3>4.3.5: Text Strings</h3>

See also <a href="#cstring">4.2.2.1.2: C Language Number and String Notation</a> and
<a href="#option_c">-c option</a>

<p>
Text strings are a row of bytes composed from
<pre>

	"text in quotes ";	. text in quotes

	:one_byte_expression	. the substring character before a 1-byte integer 

</pre>
These line-continued parts produce
<pre>

	"text_in quotes":one_byte_expression

</pre>
<p>
All strings begin with quote in the command field. The text part may be void
<pre>

$ masmx -lnkz
MASMX 7r3
0/-INPUT>>
	$word	32
CR	$equ	13
LF	$equ	10

	"":CR:LF  
	$end
  :                            1  $word 32
  :                            2 CR $equ 13
  :                            3 LF $equ 10
  :                            4 
00:00000000 0D0A0000          +5  "":CR:LF  
  :                            6  $end
:$(00):00000000:00000001 
	

</pre>
Text substrings and one-byte integers may be combined without restriction. There is
a substring character between each part

<p>
These lines
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	16
	$quantum 8      

	"string of text":10:;
	"another line of text ":;
	"and more of that line"
	$end
  :                            1  $word 16
  :                            2  $quantum 8      
  :                            3 
00:0000 737472696E67206F6620746578740A616E6F74686572206C
                              +4  "string of text":10:"another line of text ":"and more of that line"
00:0018 696E65206F66207465787420616E64206D6F7265206F6620
                              +4 
00:0030 74686174206C696E6520  +4 
  :                            5  $end
:$(00):0000:003A 


</pre>
are effectively
<pre>

	"string of text":10:"another line of text and more of that line"

</pre>
byte size, quote symbol and substring symbol may be set to different values
from defaults [ 8-bits " : ] with directives $byte $quote $sterm

<p>
Text string contents are read in source code as octets of Latin-1, Roman-8 or UTF-8.
256 code points including 128 ASCII code points may be translated to values set with
directive $data_code

<pre>


$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	16
	$quantum 8     
$(12:65536)
	"abc"
	$data_code	97,65	. generate A for a
	"abc"
	$byte   12
	"abc"
	$ascii			. switch to unchanged input
	"abc"
	$byte	8
	"abc"
	$end
  :                            1  $word 16
  :                            2  $quantum 8     
  :                            3 $(12:65536)
0C:10000 61626320              +4  "abc"
  :                            5  $data_code 97,65 . generate A for a
0C:10004 41626320              +6  "abc"
  :                            7  $byte 12
0C:10008 041062063020          +8  "abc"
  :                            9  $ascii   . switch to unchanged input
0C:1000E 061062063020          +10  "abc"
  :                            11  $byte 8
0C:10014 61626320              +12  "abc"
  :                            13  $end
:$(0C):10000:10018 


</pre>
See also Appendix A.a: Command Line Option Flags -zc for space or zero pad
<a href="#option_z">-z</a> <a href="#option_c">-c</a>

<p>
Text string constants are described further in 

	<blockquote>
	<a href="#byte">8.5: $byte Directive</a><br><br>
	<a href="#quote">8.41: $quote Directive</a><br><br>
	<a href="#sterm">8.49: $sterm Directive</a><br><br>
	<a href="#data_code">8.8: $data_code Directive</a><br><br>
	<a href="#ascii">8.1: $ascii Directive</a>
	</blockquote>

Text strings generate enough words (size set by directive $word) to 
contain a byte (size set by directive $byte) per symbol in the string.<br>
Bytes can straddle word boundaries without restriction if
$byte is not a factor of $word. New strings start at a new word

<p>
Each character between "quotes" is a symbol and an expression
after the substring mark is a symbol, as
<pre>

	"characters":10

</pre>
or
<pre>

	$sterm	'.'
LF	$equ	10

	"characters".LF
  
</pre>
If there are whole bytes unfilled in the last word of the string,
they are space-filled (zero-filled with -c flag XOR -z flag)).

<p>
If there are bits unfilled  after the last whole byte position
in the last word in the string, they are zero filled.

<p>
Byte size may be larger than word size, but may not exceed 32 bits
<pre>

$ masmx -lnkyx
MASMX 7r3
0/-INPUT>>
	$word	16
	$data_code      'a', 1*/23++'a',1*/23++'b',1*/23++'c'
	$byte	24
	"abc"
	$end
  :                            1  $word 16
  :                            2  $data_code      'a', 1*/23++'a',1*/23++'b',1*/23++'c'
  :                            3  $byte 24
00:0000 80006180006280006300  +4  "abc"
  :                            5  $end
$bits=$00:0048
-INPUT>>=0<0000
:$(00):0000:0005 

</pre>
Automatic label <b>$bits</b> indicates here that the string contains 72 bits or three 24-bit characters.<br>
The containing storage is five sixteen-bit words or 80 bits

<p>
See also <a href="#alignments">Appendix F.4: Byte-Addressing Machines with 32- and 64-bit
Bus: Managing Alignments</a>

<p>
See also escape sequences with assembly flag -c

<a	name="form"/>
<h3>4.3.6: $form Items</h3>

$form declares a bit layout template from one word to 192 bits in size.
The command field when using a form is the label of the $form:
<pre>

MASMX 7r2
3/form.msm
*EOF*
  :                            1         $word   16
  :                            2 descriptor $form 1, 1, 14, 2, 3, 3, 24
  :                            3 
00:0000 8180A4040064          +4         descriptor 1,,384, 2, 4, 4, 262144+100
00:0003 00C8F6040063          +5         descriptor  ,,200, 3, 6, 6, 262144+99
*EOF*
:$(00):0000:0006 
form.msm: object code 55 bytes: 0 errors: 0 undefined labels


</pre>

$form is the masmx building block for instruction code:
<pre>

jump_form	$form	6, 26

jump*		$proc
		jump_form	JUMP_CODE, jump(1, 1)
		$end

</pre>

<a      name="proc_call"/>
<h3>4.3.7: $proc Macro Calls: Instructions and Structures</h3>


Most code lines have macro calls in the command position.
Instructions are macros in masmx

<p>
Instruction names are not known to masmx until
they are the names of macros or macro entry points:

<p>
See also <a href="#proc">8.38: Head of Procedural Macro</a> and
<a href="#u2passproc">10.2.2.6: The Two-pass $proc</a>

<pre>

instruction_form $form	8, 12, 12

p       $proc
add*    $name   6
mov*    $name   7
xor*	$name	4
	instruction_form  $n, p(1,1), p(1,2)
	$end

</pre>
The lines of application code mostly are macro calls like these:
<pre>

	add     This, That
	mov     That, There

</pre>
$proc macros assembly may be nested up to 24-deep and may include many
instructions or data structures:
<pre>

p	$proc
sum*	$name
	xor	That, That
addend	$do	p(),	add	p(addend, 1), That
	mov	That, p(0, 2)
	$end

	sum,There	This The_Next The_Third Another

</pre>	
The <b>$proc</b> label may be any label and it is the handle for reference 
to actual arguments. Inside a <b>$proc</b> with label <i>p</i> the referencing rules are
<pre>

p       $proc


	p returns a count of all the fields on the calling line
	including command field and if present label field

	p() returns a count of fields in the actual arguments

	p(expression) returns a count of subfields in 
	field number "expression" of the actual
	arguments

	p(expression1, expression2) returns the value 
	of subfield "expression2" of field "expression1"
	of the actual arguments

	p(expression1, expression2:) returns a count of 
	substrings in subfield "expression2" of field
	"expression1" of the actual arguments

	p(expression1, expression2:expression3) returns the 
	value of substring "expression3" of subfield
	"expression2" of field "expression1" of the actual
	arguments

	p(expression1, *expression2) returns 1 if subfield 
	"expression2" of field "expression1" has the prefix * 
	otherwise 0
     
	p(expression1, #expression2) returns 1 if subfield 
	"expression2" of field "expression1" has the prefix # 
	otherwise 0
        

</pre> 
p(0, 1) and  p(0, 0) return the latent value of the $name used to invoke the $proc
<pre>

p       $proc
add*    $name   20
subtract* $name  21
	.
	.
	$end

</pre>
p(0, 0) retrieves the value 20 if the calling command is add. 

<p>
p(0, 0) returns a 192-bit value. Internal function $n
returns the same value truncated to 32 bits

<p>
p(0, 2) returns a subcommand from the command field,
for example:
<pre>


L       $equ    2
	.
	.
	move,L  location1,location2


</pre>
p(0, 2) will return the value of L, which is 2.


<p>
One macro may send all its actual arguments to another macro by<br>
using the paraform <i>macro_label()</i>. Extra arguments may be added 
<pre>

$ masmx forward -lnky
MASMX 7r3
3/forward.msm
*EOF*
  :                            1 	$word	16
  :                            2 	$quantum 8
  :                            3 
  :                            4 p	$proc
  :                            5 first*	$name
  :                            6 	second	p()	102
  :                            7 	$end
  :                            8 
  :                            9 p	$proc
  :                            10 second*	$name
  :                            11 ?	$do	p(),	+	p(?, 1)
  :                            12 	$end
  :                            13 
00:0000 0065                  +14 	first	101	99	100
00:0002 0063                  +14 
00:0004 0064                  +14 
00:0006 0066                  +14 
  :                            15 
*EOF*
:$(00):0000:0008 

</pre>


<div	style="color:a0a0a0">
<blockquote>
Paraform <i>macro_label</i> without parenthesis sends all the text of the calling line to another macro.<br>
The fields forwarded as arguments include the command plus any label on the call line to the forwarding macro.<br>
Therefore in the newly called macro, if all the call-line text is forwarded as arguments

	<blockquote>
	<i>macro_label</i> minus <i>macro_label()</i> = 2 indicates <i>macro_label(1,1)</i>
	is the label on the call line to the forwarding macro<br><br>
	
 	<i>macro_label</i> minus <i>macro_label()</i> = 1 indicates <i>macro_label(1,1)</i>
	is the command on the call line to the forwarding macro
	</blockquote>
</blockquote>

</div>
<br>
<br>
Actual parameters forwarded individually to a nested macro
plus any new tokens may be re-ordered for the nested macro:
<pre>

	first_macro	left, right, centre	off_centre

____________________________________________________________________
first_macro receives this parameter stream:

	first_macro	left, right, centre	off_centre
____________________________________________________________________

p		$proc
first_macro*	$name
		.
	second_macro	justify	p(2, 1)-7	p(1, 1), p(1, 3), p(1, 2)
		.
		$end

____________________________________________________________________
second_macro receives this parameter stream:

	second_macro	justify	off_centre-7	left,centre,right
____________________________________________________________________

p		$proc
second_macro*	$name
		.
		.
		$end

</pre>
Macro language plus parameters can be displayed step-by step if the
value $plist is greater than current macro nesting depth,<br>
given option flags -p (display $proc macros) -q (display $func macros).

<p>
Listing and -pq displays are on the second assembly pass.

<p>
If problems encountered are so great than the second assembly pass is
not reached -r flag displays macros on the first assembly pass.

<p>
See <a href="#plist">8.38: $plist Directive</a>,
<a href="#clopts">Appendix A.a: Command Line Option Flags</a>,
<a href="#walkingmacro">Appendix E.4: Tracing Macro Expansion</a>


<p>
An actual argument to a <b>$proc</b> macro may be placed in the command
field if it is a command, for example a further macro name.

<p>
This extract is from macro language illustrated at
<a href="#fpalgors">6.2: Run-Time Floating Algorithm Plotter</a><br>
A macro name is found in actual arguments and inserted into the assembly
<pre>

p       $proc
FOP*    $name
"$TYPE" $set    $t(p(1, 1))
"$RING" $set    0
        $do     p()>1,  $do     $t(p(2, 1))=$name,"$RING"       $set    p(2, 1)
        $if     $RING=IEEE754_64_ACQUIRE$
	<a style="color:blue">p(2, 1) p(1)</a>
	.
	.

</pre>
<p>
$proc macros are also described in <a href="#proc">8.38 $proc Directive</a> and
<a href="#macro">10.2.2: Describing Target Architecture in Text... $proc, $name, $end</a>


<a      name="argument"/>
<h2>4.4: The Argument Field</h2>


<a      name="xargument"/>
<h3>4.4.1 Argument Expressions</h3>

An argument expression generates a value,
for example an instruction operand address
<pre>

		lwz	r6, STORAGE_WORD_ADDRESS	; r6 and STORAGE_WORD_ADDRESS are operand expressions

</pre>

<p>
Argument field expressions may have any tokens and operators which
constant expressions have

<p>
The size of the expression value is determined by the target field size
within the instruction or structure named at the command field

<p>
Assembly macro text and link macro text may range-check the argument value


<a      name="largument"/>
<h3>4.4.2: Literal Arguments</h3>

Literals are constants of any size generated by reference. The address
of a literal operand is placed in the address field of the instruction
<pre>

	ld    r24, .literal_pool_name(0FFFC0000A000C000L)

</pre>

The instruction contains the <i>address</i>
of the 64-bit constant 0FFFC0000A000C000

<p>
The constant is generated at the end  of the program section where ".literal_pool_name" is declared.

<p>
Assembly macro text and link macro text may range-check the literal
address against the size of the instruction operand address field

<p>
See <a href="#sections">7: Constructing Program Sections</a>,
<a href="#lptag">7.1.7: Literal Pool Tag</a>,
<a href="#literals">4.5: Literals</a>,
<a href="#lpooltag">4.5.5: Literal Pool Tags</a>,
<a href="#ldirective">4.5.6: $lit directive</a>,
directive <a href="#lit">8:28 $lit</a>

<p>
With assembly flag -a an operand entirely in parentheses is an 
automatic literal
<pre>

	add	r21, (LARGE_VALUE)

</pre>

See <a href="#automatic">4.5.3: Automatic Literals</a>

<p>
Literals are typically used where a value is too large to be encoded as an immediate operand within<br>
an instruction. Constants which are not instruction code may also  reference literals. In this example<br>
an instruction points to a literal constant which points to another literal constant
<pre>

$ masmx -lnky
MASMX 7r3
0/-INPUT>>
	$list	0
	$include ../aside.dem/ppc_64.def
LTERM=#
CONT_CHAR=\
STERM=.
	$list
	$lit	3
	$set_option	"a"
$(.text:8192)
        ld      r3, (12, ("Hello World\n")d)
	bla	message
$(.data:16384)
	$res	4096
	$end
  :                            1118  $list
  :                            1119  $lit 3
  :                            1120  $set_option "a"
  :                            1121 $(.text:8192)
01:00002000 E860500C          +1122         ld      r3, (12, ("Hello World\n")d)
[+0000:00000000/*02]18*/02
01:00002004 48000003          +1123  bla message
  :                            1124 $(.data:16384)
  :                            1125  $res 4096
  :                            1126  $end
03:00005000+48656C6C6F20576F726C640A
03:0000500c+0000000C00005000
:$(01):00002000:00002008 :$(03):00004000:00005014 


</pre>


<a      name="literals"/>
<h2>4.5: Literals</h2>


<a      name="literal_is"/>
<h3>4.5.1: A Literal is</h3>


A literal is a constant generated by reference. It is assembled at the foot of its containing program section,<br>
which may be any section regardless of where the literal is referenced. Its address goes into the instruction<br>
or structure which references it

<p>
Literals are not duplicated in any one program section. References requiring
the same value retrieve the same literal


<a      name="literal_pool"/>
<h3>4.5.2: The Literal Pools</h3>


Each of the 72 location counters may have one literal pool.

<p>
If a location counter is breakpointed (the section is restarted
with breakpoint steps within  the same location counter), each part
may have a literal table.

<p>
Only the first 64 breakpoint parts of a section may have literal tables


<a	name="automatic"/>
<h3>4.5.3: Automatic Literals</h3>

Automatic literals are literals which are generated
in the current default literal pool without referencing 
a literal pool tag.

<p>
The default literal pool is at the segment-end of the default
location counter for literals, initially locator $(0).

<p>
Command line <a href="#option_a">option -a</a> switches automatic literals. Assembly source
may set this and most other option flags, typically in target
definition header files
<pre>

	$set_option	"a"

</pre>
An automatic literal is then generated where any argument in
an instruction or constant line is entirely in parentheses
<pre>

	Load    r24, (0FFFC0000s)

</pre>
<p>
In that example, 0FFFC0000 is generated at the end of the assembly or
location counter breakpoint. The address of the literal goes in the
load instruction.

<p>
A unary sign in front of the opening parenthesis prevents an expression
from being an automatic literal
<pre>

	la	a0, +(EXPRESSION)

</pre>
+(EXPRESSION) is an expression, not a literal. An attempt is made
to place value EXPRESSION in the address field of the instruction.


<a      name="iflag_lit"/>
<h3>4.5.4: Indirection Flag on a Literal</h3>

Unary * on source code arguments is widely used to represent
an indirection flag in binary code.<br>
masmx allows macro text to retrieve * at the start of all field
and subfield arguments, including literals
<pre>

	lr	r3, *(VERY_BIG_ADDRESS)

</pre>
A literal containing VERY_BIG_ADDRESS is generated

<p>
Macro language places the address of the literal in the instruction.<br>
Macro language retrieves flag value 0 or 1 for unary * absent or present


<a      name="lpooltag"/>
<h3>4.5.5: Literal Pool Tags</h3>

Literal Pool Tags are labels of literal pools, and referencing them
acts functionally to generate a literal and return its address

<p>
Each literal pool may have any number of tags.

<p>
Literal Pool Tags may be generated: 
<pre>

	on the location counter control line:

$(5:DATA_SEGMENT/literal_pool_5)

	as the label of a $lit directive: See directive <a href="#lit">8:28 $lit</a>

lits7  $lit    7

	floating_multiply	literal_pool_5(7.2e-1200000)
	quad_store		*lits7(HIGH_ADDRESS)


</pre>


<a      name="ldirective"/>
<h3>4.5.6: $lit Directive</h3>

$lit may have a label and may have an argument.
If $lit has an argument it must be the identity
of a location counter 0..71.

<p>
If $lit has no argument its effective argument
is the identity of the current location counter.

<p>
$lit sets the default location counter
for literals to the value in its argument or
to the current location counter.

<p>
The default location counter for literals is
used for automatic literals (literals which
are generated without referencing a literal
pool tag).

<p>
If $lit has a label, the label becomes a literal
tag for the literal pool.

<p>
See also directive <a href="#lit">8:28 $lit</a>

<a      name="lnested"/>
<h3>4.5.7: Nested Literals</h3>

<p>
It is possible to generate nested literals.

There is an example of how this might usefully be done at <a href="#largument">4.4.2: Literal Arguments</a><br>
The two-word literal at 0500C contains a byte count and a pointer to a string literal at 05000
<pre>

01:00002000 E860500C          +1122         ld      r3, (12, ("Hello World\n")d)
[+0000:00000000/*02]18*/02
01:00002004 48000003          +1123  bla message
  :                            1124 $(.data:16384)
  :                            1125  $res 4096
  :                            1126  $end
03:00005000+48656C6C6F20576F726C640A
03:0000500c+0000000C00005000

</pre>
The nested literal is only generated if it both begins and ends with
parenthesis. The opening parenthesis may have a flag * token in front:
<pre>

$ masmx constanz -lnyk
MASMX 7r3
3/constanz.msm
  :                            1 	$word		32
  :                            2 constanza $form		1, 31
  :                            3 
  :                            4 	$set_option	"a"
  :                            5 	$lit		5
  :                            6 	$plist		5
  :                            7 
  :                            8 instanza*	$proc
  :                            9 	constanza	instanza(1, *1), instanza(1, 1)
  :                            10 	 $end
  :                            11 
  :                            12 $(5:050000)
05:00050000 80050003          +13  	instanza	*(instanza *(instanza *(99)))
  :                            14 	$end
05:00050001+00000063
05:00050002+80050001
05:00050003+80050002
:$(05):00050000:00050004 

</pre>
This is next example does not generate a nested literal. It contains an
expression within a literal:
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	        32
	$set_option	"a"   

$(4:16384)
	+	((99)+2)
$(0:65536)
	$end
  :                            1  $word         32
  :                            2  $set_option "a"   
  :                            3 
  :                            4 $(4:16384)
04:00004000 00010000          +5  + ((99)+2)
  :                            6 $(0:65536)
  :                            7  $end
00:00010000+00000065
:$(00):00010000:00010001 :$(04):00004000:00004001 


</pre>
<a      name="fmacro"/>
<h2>4.6: Function Macros</h2>

Operand expressions may include user function macros,

<a      name="fmacrois"/>
<h3>4.6.1: A Function Macro is</h3>

Functions are not code subroutines (as they are in C-Language).

<p>
masmx functions are macros which return values at assembly time.

<p>
User written functions return a computed value for use in an expression.

<p>
Functions mostly contain directives, because they do not primarily
generate code: 
<pre>

simplog*	$func
		$do	simplog(1,1)=64,	$return	6
		$do	simplog(1,1)=8,		$return	3
		$flag	bucket can only be 8 bytes or 64 bytes
		$return	0
		$end

...
		shift_left	r6, simplog(BUCKET_SIZE)


</pre>
<a      name="fmacdi"/>
<h3>4.6.2: Directives for Constructing Functions</h3>


<a      name="fmache"/>
<h4>4.6.2.1: $func -head of function</h4>
<pre>

function_name  $func
	.
	.

</pre>
There must be a label when the command is $func.

<a      name="fmac2pass"/>
<h4>4.6.2.1.1: Second-Pass-Only Functions</h4>

$func can have an argument
<pre>

fname*  $func	*
	.
	.

</pre>
* is the only argument $func can have. It means
"second pass only", or don't expand this macro on
the first assembly pass.

<p>
One reason for a second-pass-only function may be that its
value is not required on the first pass.<br> Another reason
may be that two passes of the same function have a
cumulative effect which is undesirable 

<p>
It may to the contrary be necessary to expand a function macro on both assembly
passes, because the function has determining effect how much code is generated.<br>
See <a href="#fmacdisp">4.6.2.1.3: Functions affecting Program Displacements</a>


<a      name="fmacni"/>
<h4>4.6.2.1.2: Non-Idempotent Functions</h4>
<p>
Second-pass-only functions are used to generate a data item
once only by reference.

<p>
They prevent the situation where the data is not generated on the
second pass because its label was generated on the first pass:
<pre>


f*      $func
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . out-of-line $proc call generates label and data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
	call    f(ROUTINE)

</pre>
One way of solving this problem is a literal. Literals
are generated on the second pass only and do not have
labels

<p>
However a function call may be necessary for some
action more complex than generating a literal. This
is one use of the second-pass-only function
<pre>

f*      $func	*
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . out-of-line $proc call generate label and data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
	call    f(ROUTINE)


</pre>

<a      name="fmacdisp"/>
<h4>4.6.2.1.3: Functions affecting Program Displacements</h4>

If a function macro returns a value which determines the length
of code generated, it must be called on both assembly passes,
unless there are no labels and no literal table subsequent to
the point where the function macro has its effect

<p>
The following function is for example assembled to inform ColdFire
floating-point instructions of the address of a constant operand
in storage

<pre>


f       $func
"$ieee64"* $name
        $if     $t(f(2, 1))=$special_reg
        $if     f(2, 1)=l
"$UP"*  $equf   $azlit(f(1)d)
        $elseif f(2, 1)=w
"$UP"*  $equf   $azlit(f(1)s)
        $elseif f(2, 1)=b
"$UP"*  $equf   $azlit(f(1)*/8s)
        $elseif f(2, 1)=s
"$UP"*  $equf   $azlit(ieee754_32 f(1))
        $endif
        $else
"$UP"*  $equf   $azlit(ieee754_64 f(1))
        $endif
        $return $UP
        $end

</pre>

If the function is 2nd-pass-only (<b>f $func *</b>), then the blank result
from suppressing its expansion on pass one leads to the mistaken pre-assembly
of short format floating instructions with no displacement field. On pass two
the instructions get longer and the literal table starts at a conflicting
location. The assembly is marked in error
<pre>

$ masmx quickly -lnky
MASMX 7r3
3/quickly.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	fpxpress.def
  :                            4 	$path
  :                            5: 	$include	espresso.def
  :                            6: 	$include	ieee754.def
  :                            7 
  :                            8 $(5:65536,a5)
  :                            9 one	$res	8
  :                            10 two	$res	8
  :                            11 
  :                            12 $(0:16384,pc/$azlit)
  :                            13 froutine
00:00000000 F22D54000000      +14 	$xqt_fp,$ieee64		one*1.6384e307+two
00:00000006 F23A54230006      +14 
00:0000000C F22D54220008      +14 
00:00000012 4E75              +15 	rts
  :                            16 
*EOF*
Error: quickly.msm Line 16: code longer on 2nd assembly pass: $(00) :0000000E:00000014
00:0000000e+7FB754E31CD072DA
:$(00):00004000:00004016 :$(05):00010000:00010010 
quickly.msm: object code 152 bytes: 1 errors: 0 undefined labels

</pre>

The corrective step is to allow function <i>$ieee64</i> to expand on both assembly
passes (<b>f $func</b> without any asterisk). Then the literal constant addressed
by the  instruction at 0x00000006 is twelve bytes beyond instruction + 2 = 0x00000014
and the assembly does not error

<pre>

$ masmx quickly -lnky
MASMX 7r3
3/quickly.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	fpxpress.def
  :                            4 	$path
  :                            5: 	$include	espresso.def
  :                            6: 	$include	ieee754.def
  :                            7 
  :                            8 $(5:65536,a5)
  :                            9 one	$res	8
  :                            10 two	$res	8
  :                            11 
  :                            12 $(0:16384,pc/$azlit)
  :                            13 froutine
00:00000000 F22D54000000      +14 	$xqt_fp,$ieee64		one*1.6384e307+two
00:00000006 F23A5423000C      +14 
00:0000000C F22D54220008      +14 
00:00000012 4E75              +15 	rts
  :                            16 
*EOF*
00:00000014+7FB754E31CD072DA
:$(00):00004000:0000401C :$(05):00010000:00010010 
quickly.msm: object code 152 bytes: 0 errors: 0 undefined labels

</pre>


<a      name="fmacname"/>
<h4>4.6.2.2: $name -entry point and invocation tag</h4>

<b>$name</b> directive allows a latent value to be associated
with a callname. Here one function is available for 8051
relative jump instructions. The address encoded in the
instruction is relative to the instruction trailing edge,
either two or three bytes after the instruction start
<pre>

f	$func
"$rel2"* $name   2
"$rel3"* $name   3
target  $set    f(1,1)-$-f(0, 0)
        $do     target<-128,    $flag   You may only jump from instr. trailing edge - 128
        $do     target>127,     $flag   You may only jump from instr. trailing edge + 127
        $return target
        $end

</pre>

The <b>$func</b> label <i>f</i> need then not be exported from the macro text
(it wears no asterisk), and this allows <i>f</i> to be reused and argument paraforms like
<i>f(1,1)</i> to be recognisably familiar to the developer in many different function macros


<a      name="fmacret"/>
<h4>4.6.2.3: $return -value of result</h4>


The argument of $return is an expression.
192 bits of it are returned:
<pre>

	$return expression

</pre>
$return also leaves the containing macro, and this is true of $proc
macros as well as $func macros, although $proc macros do not have
a result value.


<a      name="fmacend"/>
<h4>4.6.2.4: $end -foot of function</h4>

$end is the last command on any subassembly.
A $func is a subassembly (a macro):
<pre>

f       $func
	.
	.
	$return something
	$end

</pre>

<a      name="fmacode"/>
<h3>4.6.3: Code Generated During Function Evaluation</h3> 

Code may not be generated inline to the current
location counter during a <b>$func</b>. That is treated
as an error, although the functional result may determine
more or less code generated inline

<p>
Here function <i>f</i> calls a macro <i>generate</i>
to construct a data item out of line (in locator 42), and  
attach a label to it
<pre>

f*      $func	*
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . Generate Label and Data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
p       $proc   $(42)        
generate* $name
*       +       address_of_resolver_routine
	"p(1, 1)"
	$end
	.
	.
	call    f(ROUTINE)


</pre>

<a      name="internalf"/>
<h2>4.7: masmx Internal Functions in Detail</h2>


<a      name="location_c"/>
<h3>4.7.1: $	location counter</h3>

<a      name="thisloc"/>
<h4>4.7.1.1: $	this location counter</h4>

The expression $ returns the value of the current location counter. 
For example the sequence
<pre>

$(7:256)
	$res    4
bampot  $equ    $+1


</pre>
label bampot has the value 261
<pre>


$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word   32
	$awidth	32:96

ASTRONOMIC	$set	07FFFF8000380000000040000
	    
$(43:1024:*ASTRONOMIC)
	
	$res	512
here
tube	$equ	$+1

	+	tube
	+	here
	$end
  :                            1  $word   32
  :                            2  $awidth 32:96
  :                            3 
  :                            4 ASTRONOMIC $set 07FFFF8000380000000040000
  :                            5      
  :                            6 $(43:1024:*ASTRONOMIC)
  :                            7  
  :                            8  $res 512
  :                            9 here
  :                            10 tube $equ $+1
  :                            11 
2B:7FFFF8000380000000040600:7FFFF8000380000000040601
                              +12  + tube
2B:7FFFF8000380000000040603:7FFFF8000380000000040600
                              +13  + here
  :                            14  $end
:$(2B):00000400:00000606 


</pre>

<a      name="alocator"/>
<h4>4.7.1.2: $(..)	named location counter</h4>

The expression $(..) returns the value of the location 
counter identified in the brackets. For example
<pre>

text    $equ    0
var     $equ    1
$(var:4096)
	$res    4
$(text:256)
CONSTANT        +       $(1)+3

</pre>
The data word at location CONSTANT to contains the value 4103


<a      name="absolute"/>
<h3>4.7.2: $a	absolute address</h3>

$a retrieves an absolute address value of a
<a href="#bdflat">base-displacement</a> identifier,
where $ produces only a displacement
<p>

<p>
Constants of base-displacement identifiers and location counters only contain
the displacement. $a adds the section base whether it is already known or
relocatable

<a      name="absolute_here"/>
<h4>4.7.2.1: $a	current absolute address</h4>

$a without parameter is the current absolute address. Here $ and $a
are in the left and right halves of a quadword storage constant
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
        $word   16
$(44:0FC00,5)
        $res    10
	+	$, $a:Q
        $end
  :                            1         $word   16
  :                            2 $(44:0FC00,5)
  :                            3         $res    10
2C:000A 0000000A0000FC0A      +4         +       $, $a:Q
  :                            5         $end
:$(2C):FC00:FC0E 

</pre>

<p>
$a also retrieves relocatable addresses, as $ also does except in
base-displacement sections

<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
$(15:*8, 9)     . relocation alignment 8, base register 9
        $res    6
	+	$a:L
	$end
  :                            1 $(15:*8, 9)     . relocation alignment 8, base register 9
  :                            2         $res    6
(+0f)30
0F:000006 000000000006        +3         +       $a:L
  :                            4         $end
:$(0F):000000:000008 

</pre>
A relocation request is attached to the $a value. The receiving field of a
storage constant must be large enough to contain the linked absolute address

<a      name="absolute_there"/>
<h4>4.7.2.2: $a(..)     absolute value of expression</h4>

<p>

$a(<i>expression</i>) retrieves the absolute value of base-displacement identifiers


<pre>

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
	+	$a(location4)
	+	$a(location5)

$(4:0400000,2)
        $res    4
location4

$(5:*8, 3)
	$res	100
location5
	$end
00:000000 400004              +1         +       $a(location4)
(+05)18
00:000001 000064              +2         +       $a(location5)
  :                            3 
  :                            4 $(4:0400000,2)
  :                            5         $res    4
  :                            6 location4
  :                            7 
  :                            8 $(5:*8, 3)
  :                            9         $res    100
  :                            10 location5
  :                            11        $end
location4=$04:000004,000002
location5=$05:000064,000003
-INPUT>>=0<000000
:$(00):000000:000002 :$(04):400000:400004 :$(05):000000:000064 

</pre>

$a attached a relocation request to the reference to relocatable identifier location5.<br>
Simple constants of base-displacement identifiers only retrieve the displacement

<p>
$a has no function for addresses in <a href="#voidsection">void sections</a>,
where the base pointer value is not available at either assembly or link


<p>
A breakpoint value in the locator declaration concerns hardware address translation
and is a load address or handle known at assembly time

<p>
$a(<i>location</i>) in this assembly includes the program-absolute base address 0C000.
The load address 0FC0000 is not part of the program-absolute address.<br>
See <a href="#bdbreakpt">7.1.4: Base+Displacement in Translated Address Spaces</a>
<pre>

$ masmx -lnkyx
MASMX 7r3
0/-INPUT>>
	$word	32
	$quantum 8
$(12:0C000:0FC0000,5)
	+	location, $a(location)d
	$res	40
location
	$end
  :                            1  $word 32
  :                            2  $quantum 8
  :                            3 $(12:0C000:0FC0000,5)
0C:00000000 000000300000C030  +4  + location, $a(location)d
  :                            5  $res 40
  :                            6 location
  :                            7  $end
location=$0C:00000030,00000005
-INPUT>>=0<00000000
:$(0C):0000C000:0000C030 

</pre>
A starred breakpoint is part of program-absolute addresses
(<a href ="#bdgiant">7.1.6.2: Giant Address Base-Displacement</a>)

<p>
$a retrieves the large absolute value
<pre>

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
	$word	32
	$awidth	32:64
$(14::*00FFC800003F0000, 20)
	$res	10
here
	+($a)d
	$end
  :                            1  $word 32
  :                            2  $awidth 32:64
  :                            3 $(14::*00FFC800003F0000, 20)
  :                            4  $res 10
  :                            5 here
0E:00FFC800003F000A:00FFC800003F000A
                              +6  +($a)d
  :                            7  $end
here=$0E:0000000A,00000014
-INPUT>>=0<00000000
:$(0E):00000000:0000000C 

</pre>


<a      name="sectionbase"/>
<h3>4.7.3: $b	section base address</h3>

$b function in an absolute section retrieves the initial start address
of the section
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
$(5:02000)
$(5:05000)
	$res	100
	+	$b
	$end
  :                            1 $(5:02000)
  :                            2 $(5:05000)
  :                            3  $res 100
05:005064 002000              +4  + $b
  :                            5  $end
:$(05):002000:005065 

</pre>
$b function in a relocatable section retrieves the link root of the
input segment within the linked section
<pre>

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
$(5:*8) 
	$res	100
base*	$equ    $b
	$store	rel_file
	$end
  :                            1 $(5:*8) 
  :                            2  $res 100
  :                            3 base* $equ    $b
  :                            4  $store rel_file
  :                            5  $end
base+=$05:000000
rel_file.txo=0<FFFFFFFF
-INPUT>>=0<000000
:$(05):000000:000064 

$ cat rel_file.txo

+base:$05:000000
:$05*FFFFF8:000000:000064

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
	$list	        0
	$include	../def/map1.def
	$list
$(5:02000)
buffer	$res	03000
	$include,$binary rel_file
rel_file.txo:$(5) 100 words decimal from hexadecimal 005000 to 005064
	$end
  :                            97  $list
  :                            98 $(5:02000)
  :                            99 buffer $res 03000
  :                            100:  $include,$binary rel_file
  :                            101  $end
buffer=$05:002000
base+=$05:005000
rel_file.txo=1<000004
../def/map1.def=1<000004
-INPUT>>=0<000000
:$(05):002000:005064

$ cat temp.txo

+base:$05:005000
:$05*000000:002000:005064

</pre>
The value of label base is 05000.



<a      name="bix"/>
<h3>4.7.4: $bank_index -absolute or virtual memory space identity</h3>

$bank_index concerns targets with hardware relocation
and program sections assembled to have translated load addresses<br>
See <a href="#breakpoint">7.1.2</a>, <a href="#bdbreakpt">7.1.4</a>, Breakpointed Location Counters

<p>
$bank_index retrieves a load pointer which may be a physical load address
or an encoded or translated identifier for the memory block currently assembling.<br>
The load pointer is the <i>breakpoint_value</i> in the location counter switch statement
<pre>

$(locator_number:program_visible_base_address:<i>breakpoint_value</i>)

</pre>
If assembly flag -v is not set, <i>breakpoint_value</i> is a physical load address.<br>
A section identified by location counter may have many breakpoints,
making many parts of one program section with different load addresses

<p>
If assembly flag <a href="#option_v">-v</a> is set, <i>breakpoint_value</i> is an abstraction
like a handle or block identifier,<br>
and the binary output appends it to load string addresses without interpreting it.
A section identified by location counter<br>
may have many parts with different storage block identifiers.
See <a href="#vbreakpt">7.1.2.2: Breakpointed Location Counters: -v Option</a>

<p>
$bank_index function retrieves the current breakpoint value whether physical or abstracted<br>
and identifies the memory block automatically, allowing macro code to generate vector information
<pre>



p	$proc
entryP*	$name
*	$equ	vector_value($bank_index, $)
	j	p(1, 1)
	$end


callname* entryP callroutine


</pre>

<a      name="sname"/>
<h3>4.7.5: $n -value of instruction $name, macro entry tag</h3>

$n has the latent value of a $name macro entry point

<p>
$n is the same value as the paraform <i>macro_label</i>(0, 0),
but truncated to 32 bits instead of 192 bits

<p>
$n may be used in both procedural and functional macros
<pre>

p	$proc
command_name_1* $name LATENT_VALUE_1
command_name_z* $name LATENT_VALUE_Z


	$end 
	
f	$func
reference_name_x* $name LATENT_VALUE_X
reference_name_y* $name LATENT_VALUE_Y

	$return	FUNCTIONAL_VALUE
	$end

</pre>
For example where
<pre>

	$word   48
"$instruction" $form 6, 42
	.
	.
p       $proc
load*   $name   1
store*  $name   2
add*    $name   3
subtract* $name  4

	$instruction   $n, p(1,1)

	$end

</pre>
the call line
<pre>

	add     8193

</pre>
generates
<pre>

	0C0000002001

</pre>
The macro was called with the name add with latent value 3

<p>
Value 3 is in the first field and the operand value in the other field

<p>
$n can also be retrieved as parameter <i>macro_label</i>(0,0), in this example p(0, 0)

<p>
The size of <i>macro_label</i>(0, 0) is 192 bits.

<p>
The size $n is 32 bits.

<p>
This function macro uses its $n value to compute
an 8-bit address relative to the trailing edge of 
either a two- or a three-byte relative-jump instruction:
<pre>

"$rel"  $func
"$rel2"* $name   2
"$rel3"* $name   3
target  $set    $rel(1,1)-$-$n
	$do     target<-128,	$flag   You may only jump from instr. trailing edge - 128
	$do     target>127,	$flag   You may only jump from instr. trailing edge + 127
	$return target
	$end

</pre>
<p>
"cjne" calls $rel3 to obtain an 8-bit relative displacement from its own 
trailing edge, which is three bytes later than the location counter

<p>
"jc" and "jnc" call $rel2 to obtain an 8-bit relative displacement from 
their trailing edge, which is two bytes later than the location counter
<pre>

i$cjne_a        $form   8,8,8
i$cjne_r        $form   5,3,8,8
i$cjne_indirect $form   7,1,8,8

"$jumpcc"	$form 8, 8

p	$proc
cjne*	$name

        $if     ($t(p(1,1))=REGISTERS$)**(p(1,1)=A)
          $if   p(1,#2)
            i$cjne_a            0b4, p(1,2), $rel3(p(1,3))
          $else
            i$cjne_a            0b5, p(1,2), $rel3(p(1,3))
          $endif
        $elseif $t(p(1,1))=POINTER$
          $if   p(1,#2)
            i$cjne_indirect     05bh, p(1,1), p(1,2), $rel3(p(1,3))
          $else
            $flag Second Operand Must Be Immediate
          $endif
        $elseif $t(p(1,1))=RREGISTERS$
          $if  p(1,#2)
            i$cjne_r            017, p(1,1), p(1,2), $rel3(p(1,3))
          $else
            $flag Second Operand Must Be Immediate
          $endif
        $else
          $flag First Operand Must be A/Rn/@Rn
        $endif
        $end

p       $proc
jc*     $name   JC_CODE
jnc*    $name   JNC_CODE
	$jumpcc $n, $rel2(p(1,1))
	$end

</pre>

<a      name="snet"/>
<h3>4.7.6: $net(..) -the unrelocated value of an expression</h3>

Few algebraic operations are allowed on relocatable addresses.
See <a href="#operator">4.2.1: Operators</a>

<p>
masmx Linking assembly guards internally against truncation on absolute relocation.

<p>
Assembling from source, range checks may be needed to prevent intermediate truncation,
or final truncation in absolute assembly.<br>
It is also desirable to to assemble relocatable and absolute with the same macro text

<p>
This test
<pre>

p	$proc
jump*	$name	
target	$set	p(1, 1)

	$do	target>16777261,	$flag	you can't jump there

</pre>
would always error where p(1, 1) is relocatable or external, because operator &gt;
is not allowed on a relocatable.

<p>
This is allowed
<pre>

	$do	$net(target)>16777261,	$flag	you can't jump there

</pre>
Targets in relocatable segments have relocation requests added to references.<br>
Labels which are not present are external and relocation requests are added to references

<p>
The operators allowed on relocatable tokens are
<pre>

	+	plus

	-	minus

	/*	shift right

        */-	algebraic shift right

	**	AND

</pre>
Other operators require <b>$net()</b> function of relocatable tokens



<a      name="oflag"/>
<h3>4.7.7: $o(.) -is this option set?</h3>


An expression whose value is 'A'..'Z' or 'a'..'z' is allowed in the
parentheses, and 1 is returned if the equivalent flag is on, for example:
<pre>

	$do	$o('k'),	$note flag -k is set

	$if	$o(65)=0
	$flag	flag -A should be set
	$endif 

</pre>
Flags -<b>abcdefghjklmnopqrsuvwxyzDEFGQYZ+</b> are set at any or several positions of
the <a href="#commandline">command line</a><br>
or with the exception of flags -<b>ksy</b> with the <a href="#set_option">$set_option</a> directive

<p>
Flags used by masmx are listed at <a href="#clopts">Appendix A.a: Command Line Option Flags</a>

<p>
Flags -<b>VUOS</b> may be used to switch and trace assembly language code



<a      name="region"/>
<h3>4.7.8: $r region</h3>


<a      name="thisregion"/>
<h4>4.7.8.1: $r	identity of current location counter</h4>

Returns the identity, not the value, of the current 
location counter 0..71. 


<a      name="thatregion"/>
<h4>4.7.8.2: $r(<i>expression</i>)	location counter containing identifier <i>expression</i></h4>

identifies the program section where the target identified by <i>expression</i> is

<p>
The first token in <i>expression</i> should be an identifier pertaining to
a program section, or a macro argument paraform referencing an identifier
				  
				  
<a      name="relocation"/>
<h3>4.7.9: $rel	relocation factor of location counter</h3>

The relocation factor of a location counter is zero if the program
section is absolute and nonzero if the program counter is relocatable.<br>
A nonzero relocation factor is not guaranteed to be 1. It is the
alignment quantum of the section and it is represented as negative if the<br>
segment contains only buffers and no code

<a      name="relocat_here"/>
<h4>4.7.9.1:	$rel</h4>

$rel without parameter is the relocation factor of the current location counter</h4>

<a      name="relocat_there"/>
<h4>4.7.9.2:	$rel(<i>locator</i>)</h4>

<i>locator</i> is a value in the range 0..71

<p>
Function <b>$rel</b> may be cascaded with function <b>$r</b> to detect
if the current location or a named label is relocatable
<pre>

	$if     $rel($r(label))
	.
	.

</pre>


<a      name="labeltyp"/>
<h3>4.7.10: $t(label)	Label Type</h3>

The return value from the $t(..) function is a type 
associated with a label. The type is assigned either 
by the assembler or by the developer.

<a	name="lt_undefined"/>
<h4>4.7.10.1: Label Type Undefined</h4>

A label which is not defined during the first assembly passed is external
and has the type zero meaning undefined. Any reference to it other than<br>
<b>$t()</b> function generates a link request for external resolution,
or if -u flag is set, an error.


<a      name="lt_location"/>
<h4>4.7.10.2: Label Type Location</h4>


A label has the type of a storage address if it
has been encountered on column 1 of a source line,<br>
and is not the label of a $equ, $set, $equf, $proc, 
$func, a $name in a $proc or $func, or the counter tag<br> 
of a $do, or the tag of a $lit directive. 
	
<p>
The type and value of address labels cannot be changed.
However the same label name can be used independently and differently
at different macro depths
	
<p>
The type of a location or storage address label is 127. This type value does not have a masmx-supplied name
<pre>

$ masmx -lnkyx
MASMX 7r3
0/-INPUT>>
$(5:05000)
startup	+       $t(startup)
	$end
  :                            1 $(5:05000)
05:005000 00007F              +2 startup + $t(startup)
  :                            3  $end
startup=$05:005000
-INPUT>>=0<000000
:$(05):005000:005001 

</pre>
A location label is associated with a a location counter and is either absolute or relocatable.<br>
So are labels of types $set and $equ, if they are equated to a storage address
<pre>

$(5:05000)
startup	+       $t(startup)
forward	$set	startup
along	$equ	forward
	$end
  :                            1 $(5:05000)
05:005000 00007F              +2 startup +       $t(startup)
  :                            3 forward $set startup
  :                            4 along $equ forward
  :                            5  $end
along=$05:005000
forward=$05:005000
startup=$05:005000
-INPUT>>=0<000000
:$(05):005000:005001 

</pre>

<a      name="lt_equ"/>
<h4>4.7.10.3: Label Type $equ</h4>


The label of a $equ line has an absolute or a relocatable 
value according to the the argument to which it is equated.

<p>
$equ labels are not intended to be equated more than once

<p>
A label name may be defined independently and differently
at different macro depths

<p>
See <a href="#equ">8.14: $equ directive</a>


<a      name="lt_set"/>
<h4>4.7.10.4: Label Type $set</h4>


The label of a $set line has an absolute or a relocatable 
value according to the argument to which it is set.

<p>
$set labels may be redefined without restriction.
$set is actioned on both assembly passes.

<p>
A label name is defined independently and differently
at different macro depths.

<p>
See <a href="#set">8.46: $set directive</a>
	

<a      name="lt_equf"/>
<h4>4.7.10.5: Label Type $equf</h4>


$equf equates a label to a list of values.

<p>
A $equf name supplied as actual argument to a macro 
appears to macro text as a list of subfields. There
may be other subfields of the field in front. Extra
trailing subfields replace $equf subfield values
(line 10) starting at the second position
<pre>

$ masmx -lnky macaroon
MASMX 7r3
3/macaroon.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1: 	$include	../aside.dem/ppc_603.def
  :                            2 
  :                            3 macaroon $equf	600, r31
  :                            4 more	$equf	r3, 600, r31
  :                            5 
  :                            6 $(.text:131072)
  :                            7 
01:00020000 807F0258          +8 	lwz	r3, macaroon
01:00020004 807F0258          +9 	lwz	more
01:00020008 807E0258          +10 	lwz	more,,r30
  :                            11 
  :                            12 
*EOF*
:$(01):00020000:0002000C 

</pre>
If an $equf name is a token of expression, its value is its
first attribute, so macaroon+20 has a value of 620

<p>
Individual values in the $equf list may be retrieved with label\&xi;<br>
more\2 has the value 600

<p>
The first $equf subfield may be a relocatable address, but
<i>equf_label</i>\1 is not relocatable

<pre>

$ masmx crusti -lnky
MASMX 7r3
3/crusti.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1: 	$include	../aside.dem/ppc_603.def
  :                            2 
  :                            3 $(.data:*4)
  :                            4 croutons
  :                            5 bisque $equf croutons, r29
  :                            6 
  :                            7 $(.text:131072)
  :                            8 
(+03)10
01:00020000 80C00000          +9 	lwz	r6, croutons
(+03)10
01:00020004 80DD0000          +10 	lwz	r6, bisque
01:00020008 80DD0000          +11 	lwz	r6, bisque\1
*EOF*
:$(01):00020000:0002000C 


</pre>

See <a href="#equf">8.15: $equf directive</a>


<a      name="lt_directive"/>
<h4>4.7.10.6: Label Type $directive</h4>

The names of the 59 directives are labels. See <a href="#Directives">masmx Directives</a><br>
Directives may be assigned extra names using the <b>$equ</b> subcommand <b>$directive</b>
<pre>

MACRO   $equ,$directive $proc
MACEND  $equ,$directive $end


</pre>

<a      name="lt_function"/>
<h4>4.7.10.7: Label Type $function</h4>    


The internal functions available when the assembler begins
to execute have the type $function. The developer may also
alias those functions by giving equates the subtype of $function,
thus
<pre>

.       $equ,$function  "$"   ; $ is now also named .

</pre>
This only equates "." to location counter function "$" if "$"
is in quotes as shown. This retrieves the functional identity
of "$" for "."

<p>
"." now means the location counter function.

<p>
Without the quotes $ is evaluated functionally and "." receives
the current location value. See also <a href="#option_Q">-Q option</a>
and <a href="#option_m">-m option</a>


<a      name="lt_proc"/>
<h4>4.7.10.8: Label Type $proc</h4>

The label on column 1 of the $proc directive line has the label type of $proc.<br>
The following images until a mirroring $end are a $proc command macro.<br>
Embedded $procs mat be nested inside a $proc description. 

<p>
A $proc macro may be identified in the command position of an assembly<br>
source line by its $proc label or by a $name label, whichever is exported
with trailing asterisk

<p>
Inside a $proc an reference to its own label is a parameter reference or
paraform

<pre>

this_macro*      $proc
	jump    this_macro(1, 4)
	$end

	this_macro 1, 2, 3, away

</pre>
has the effect "jump away"

<p>
Example <i>this_macro</i>* must be unique in the subassembly calling it.
$proc labels often are not unique, and then may not be exported with<br>
the trailing asterisk* These $procs contain one or more  exported
$names which may also have a latent value

<p>
An exported $proc label may be referenced in an expression and has an
identify value unique in the calling subassembly

</pre>
<a      name="lt_name"/>
<h4>4.7.10.9: Label Type $name</h4>


$name is used within macro text $proc..$end or $func..$end
to give alternative call names with latent values
to the macro

<p>
$name labels have the type $name

<p>
$func and $proc macro labels need only be unique if they are exported.<br>
They are otherwise made callable by having unique $name labels
	
<p>
It is therefore possible to have identical and cryptic
labels for many macros, for example p
<pre>

instruction_form $form 8, 8, 16

p       $proc
grabit* $name   1
dropit* $name   2
	instruction_form   $n, p(1, 1), p(1, 2)
	$end


        grabit  r12, input_port
        dropit  r12, output_port

</pre>
The developer may have many procedural macros p. This makes the
argument reference paraforms p(1, 1) p(1, 2) similar in syntax
and easy to read in many different macros.<br>p is not used as a
call name, but the $name labels are.<br>p with no asterisk is only
a visible name within macro p, and this is why multiple macros
may have the same name

<p>
If the label on the $proc or $func line  is instead <i>pqrpqr</i> then<br>
actual parameters are referenced <i>pqrpqr(1, 1) pqrpqr(1, 2)</i>...

<p>
A macro is callable by its $proc or $func label or or by a  $name label,
whichever is exported with trailing asterisk*<br>Labels exported from macros
must be unique in the containing subassembly

<p>
See directive <a href="#name">8.31: $name</a>,
<a href="#proc_call">4.3.7: $proc Macro Calls: Instructions and Structures</a>,
<a href="#macro">10.2.2: ...$proc, $name, $end</a>,
<a href="#fmacname">4.6.2.2: ($func) Entry Point and Value Tag</a> 


<a      name="lt_func"/>
<h4>4.7.10.10: Label Type $func</h4> 


<p>
A $func label is the label on column 1 of a $func line.<br> 
$func..$end contains a user written value-generating macro and 
its value is the expression on the first $return line to be actioned 

<pre>

	$word	8

hi*	$func
	$return	hi(1, 1)/*8
	$end

	+	value, hi(value):L	; 16-bits little-endian


</pre>

Function macros are more often called by <a href="#name">$name</a> label than by $func label

<p>
See directive <a href="#func">8.21: $func</a>, <a href="#func_macro">4.2.2.4: Function Macro Reference</a> 

<a      name="lt_form"/>
<h4>4.7.10.11: Label Type $form</h4>


A label declared as $form returns the type $form and
describes the layout of an instruction or similar
bit-structure.

<p>
When a $form label is encountered in the command position
the corresponding storage structure is generated inline.

<pre>

powerpc_load_store_instruction  $form   6, 5, 5, 16


p       $proc
lwz*    $name   LWZ
stw*    $name   STW
lbz*    $name   LBZ
stb*    $name   STB
	.
	.
	powerpc_load_store_instruction $n,p(1, 1),.index\p(1, 2),p(1, 2)
	$end


</pre>

<a      name="lt_user"/>
<h4>4.7.10.12: Label Types Assigned by the Developer</h4>


Label type values 128..255 are available to the developer
who may use them to associate distinct attributes with
certain names.

<p>
The developer may assign types to names and the type
may be retrieved with function $t(..)

<p>
This accommodates the frequent practice with CISC
targets like ColdFire of assigning one mnemonic name
reflecting functionality to several instructions<br>
which have differing opcodes according to memory, register
or immediate operand and according to operand size
and transfer direction

<p>
Names like <i>add</i> and <i>move</i> may be many different
instructions which can only be fixed by understanding
what sort of operands are addressed 

<p>
A definition file for ColdFire might contain
<pre>

data_register   $equ    128
address_register $equ   129
pointer_register $equ   130
special_register $equ   131

d0      $equ,data_register      0
d1      $equ,data_register      1
	.
	.
d7      $equ,data_register      7

a0      $equ,address_register   0
a1      $equ,address_register   1
	.
	.
a7      $equ,address_register   7
	.
	.
a0@     $equ,pointer_register   0
a1@     $equ,pointer_register   1
	.
	.
a7@     $equ,pointer_register   7
	.
	.
ssp     $equ,special_register   $0407
usp     $equ,special_register   $0007
cr      $equ,special_register   1

</pre>

Correspondingly the instruction part of the target definition interrogates
the operand types of the actual arguments to instructions
<pre>

p       $proc
mov.b*  $name   MOV_B
mov.w*  $name   MOV_W
mov.l*  $name   MOV_L
	$if     $t(p(1,1))=data_register     
	.
	.

</pre>
<a      name="zenith"/>
<h3>4.7.11: $zenith -High Address of Section + Literals</h3>

<b>$zenith</b> is the high address of a section including its literals.<br>
To obtain the final high address, <b>$zenith</b> is retrieved after all of the section
is assembled on the second assembly pass. Then all literals have been added.


<h4>4.7.11.1: $zenith -this Section</h4>

Example
<pre>

	$do	$zenith>LIMIT,	$flag	section overrun

</pre>


<a      name="azenith"/>
<h4>4.7.11.2: $zenith(locator) -named Section</h4>

Example
<pre>

	$do	$zenith(_STATIC)>_STATIC_LIMIT,	$flag	static section overrun	

</pre>

<a	name="structure"/>
<h1>5: Iterated Code and Structured Data</h1>

<a	name="domac"/>
<h2>5.1: $do Directive and $proc Macros</h2>

<b>$do</b> directive repeats a line of code. An optional label is a count value ascending from 1.

See also <a href="#do">8.9: $do</a> directive

<p>
This $do example generates 615 floating constants with 11-bit exponent field.<br>
A scan routine uses this table to scale a floating number by its decimally
expressed exponent in the range &plusmn;307
<pre>

powers10_table
scale	$do	615,	1d*+scale-308	. generate 615 multiplier constants ranged 1.0e[-307..+307]

</pre>

<p>

The line of code on a $do line may be a macro call

<pre>

$ masmx sockets -lnk
MASMX 7r3
3/sockets.msm
*EOF*
  :                            1 	$word		16
  :                            2 
  :                            3 p	$proc
  :                            4 port*	$name
  :                            5 *	$tree
  :                            6 next	+	p(2, 1)L 
  :                            7 local	0L
  :                            8 port	+	p(1, 1)S
  :                            9 remote	0L
  :                            10 remoteP	0
  :                            11 
  :                            12 connection_chain	. connection port
  :                            13 message_chain		. datagram_port
  :                            14 	0L
  :                            15 	$root
  :                            16 	$end
  :                            17 
  :                            18 $(10:0A000)
  :                            19 
  :                            20 UPORTS	$equ	3
  :                            21 TPORTS	$equ	3
  :                            22 
0A:A000 A002                  +23 ufree	+	uport(1)S
0A:A001 A020                  +24 tfree	+	tport(1)S
  :                            25 
0A:A002 0000A00C              +26 ?	$do	UPORTS,uport(?)	port	1023+?	uport(?+1)
0A:A004 00000000              +26 
0A:A006 0400                  +26 
0A:A007 00000000              +26 
0A:A009 0000                  +26 
0A:A00A 00000000              +26 
0A:A00C 0000A016              +26 
0A:A00E 00000000              +26 
0A:A010 0401                  +26 
0A:A011 00000000              +26 
0A:A013 0000                  +26 
0A:A014 00000000              +26 
0A:A016 00000000              +26 
0A:A018 00000000              +26 
0A:A01A 0402                  +26 
0A:A01B 00000000              +26 
0A:A01D 0000                  +26 
0A:A01E 00000000              +26 
  :                            27 
0A:A020 0000A02A              +28 ?	$do	TPORTS,tport(?)	port	1023+?	tport(?+1)
0A:A022 00000000              +28 
0A:A024 0400                  +28 
0A:A025 00000000              +28 
0A:A027 0000                  +28 
0A:A028 00000000              +28 
0A:A02A 0000A034              +28 
0A:A02C 00000000              +28 
0A:A02E 0401                  +28 
0A:A02F 00000000              +28 
0A:A031 0000                  +28 
0A:A032 00000000              +28 
0A:A034 00000000              +28 
0A:A036 00000000              +28 
0A:A038 0402                  +28 
0A:A039 00000000              +28 
0A:A03B 0000                  +28 
0A:A03C 00000000              +28 
  :                            29 
*EOF*
:$(0A):A000:A03E 


</pre>

<b>$do</b> can be cascaded

<pre>

	$include	coldfire.def

.text	$equ	0

$(.text:524288,pc)

;	translate a 32-bit unsigned integer in d0 to 12 decimal digits in d0:d1:d2 quickly
;	three * 4-byte blocks are returned in registers without editing or truncation
;	this routine may be called from others which action sign / edit / store
;	the high order two digits of the 12 are guaranteed "00"

i2string
	move.l	#100000000, d2
	remu.l	d2, d1:d0			; separate the low-order 8 columns
	divu.l	d2, d0				; separate the high-order 2 columns
	divu.w	#10000, d1			; split to 4-column groups
	swap	d1				; translate the low-order 4 columns
	move.l	(table, pc, d1.w*4), d2
	swap	d1				; translate the next 4 columns
	move.l	(table, pc, d1.w*4), d1
	move.l	(table, pc, d0.w*4), d0		; translate the high-order 2 columns
	rts

table
	$list	0
thousands	$do	10,|
hundreds	$do	10,|
tens		$do	10,|
units		$do	10,	'0'+thousands-1, '0'+hundreds-1, '0'+tens-1, '0'+units-1L



</pre>


<a	name="stradata">
<h2>5.2: Structured Data and Structured Code Name Spaces</h2>

<a	name="strools">
<h3>5.2.1: Rules of Structured Spaces</h3>

masmx.7r3A applies a set of rules to the construction of hierarchical labelled code

<p>
Structures start <b>$tree</b> or <b>$branch</b> or <b>$record</b> or <b>$record,$branch</b>.
Structures end <b>$root</b>
<pre>

		$tree		$branch		$record		$record,$branch
		.		.		.		.
		$root		$root		$root		$root

</pre>
<b>$branch</b> redefines, or maps the same memory multiple times. <b>$tree</b> and <b>$branch</b>
construct word-aligned spaces. <b>$record</b> constructs bit-aligned spaces

<p>
Structures made with these directives are not templates but instances. Templates can be made
by describing structures in procedural macros
<pre>

	p	$proc			p	$proc
	callname* $name			rectype* $name
	*	$tree			*	$record
	left	$branch			left	$record,$branch
		.				.
		$root				$root
	right	$branch			right	$record,$branch
		.				.
		$root				$root
		$root				$root
		$end				$end

</pre>
Macro programming can link complex hierarchical structures together. A macro
claiming the label of the macro call for a <b>$tree</b> or <b>$branch</b> or
<b>$record</b> adds itself to the calling structure
<pre>


									p	$proc
	p	*proc			p	$proc			second_view $name
	upper*	*name			first_view* $name		*	$record	p(1, 1) p(1, 5)
	*	$tree			*	$record	p(1, 1)		ahead	12
	word10	+	p(1, 1)		field_a	5			left	$record, $branch p(1, 2)
	word11	+	p(1, 2)			$root			field_y	23
	first	$branch				$end				$root
	view1	first_view p(2)						right	$record, $branch p(1, 3) p(1, 4)
		$root							field1	19s
	second	$branch							field2	118
	view2	second_view p(3)						$root
		$root								7
		$root							beyond	4
		$end								$root
										$end

</pre>

Code structuring rules can begin to be demonstrated by setting these sample macros to work
<pre>

$ masmx -lnkxz
MASMX 7r3A
0/-INPUT>>
	$include	constru.def
$(4:04000)
table   upper	10,11 6 14,8191,63,"not very aligned",15
	$end
  :                            1  $word 16
  :                            2 
  :                            3 p       $proc
  :                            4 upper*  $name
  :                            5 *       $tree
  :                            6 word10  +       p(1, 1)
  :                            7 word11  +       p(1, 2)
  :                            8 first   $branch
  :                            9 view1   first_view       p(2) 
  :                            10         $root 
  :                            11 second  $branch
  :                            12 view2 second_view       p(3)
  :                            13         $root
  :                            14         $root
  :                            15         $end
  :                            16 
  :                            17 p       $proc
  :                            18 first_view* $name
  :                            19 *       $record         p(1, 1) 
  :                            20 field_a 5
  :                            21         $root
  :                            22         $end
  :                            23 
  :                            24 p       $proc
  :                            25 second_view* $name
  :                            26 *       $record         p(1, 1) p(1, 5)
  :                            27 ahead   12
  :                            28 left    $record,$branch p(1, 2)
  :                            29 field_y 23
  :                            30         $root
  :                            31 right   $record,$branch p(1, 3) p(1, 4)
  :                            32 field1  19s
  :                            33 field2  118
  :                            34         $root
  :                            35         7
  :                            36 beyond  4
  :                            37         $root
  :                            38         $end
  :                            39 
  :                            40 $(4:04000)
04:4000 000A                  +41 table   upper 10,11 6 14,8191,63,"not very aligned",15
04:4001 000B                  +41 
04:4002 3000                  +41 
04:4002 00E003FFE000          +41 
04:4002 0000007EDCDEE840ECCAE4F240C2D8D2CEDC0000
                              +41 
04:400B 00F0                  +41 
  :                            42  $end
upper=:N129:P:0:0000
first_view=:N129:P:0:0000
second_view=:N129:P:0:0000
table=$04:4000
table:word10=$04:4000
table:word11=$04:4001
table:first=$04:4002
table:first:view1=$04:4002,,,,0005
table:first:view1:field_a=$04:4002,,,,0005
table:second=$04:4002
table:second:view2=$04:4002,,,,00A0
table:second:view2:ahead=$04:4002,,,,000C
table:second:view2:left=$04:4002,,,000C,0017
table:second:view2:left:field_y=$04:4002,,,000C,0017
table:second:view2:right=$04:4002,,,000C,0089
table:second:view2:right:field1=$04:4002,,,000C,*0013
table:second:view2:right:field2=$04:4003,,,000F,0076
table:second:view2:beyond=$04:400B,,,000C,0004
constru.def=1<0004
-INPUT>>=0<0000
:$(04):4000:400C 


</pre>

For simplicity this example has a word size and address quantum both of 16 bits

<p>
Features are principally a named data or code hierarchy which for word aligned<br>
leaf items (at the start of this example structure) have at most two attributes,<br>
address and optional index base register. Items in bitfield structures have<br>
additionally a bit offset attribute and a bit size with signedness flag. Code<br>
within a substructure references local names without hierarchic preamble

<p>
Rules are

	<ol>
	<li>structure directives {$tree | $branch | $record } .. { $root }<br>
	    may be used without macro programming</li><br>

	<li>directives { $tree | $branch | $record } declare a structure instance not a template</li><br>

	<li>macro programming concerns templates</li><br>

	<li>parts nested textually inline without macro programming are in the structure</li><br>

	<li>parts connected by label inheritance from one $proc macro to another are in the structure</li><br>

        <li>every branch and leaf in the structure is at the same macro nesting level<br>
	    which is most often zero or main assembly, notwithstanding deeply nested macros<br>
	    may generate items in the structure</li><br>

	<li>an exported label of an entire structure has a negative macro-nesting depth as have<br>
	    other exported names, but its members have main assembly level zero</li><br>

        <li>$equ labels are included in the structure</li><br>

        <li>$set labels are not included in the structure</li><br>

        <li>a nested macro call which does not inherit the label of its invoking call<br>
	    may declare location labels which remain independent of the structure.<br>
	    Therefore instruction code within a structured namespace may contain two-pass<br>
	    macros containing forward reference to macro-local storage location labels</li>
	</ol>


<a      name="wstradata">
<h3>5.2.2: Word-Aligned Structures $tree / $branch..$root</h3>

<a      name="tree_root">
<h4>5.2.2.1: Structures $tree..$root</h4>

<p>
$tree is used to structure a name space containing data or code.

<p>
The structure is ended with $root. The tree must 
have a label:
<pre>

name    $tree
datum1	.
datum2	.
	$root

</pre>
<p>
$tree may be inside a $proc macro or not. If a $tree is inside a
$proc, the label of the $tree may be the inherited label from
the macro call line, for example
<pre>

p       $proc
species $name
*       $tree
many    $do     p(),branch(many)   $res    4
	$root
	$end

</pre>


<p>
$tree..$root structures may be nested to depth 8.
Other examples can be found in <a href="#tree">8.54: $tree Directive</a>


<a      name="branch_root">
<h4>5.2.2.2: Overlaid Structures $branch..$root</h4>


<p>
Structures declared with $branch instead of $tree start from
the same storage address. Values may freely be declared. The later
declared values load last:
<pre>

MASMX 7r2
3/ast.msm
*EOF*
  :                            1        $word   32
  :                            2 
  :                            3 $(4:040000)
  :                            4 
  :                            5 ast1   $branch
  :                            6 axil   $res    1
  :                            7 twig   $res    1
  :                            8 x      $do     12,leaf(x)      $res    1
04:0004000E 11111111          +9        +       011111111
  :                            10       $root
  :                            11 
  :                            12 ast2  $branch
  :                            13 x     $do     6,blossom(x)    $res    1
04:00040006 22222222          +14       +       022222222
  :                            15       $root
*EOF*

......

AST1=$04:00040000
AST1:AXIL=$04:00040000
AST1:TWIG=$04:00040001
AST1:LEAF(1)=$04:00040002
AST1:LEAF(2)=$04:00040003
AST1:LEAF(3)=$04:00040004
AST1:LEAF(4)=$04:00040005
AST1:LEAF(5)=$04:00040006
AST1:LEAF(6)=$04:00040007
AST1:LEAF(7)=$04:00040008
AST1:LEAF(8)=$04:00040009
AST1:LEAF(9)=$04:0004000A
AST1:LEAF(10)=$04:0004000B
AST1:LEAF(11)=$04:0004000C
AST1:LEAF(12)=$04:0004000D
AST2=$04:00040000
AST2:BLOSSOM(1)=$04:00040000
AST2:BLOSSOM(2)=$04:00040001
AST2:BLOSSOM(3)=$04:00040002
AST2:BLOSSOM(4)=$04:00040003
AST2:BLOSSOM(5)=$04:00040004
AST2:BLOSSOM(6)=$04:00040005
X=00000006
ast.msm=0<00000003
:$(04):00040000:0004000F 
ast.msm: object code 76 bytes: 0 errors: 0 undefined labels


</pre>
<p>
Pointer-based structures may be branched in the same way:
<pre>

$ masmx -lnkx transport
MASMX 7r3
3/transport.msm
*EOF*
  :                            1 	$word	16
  :                            2 	$quantum	8
  :                            3 	$awidth	32
  :                            4 
  :                            5 p	$proc
  :                            6 udp_datagram* $name
  :                            7 sourcep	+	p(1,1)
  :                            8 destp   +       p(1,2)
  :                            9 length  +       p(1,3)
  :                            10 checksum +      p(1,4)
  :                            11 data
  :                            12 	$end
  :                            13 
  :                            14 p	$proc
  :                            15 tcp_segment*	$name
  :                            16 sourcep	+	p(1,1)
  :                            17 destp	+	p(1,2)
  :                            18 sequence +	0:d
  :                            19 ack	+	0:d
  :                            20 hl_code	+	0
  :                            21 window	+	0
  :                            22 checksum +	0
  :                            23 urgent	+	0
  :                            24 data
  :                            25 	$end
  :                            26 
  :                            27 pointer_register $equ	15
  :                            28 
  :                            29 $(67:,pointer_register)
  :                            30 
  :                            31 user_datagram	$branch
  :                            32 		udp_datagram
  :                            33 		$root
  :                            34 
  :                            35 tcp_segmentP	$branch
  :                            36 		tcp_segment
  :                            37 		$root
  :                            38 
*EOF*
udp_datagram=:N129:P:0:0000
tcp_segment=:N129:P:0:0000
pointer_register=000F
user_datagram=$43:00000000,0000000F
user_datagram:sourcep=$43:00000000,0000000F
user_datagram:destp=$43:00000002,0000000F
user_datagram:length=$43:00000004,0000000F
user_datagram:checksum=$43:00000006,0000000F
user_datagram:data=$43:00000008,0000000F
tcp_segmentP=$43:00000000,0000000F
tcp_segmentP:sourcep=$43:00000000,0000000F
tcp_segmentP:destp=$43:00000002,0000000F
tcp_segmentP:sequence=$43:00000004,0000000F
tcp_segmentP:ack=$43:00000008,0000000F
tcp_segmentP:hl_code=$43:0000000C,0000000F
tcp_segmentP:window=$43:0000000E,0000000F
tcp_segmentP:checksum=$43:00000010,0000000F
tcp_segmentP:urgent=$43:00000012,0000000F
tcp_segmentP:data=$43:00000014,0000000F
transport.msm=0<00000003
:$(43):00000000:00000014 


</pre>

<a      name="name_space">
<h4>5.2.2.3: Structured Code Name Spaces</h4>

<b>$tree..$root</b> construct may be used to compartment the local names
of code routines in the manner of block-structured languages
<pre>

$ masmx -lnkx routines
MASMX 7r3
3/routines.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            4 	$list
  :                            5 	$path
  :                            6 
  :                            7 .data	$equ	5
  :                            8 .text	$equ	0
  :                            9 
  :                            10 $(.data:0x5000)
  :                            11 $(.text:16384)
  :                            12 
  :                            13 routineA	$tree
  :                            14 $(.data)
05:00005000 001E              +15 counter	+	30
05:00005002 0000A000          +16 pointer	+	0x0a000L
  :                            17 $(.text)
00:00004000 30385000          +18 	move.w	counter, d0
00:00004004 20785002          +19 	movea	pointer, a0
  :                            20 
  :                            21 	;
  :                            22 	;
00:00004008 4E75              +23 	rts
  :                            24 	$root
  :                            25 
  :                            26 routineB	$tree
  :                            27 $(.data)
05:00005006 003C              +28 counter	+	60
05:00005008 0000B000          +29 pointer	+	0x0b000L
  :                            30 $(.text)
00:0000400A 30385006          +31 	move.w	counter, d0
00:0000400E 20785008          +32 	movea	pointer, a0
  :                            33 
  :                            34 	;
  :                            35 	;
00:00004012 4E75              +36 	rts
  :                            37 	$root
  :                            38 
*EOF*
.data=0005
.text=0000
routineA=$00:4000
routineA:counter=$05:5000
routineA:pointer=$05:5002
routineB=$00:400A
routineB:counter=$05:5006
routineB:pointer=$05:5008
../smaragd.68k/coldfire.def=1<00000005
routines.msm=0<00000003
:$(00):00004000:00004014 :$(05):00005000:0000500C 



</pre>

<a      name="bstradata"/>
<h3>5.2.3: Bit-Aligned Structures</h3>

<a      name="record_root"/>
<h4>5.2.3.1: Bit-Aligned Data $record..$root</h4>

<b>$record</b>..<b>$root</b> structures are bit aligned

<p>
masmx naming techniques allow macro code to read and write complex bit-aligned data

<p>
<b>$record</b> structures may be more or less complex. Fields which are not accessed
do not need a label. All fields need a length. <b>$record</b> requires a label

<p>
<b>$record</b> shares the structured name plan with <b>$tree</b> and <b>$branch</b>,
and likewise ends with </b>$root

<p>
Outermost <b>$record</b> starts at a word boundary and nested <b>$record</b>s
start at the bit location which has been reached

<p>
Any initial values are spaced arguments of the <b>$record</b> lines

<p>
An argument on a <b>$record</b> line is not a bit length but a data value for a contained field

<p>
<b>$record</b> labels acquire a group length attribute as seen below

<p>
Nested <b>$record</b>s have their own arguments. Containing <b>$record</b>s place
initial values in their own fields and not in the fields of nested <b>$records</b>

<p>
It can be seen here that initial value 10 is assembled after embedded
<b>inner $record</b> 

<pre>

$ masmx record.msm -lnkx
MASMX 7r3
3/record.msm
*EOF*
  :                            1 $(3:03000)
  :                            2 
  :                            3 	$word		16
  :                            4 
  :                            5 outermost $record			'o' 1 1 1 10
  :                            6 first_field	9
  :                            7 ?	$do	3,field(?)	9
  :                            8 inner	$record				6 4 6 4
  :                            9 ?	$do	4,field(?)	3
  :                            10 	$root
  :                            11 trailing 12
03:3000 378040201D3400A0      +12 	$root
  :                            13 
*EOF*
outermost=$03:3000,,,,003C
outermost:first_field=$03:3000,,,,0009
outermost:field(1)=$03:3000,,,0009,0009
outermost:field(2)=$03:3001,,,0002,0009
outermost:field(3)=$03:3001,,,000B,0009
outermost:inner=$03:3002,,,0004,000C
outermost:inner:field(1)=$03:3002,,,0004,0003
outermost:inner:field(2)=$03:3002,,,0007,0003
outermost:inner:field(3)=$03:3002,,,000A,0003
outermost:inner:field(4)=$03:3002,,,000D,0003
outermost:trailing=$03:3003,,,,000C
?=0004
record.msm=0<0003
:$(03):3000:3004 


</pre>

<p>
Bit-aligned structures may be simple or overlaid in memory to any extent
and may be nested

<p>
masmx labels each field with address, bit offset, bit size and signed attribute
plus optionally base-displacement pointer register.<br>The attributes of each field
are held in one label of type <b>$equf</b>

<p>
$record does not have separate template and instance steps. Describing a $record layout is also describing an instance

<p>
For this reason $record may be found within a $proc macro

<p>
$proc macros can assign actual arguments to any nested $record in their scope



<a      name="record_macro"/>
<h4>5.2.3.2: Macro Code Access to Bit-Aligned Fields and Groups</h4>


<p>
masmx labelling allows macro language specific to the target to read and
write bit-aligned fields

<p>
Here ColdFire-specific macro language retrieves fields from an inventory
<pre>

$ masmx betaille -lnk
MASMX 7r3
3/betaille.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	record_x.def
  :                            4 	$path
  :                            5 
  :                            6 p	$proc
  :                            7 hameau*	$name
  :                            8 *	$record	p(1, 2), p(1, 3) p(1, 4)
  :                            9 oies	18
  :                            10 anes	12
  :                            11 moutons	16
  :                            12 	$root
  :                            13 	$end
  :                            14 
  :                            15 p	$proc
  :                            16 commune* $name
  :                            17 *	$record
  :                            18 ?	$do	p(),"p(?, 1)"	hameau	p(?)
  :                            19  	$root
  :                            20 	$end
  :                            21 
  :                            22 
  :                            23 $(5:050000)
  :                            24 communes $record
                                Vaux_les_Pres	commune	les_Cotards, 80, 5, 248	|
                                			le_Charmelot, 660, 24, 79 |
  :                            27 			village, 28, 2, 5
  :                            28 
                                Villers_Buzon	commune	centre, 10, 1, 30	|
05:00005000 0014001403E00294018004F000700080014000A001001E00
                              +30 			Combe_au_Loup, 15,,315
05:00005018 03C00004EC00      +31 	$root
  :                            32 
  :                            33 $(0:16384)
  :                            34 
00:00004000 2038501A          +35 	retrieve	communes.Villers_Buzon.Combe_au_Loup.moutons
00:00004004 E088              +35 
00:00004006 E488              +35 
00:00004008 32385008          +36 	retrieves	communes.Vaux_les_Pres.le_Charmelot.anes	d1
00:0000400C 4841              +36 
00:0000400E 323C0014          +36 
00:00004012 E2A1              +36 
  :                            37 
00:00004014 24385016          +38 	lretrieve	communes.Villers_Buzon.Combe_au_Loup.oies	d2
00:00004018 E18A              +38 
00:0000401A E08A              +38 
00:0000401C EC8A              +38 
00:0000401E 26385010          +39 	lretrieve	communes.Villers_Buzon.centre.oies	d3
00:00004022 E18B              +39 
00:00004024 E58B              +39 
00:00004026 E08B              +39 
00:00004028 EC8B              +39 
*EOF*
:$(00):00004000:0000402A :$(05):00005000:0000501E 


</pre>


<a      name="record_overlay"/>
<h4>5.2.3.3: Bit-Aligned Structure Overlay and Overload: $record,$branch</h4>

<b>$record</b> structures can may be overlaid or redefined with the addition of
<b>,$branch</b> subfunction.<br>
Each branch of the union starts at the same bit position
<pre>

$ masmx mfeuille -lnk
MASMX 7r3
3/mfeuille.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	record_x.def
  :                            4 	$path
  :                            5 
  :                            6 $(5:050000)
  :                            7 
  :                            8 layer4  $record,$branch         10 11 12 13 14 15
05:00005000 ABCDEF000000000000000000000000000000000000000000
                              +9 ?       $do     60,quartet(?)   4
  :                            10         $root
  :                            11 layer5  $record,$branch
  :                            12 ?       $do     80,quintet(?)   5s
  :                            13         $root
  :                            14 layer6  $record,$branch
  :                            15 ?       $do     40,sextet(?)    6
  :                            16 	$root
  :                            17 
  :                            18 $(64:65536)
  :                            19 
40:00010000 30385000          +20 	retrieve	layer5.quintet(2)	; substring is .
40:00010004 4840              +20 
40:00010006 EB88              +20 
40:00010008 303C001B          +20 
40:0001000C E0A0              +20 
40:0001000E 1438501D          +21 	retrieve	layer6.sextet(40)	d2
40:00010012 02820000003F      +21 
*EOF*
:$(05):00005000:00005032 :$(40):00010000:00010018 


</pre>
Initial values in overlaid locations may be overloaded. However masmx load code
is in words. Overloads on a storage word are not merged

<pre>

$ masmx -lnkx moreover.msm 
MASMX 7r3
3/moreover.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            5 	$list
  :                            6 	$path
  :                            7 
  :                            8 
  :                            9 $(3:03000)
  :                            10 first	$record,$branch	1 2 3
  :                            11 one	4
  :                            12 two	4
  :                            13 three	4
  :                            14 "O'Leary" 20
03:00000600 12300000          +15 	$root
  :                            16 second	$record,$branch
  :                            17 fill	4
  :                            18 second1	$record,$branch	4 5 6
  :                            19 one	4s
  :                            20 two	4
  :                            21 three	4
03:00000600 0456              +22 	$root
  :                            23 second2	$record,$branch	7 8
  :                            24 one	4
  :                            25 two	4
03:00000600 0780              +26 	$root
  :                            27 	$root
  :                            28 third	$record,$branch	63
  :                            29 longways 18
03:00000600 000FC000          +30 	$root
  :                            31 
  :                            32 new	$record	10 6
  :                            33 discriminator 4
  :                            34 first	$record,$branch	"carpets"
  :                            35 text	48
03:00000604 A636172706574000  +36 	$root
  :                            37 second	$record,$branch	10 11 12 13 14 15
  :                            38 ?	$do	9,quartet(?)	4
03:00000604 0ABCDEF00000      +39 	$root
  :                            40 marker	4
03:0000060A 0600              +41 	$root
  :                            42 
03:0000060C 400001E00000000000000000
                              +43 sum	1.75
  :                            44 	
  :                            45 $(0:64)
00:00000040 10380601          +46 	retrieve	first.three
00:00000044 E888              +46 
00:00000046 02800000000F      +46 
00:0000004C 12380600          +47 	retrieve	second.fill		d1
00:00000050 E889              +47 
00:00000052 02810000000F      +47 
00:00000058 34380600          +48 	retrieve	second.second1.one	d2
00:0000005C 4842              +48 
00:0000005E E98A              +48 
00:00000060 343C001C          +48 
00:00000064 E4A2              +48 
00:00000066 16380601          +49 	retrieve	second.second1.three	d3
00:0000006A 02830000000F      +49 
00:00000070 38380600          +50 	retrieve	second.second2		d4
00:00000074 E88C              +50 
00:00000076 0284000000FF      +50 
00:0000007C 3A380606          +51 	retrieves	new.second.quartet(5)	d5
00:00000080 4845              +51 
00:00000082 E98D              +51 
00:00000084 3A3C001C          +51 
00:00000088 EAA5              +51 
  :                            52 
*EOF*
first=$03:00000600,,,,00000020
first:one=$03:00000600,,,,00000004
first:two=$03:00000600,,,00000004,00000004
first:three=$03:00000600,,,00000008,00000004
first:O'Leary=$03:00000600,,,0000000C,00000014
second=$03:00000600,,,,00000010
second:fill=$03:00000600,,,,00000004
second:second1=$03:00000600,,,00000004,0000000C
second:second1:one=$03:00000600,,,00000004,80000004
second:second1:two=$03:00000600,,,00000008,00000004
second:second1:three=$03:00000600,,,0000000C,00000004
second:second2=$03:00000600,,,00000004,00000008
second:second2:one=$03:00000600,,,00000004,00000004
second:second2:two=$03:00000600,,,00000008,00000004
third=$03:00000600,,,,00000012
third:longways=$03:00000600,,,,00000012
new=$03:00000604,,,,00000038
new:discriminator=$03:00000604,,,,00000004
new:first=$03:00000604,,,00000004,00000030
new:first:text=$03:00000604,,,00000004,00000030
new:second=$03:00000604,,,00000004,00000024
new:second:quartet(1)=$03:00000604,,,00000004,00000004
new:second:quartet(2)=$03:00000604,,,00000008,00000004
new:second:quartet(3)=$03:00000604,,,0000000C,00000004
new:second:quartet(4)=$03:00000606,,,,00000004
new:second:quartet(5)=$03:00000606,,,00000004,00000004
new:second:quartet(6)=$03:00000606,,,00000008,00000004
new:second:quartet(7)=$03:00000606,,,0000000C,00000004
new:second:quartet(8)=$03:00000608,,,,00000004
new:second:quartet(9)=$03:00000608,,,00000004,00000004
new:marker=$03:0000060A,,,00000004,00000004
?=0009
sum=$03:060C
../smaragd.68k/record_x.def=1<00000005
../smaragd.68k/coldfire.def=1<00000005
moreover.msm=0<00000003
:$(00):00000040:0000008A :$(03):00000600:00000618 


</pre>


<a      name="signed_bitfield"/>
<h4>5.2.3.4: Signed Bit Fields</h4>

Option <b>-Y</b> causes bit fields to be flagged as signed unless the length is marked
with trailing <b>u</b>
<pre>

record1	$record
quarter	4	; signed if option -Y	
quintet	5u	; never signed
	$root

</pre>

If <b>-Y</b> is not opted, only fields marked with trailing <b>s</b> on the length
are flagged to be signed
<pre>

record2	$record
quartet	4	; signed if option -Y
quintet	5s	; always signed
	$root

</pre>
Signedness is flagged on the length attribute of the field identifier. The flag
indicates an intention of signedness which macro text <i>may</i> action

<p>
Macro text responds in this sample assembly to signed attribute on bit quintet fields
<pre>

layer4:quartet(60)=$05:0000501C,,,0000000C,00000004
?=0028
layer5=$05:00005000,,,,00000190
layer5:quintet(1)=$05:00005000,,,,80000005
layer5:quintet(2)=$05:00005000,,,00000005,80000005

$ masmx -lnk mfeuille.msm 
MASMX 7r3
3/mfeuille.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	record_x.def
  :                            4 	$path
  :                            5 
  :                            6 $(5:050000)
  :                            7 
  :                            8 layer4  $record,$branch         10 11 12 13 14 15
05:00005000 ABCDEF000000000000000000000000000000000000000000
                              +9 ?       $do     60,quartet(?)   4
  :                            10         $root
  :                            11 layer5  $record,$branch
  :                            12 ?       $do     80,quintet(?)   5s
  :                            13         $root
  :                            14 layer6  $record,$branch
  :                            15 ?       $do     40,sextet(?)    6
  :                            16 	$root
  :                            17 
  :                            18 $(64:65536)
  :                            19 
40:00010000 30385000          +20 	retrieve	layer5.quintet(2)	; substring is .
40:00010004 4840              +20 
40:00010006 EB88              +20 
40:00010008 303C001B          +20 
40:0001000C E0A0              +20 



</pre>
Macro text may on access override the flagged signedness of a field. This macro<br>
definition extract has retrieval entry point names for default, unsigned
override and signed override
<pre>


p       $proc
retrieve* $name         1       . signed if field is flagged signed
retrieves* $name        2       . signed override
retrieveu* $name        0       . unsigned override

SIGNED  $set    p(2, *5)+p(0, 0)/*1
.
.


</pre>


<a name="record_float"/>

<h4>5.2.3.5: $record compressed floating constant arrays</h4>

Floating values targeted to bit-aligned fields have the exponent size and
rounding position indicated for their bitsize.<br>This routine generates an
array of 1572864 floating numbers compressed and rounded to 24 bits

<pre>

$ cat pxar.msm
	$word		32
	$cont_char	'|'
	$do	$o('k')=0,	$exit	this assembly depends on option -k

	$include	zones.def

ROWS	$equ	1024
COLUMNS	$equ	1536


p	$proc
muster*	$name

p       $proc
horizontal* $name

p       $proc
slice*  $name

f*	$func
area	$do	zone(?),				|
	$do	!*24-24+t(1, 1)+1&gt;zone(?, area)\1,	|
	$do	!*24-24+t(1, 1)-1&lt;zone(?, area)\2,	$return	zone(?,area)\3*+zone(?,area)\4
	$return	DEFAULT
	$end

*       $record f(0)  f(1)  f(2)  f(3)  f(4)  f(5)  t(6)  f(7)	|
		f(8)  f(9)  f(10) f(11) f(12) f(13) f(14) f(15)	|
		f(16) f(17) f(18) f(19) f(20) f(21) f(22) f(23)
        $do     24,      24
        $root
        $end
*       $record

!       $do     COLUMNS/24,field(!)      slice
        $root
        $end
*	$record
?	$do	ROWS,row(?)	horizontal
	$root
	$end


pattern	muster

$

</pre>


In this case nothing except a floating array all of one number size is required, although
$record packs fields of arbitrary and irregular bitsize and content

<p>
In similar cases where only a floating array is required, the array could also
be separately assembled in its target word size and linked to the application

<a      name="algors"/>
<h1>6: Run-Time Algorithm Plotter</h1>

<p>
Assemblers mostly resolve expressions whose tokens are all known at assembly time

<p>
<b>$xqt_fp</b> and <b>$xqt_i</b> directives code an instruction plan in a<br>
compiler-like fashion however, to solve expressions involving run-time variables<br>
first resolving sequences within the expression whose token values are known at assembly time

<p>
These instruction steps are planned with the support of target-specific macros with<br>
fixed call-names known to masmx 


<a      name="ialgors"/>
<h2>6.1: Run-Time Integer Algorithm Plotter $xqt_i</h2>

<b>$xqt_i</b> processes integers and can resolve all expression steps
between constants at assembly time,<br> planning the fewest possible instructions
for run time calculation

<p>
In this example the sequence right of the OR operator <b>++</b> has been
resolved at assembly time,<br> but left of <b>++</b> a multiply, two adds and a
shift must take place at runtime

<pre>

$ masmx -lnk boolean
MASMX 7r3
3/boolean.msm
CONT_CHAR=|
LTERM=;
STERM=.
  :                            1 	$path		../
  :                            2: 	$include	smaragd.68k/coldfire.def
  :                            3: 	$include	smaragd.68k/express.def
  :                            4 	$path
  :                            5: 	$include	espresso.def
  :                            6 
  :                            7 $(3:03000)
03:00000600 0001              +8 one	1
03:00000602 00000002          +9 two	2d
03:00000606 00000003          +10 three	3d
  :                            11 $(0:32768)
00:00008000 30380600          +12 	$xqt_i,#	two+one w*4+three*/16++12*/20
00:00008004 C1FC0004          +12 
00:00008008 D0B80602          +12 
00:0000800C D0B80606          +12 
00:00008010 E188              +12 
00:00008012 E188              +12 
00:00008014 80BC00C00000      +12 
00:0000801A 3002              +13 	$xqt_i		d2 w+d3+d4
00:0000801C D083              +13 
00:0000801E D084              +13 
  :                            14 	$do	$<256,$(0:256)
  :                            15 	$end
:$(00):00008000:00008020 :$(03):00000600:0000060A 


</pre>

Some of the identifiers in this these expressions are followed with space then <b>w</b><br>
This informs macro language that the variable input to the algorithm is a ColdFire word
of 16 bits where inputs are otherwise 32 bits

<p>
One of the <b>$xqt_i</b> directives is followed with a subcommand <b>,#</b>

<p>
This floats the symbol <b>#</b> onto the front of the constant sequences <b>16</b> and <b>12*/20</b>

<p>
Directive <b>$xqt_i</b> surrounds constant sequences with parentheses, so that target definitions<br>
which use automatic literals would generate the literals (16) and (12*/20)

<p>
Automatic literals are not opted in <b>coldfire.def</b> because this would disrupt<br>
the many parenthesised operand expressions in accepted source syntax

<p>
For ColdFire integer arithmetic, literals are unnecessary because<br>
32-bit integer immediate operands indicated with prefix <b>#</b> are available

<p>
The floated <b>#</b> at line 12 is attached to these two immediate operand clauses
<pre>

	#(16)
	#(12*/20)

</pre>
Target specific macros required for $xqt_i and $xqt_fp have the names called from this target-independent
outline scheme

<p>
The target specific parts like LOAD and LOAD_NEGATIVE are fewer in number 
than these wrappers which $xqt_i and $xqt_fp call

<pre>

$ cat espresso.def

p	$proc
"$i_load"*	$name
	LOAD	p()
	$end

p	$proc
"$i_load_negative"*	$name
	LOAD_NEGATIVE	p()
	$end

p	$proc
"$i_testequal"*	$name
	TEST_EQUAL	p()
	$end

p	$proc
"$i_testunequal"*	$name
	TEST_NE	p()
	$end

p	$proc
"$i_testgreater"*	$name
	TEST_GREATER	p()
	$end

p	$proc
"$i_testless"*	$name
	TEST_LESS	p()
	$end

p	$proc
"$i_shift"*	$name
	SHIFT	p()
	$end

p	$proc
"$i_shift_right"*	$name
	SHIFT_RIGHT	p()
	$end

p	$proc
"$i_or"*	$name
	OR	p()
	$end

p	$proc
"$i_and"*	$name
	AND	p()
	$end

p	$proc
"$i_xor"*	$name
	XOR	p()
	$end

p	$proc
"$i_add"*	$name
	ADD	p()
	$end

p	$proc
"$i_subtract"*	$name
	SUBTRACT	p()
	$end

p	$proc
"$i_multiply"*	$name
	MULTIPLY	p()
	$end

p	$proc
"$i_divide"*	$name
	DIVIDE	p()
	$end

p	$proc
"$i_covered_quotient"*	$name
	DIVIDE_ROUNDED	p()
	$end

p	$proc
"$i_remainder"*	$name
	MODULO	p()
	$end

p	$proc
"$i_reserve"*	$name
	PUSH
	$end

p	$proc
"$i_reverse"*	$name
	REVERSE
	$end

"$i_retrieve_testequal"*	$proc
	TEST_EQUAL	STACK_TOP
	POP
	$end

"$i_retrieve_testunequal"*	$proc
	TEST_NE	STACK_TOP
	POP
	$end

"$i_retrieve_testgreater"*	$proc
	TEST_GREATER	STACK_TOP
	POP
	$end

"$i_retrieve_testless"*	$proc
	TEST_LESS	STACK_TOP
	POP
	$end

"$i_retrieve_shift"*	$proc
	SHIFT	STACK_TOP
	POP
	$end

"$i_retrieve_shift_right"*	$proc
	SHIFT_RIGHT	STACK_TOP
	POP
	$end

"$i_retrieve_or"*	$proc
	OR	STACK_TOP
	POP
	$end

"$i_retrieve_and"*	$proc
	AND	STACK_TOP
	POP
	$end

"$i_retrieve_xor"*	$proc
	XOR	STACK_TOP
	POP
	$end

"$i_retrieve_add"*	$proc
	ADD	STACK_TOP
	POP
	$end

"$i_retrieve_subtract"*	$proc
	SUBTRACT	STACK_TOP
	POP
	$end

"$i_retrieve_multiply"*	$proc
	MULTIPLY	STACK_TOP
	POP
	$end

"$i_retrieve_divide"*	$proc
	DIVIDE	STACK_TOP
	POP
	$end

"$i_retrieve_covered_quotient"*	$proc
	DIVIDE_ROUNDED	STACK_TOP
	POP
	$end

"$i_retrieve_remainder"*	$proc
	MODULO	STACK_TOP
	POP
	$end

p       $proc
"$x_load"* $name
	FP_LOAD		p()
	$end

p       $proc
"$x_load_negative"* $name
	FP_LOAD_NEGATIVE p()
	$end

p	$proc
"$x_add"*	$name
	FP_ADD		p()
	$end

p       $proc
"$x_subtract"* $name
	FP_SUBTRACT	p()
	$end

p       $proc
"$x_multiply"* $name
	FP_MULTIPLY	p()
	$end

p       $proc
"$x_divide"* $name
	FP_DIVIDE	p()
	$end

"$x_reserve"* $proc
	FPUSH
	$end

p	$proc
"$x_reverse"* $name
	FP_REVERSE
	$end

"$x_retrieve_add"* $proc
        FP_ADD		FP_STACK_TOP
        FPOP
        $end

"$x_retrieve_subtract"* $proc
        FP_SUBTRACT	FP_STACK_TOP
        FPOP
        $end

"$x_retrieve_multiply"* $proc
        FP_MULTIPLY	FP_STACK_TOP
        FPOP
        $end

"$x_retrieve_divide"* $proc
	FP_DIVIDE	FP_STACK_TOP
	FPOP
	$end

</pre>

<p>
This macro frame can be assembled for any target. It references
simple target-specific $proc macros which populate the following names<br>
and update designated result registers
<pre>

	LOAD		LOAD_NEGATIVE	TEST_EQUAL	TEST_NE		TEST_GREATER	TEST_LESS
	SHIFT		SHIFT_RIGHT	OR		AND		XOR		REVERSE
	ADD		SUBTRACT	MULTIPLY	DIVIDE		DIVIDE_ROUNDED	MODULO

</pre>
Instructions in the four TEST_ macros have a runtime result
of one for true and zero for untrue

<p>
The macro
<pre>

	REVERSE

</pre>
negates an accumulation in the result register to cover cases like
<pre>

	-(<i>x*y-z</i>)

</pre>
There may be advantage in a different instruction sequence from simple LOAD_NEGATIVE
<p>
The macro
<pre>

	PUSH

</pre>
saves the result register either in a real stack or in a list of registers<br>
managed at assembly time with macro text

<p>
The function macro
<pre>

	STACK_TOP

</pre>
is the most recent stored value in the stack or save register list

<p>
The macro
<pre>

	POP

</pre>
for some targets needs no separate instructions and is void. POP is however
separated in case the stacked value must be cleared,<br>
because STACK_TOP is a function not a procedure,
and function macros in masmx may not generate code.

<p>
Interim results are saved and retrieved in various ways according
to target architecture
<pre>

;		In ColdFire saves/retrieves PUSH macro generates an instruction

;		STACK_TOP function causes its associated operation to pop the stack
;		without a separate instruction

;		LOAD and arithmetic macros need to distinguish register / storage / immediate arguments

PUSH*		$proc				; ColdFire
		move.l			d0, -(a7)
		$end

STACK_TOP*	$equ,"$a_reg_@+"	"(a7)+"	; ColdFire
POP		$equ,$directive	$nop		; ColdFire

.		____________________________________

#		in PowerPC saves/retrieves, PUSH macro generates a save instruction
#		and designates without hardware action the next save location

#		STACK_TOP function and POP macro identify and redesignate an operand source
#		without any operation taking place on hardware

#		LOAD and arithmetic macros need to distinguish register / storage / immediate arguments

#		arithmetic macros must load storage operands to a GPR designated as threshold.
#		The threshold may be the next designated set_aside register

LISTP		$set	1		# PPC32
SAVE(1)		$equ	r20
SAVE(2)		$equ	r21
SAVE(3)		$equ	r22

PUSH*		$proc			# PPC32
		$do	LISTP>3,	$flag	assign more save registers
		mr	r0,SAVE(LISTP)
LISTP*		$set	LISTP+1
		$end

STACK_TOP*	$func
		$return	SAVE(LISTP-1)	# PPC32
		$end

POP*		$proc			# PPC32
LISTP**		$set	LISTP-1
		$end	


</pre>

<a      name="fpalgors"/>
<h2>6.2: Run-Time Floating Algorithm Plotter</h2>

<p>
<b>$xqt_fp</b> directive scans an expression and calls macro code to write an
instruction plan

<p>
Macro code is specific per target and has macro call names global to all targets

<p>
Macro code may compute into any result register considered intuituve or serviceable

<p>
Tokens which are constants appear as literals at the foot of the program

<p>
An algorithm which can be stated as an expression is assembled in one pass of one <b>$xqt_fp</b> line

<p>
<b>$xqt_fp</b> does not currently attempt assembly-time calculation of expression
steps between constant terms. The assembly platform may not be the target device. masmx generates constants for any floating architecture but executes no floating arithmetic. Each floating operation is at runtime

<p>
<b>$xqt_fp</b> resolves four-function arithmetic and parentheses. All algorithms are built from these

<p>
<b>$xqt_fp</b> is demonstrated here with ColdFire architecture. Macro code in fpxpress.def for ColdFire computes into register fp0

<p>
The first simple algorithm has five inputs and is executed in five instructions, including
operand acquisition from storage.<br>
Operations follow masmx expression precedence order. Three of the
five tokens are identifiers whose content is only known at runtime

<p>
The second algorithm has a mixture of register, storage and pointer inputs
<pre>

$ ~/masmx -lnky r2xample.msm 
MASMX 7r3
3/r2xample.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 
  :                            2 	$path		../smaragd.68k
  :                            3: 	$include	coldfire.def
  :                            4: 	$include	express.def
  :                            5: 	$include	fpxpress.def
  :                            6 	$path
  :                            7: 	$include	espresso.def
  :                            8: 	$include	ieee754.def
  :                            9 
  :                            10 $(4:16384,a5/$literal)
  :                            11 
  :                            12 one	$res	8
  :                            13 two	$res	8
  :                            14 three	$res	8
  :                            15 
  :                            16 westward $res	2
  :                            17 ho	$res	2
  :                            18 
  :                            19 $(5:16384+1024)
  :                            20 rastore	$res	8
  :                            21 rapointer $res	4
  :                            22 
  :                            23 $(1:131072,pc/$azlit)
  :                            24 
  :                            25 fp_routine
01:00000000 4BF84000          +26 	lea		$a(one), a5
01:00000004 F22D54000000      +27 	$xqt_fp,$ieee64	one*1.75*+307*two/3.0*-307-three
01:0000000A F23A54230064      +27 
01:00000010 F22D54230008      +27 
01:00000016 F23A54200060      +27 
01:0000001C F22D54280010      +27 
  :                            28 
01:00000022 F21B5400          +29 	$xqt_fp		d5+fp6+a2@+"-(a4)"+"a3@+"*(*rapointer)/rastore
01:00000026 20784408          +29 
01:0000002A F2105423          +29 
01:0000002E 41F84400          +29 
01:00000032 F2105420          +29 
01:00000036 F2055422          +29 
01:0000003A F2001822          +29 
01:0000003E F2125422          +29 
01:00000042 F2245422          +29 
  :                            30 
01:00000046 F22D5000001A      +31 	$xqt_fp		westward w+ho w*(*rapointer s)
01:0000004C 20784408          +31 
01:00000050 F2104423          +31 
01:00000054 F22D50220018      +31 
01:0000005A F23A54000024      +32 	$xqt_fp,$ieee64	(westward w)+(1.5 s)*(*rapointer s)
01:00000060 20784408          +32 
01:00000064 F2104423          +32 
01:00000068 F22D50220018      +32 
01:0000006E 4E75              +33 	rts
*EOF*
01:00000070+7FB8EBBB5516E5AD
01:00000078+004AF72442612915
01:00000080+3FC00000
:$(01):00020000:00020084 :$(04):00004000:0000401C :$(05):00004400:0000440C 


</pre>

The third algorithm at line 31 has ColdFire syntax flags indicating that the inputs
are respectively ColdFire word (16-bit integer) and and single (32-bit float).<br>ColdFire
floating instructions are 64-bit and carry out conversions on operand acquisition.

<p>
masmx expression syntax allows attribute text to follow a token before the next operator.
The token name or value is scanned until space or comma

<p>
Macro language has been written to recognise a pointer by unary *

<p>
To avoid confusion with multiply operator, the pointer reference is shielded in parentheses

<p>
The fourth algorithm at line 32 has any tokens with attribute [ b w l s d ] in parentheses,
because this may be easier to read

<p>
<b>xqt_fp</b> has already placed all constants in the expression within parentheses.
Some target definitions use these parenthesised arguments directly as automatic literals,<br>
but this is not appropriate for ColdFire, because accepted assembly syntax has many
operands which are not literals in parentheses. Automatic literals are not opted for<br>
ColdFire, but <b>xqt_fp</b> prepends a literal pool tag or a function macro name from
its subfunction field to constants

<p>
A function name $ieee64 is prepended to constants on lines 27 and 32. ColdFire floating<br>
instructions have neither immediate operands, nor operands in directly addressed storage

<p>
Floating operands in memory are possible at an address offset from a0..a7
or from the program counter at (instruction + 2)

<p>
Two 64-bit ieee754 floating numbers can be seen at address (fp_routine + 0x0070).
They are the constants 1.75*+307 and 3.0*-307 in the algorithm at line 27,<br>
where they are referenced aa (instruction @ 0x000A + 2 + 0x0064) and
(instruction @ 0x0016 + 2 + 0x0060)

<p>
A 32-bit ieee754 floating number can be seen at address (fp_routine + 0x0080).
That is the constant 1.5 in the algorithm at line 32,<br>where it is referenced as
(instruction @ 0x005A + 2 + 0x0024)

<p>
ColdFire integer/floating conversions carried out within the floating instruction
are clearly there to be used and much faster than any conversion routines in software

<p>
masmx and <b>$xqt_fp</b> support all architectures. The inclusion of conversion
routine calls in floating algorithms is supported in the same way as the indicative
flags like [ b w l s d ] 

<p>
It is not easy to have an integer longer that 32 bits on ColdFire, and even harder
to convert it to ieee754 64-bit. This may be one reason why ColdFire<br>can add 8-bit
integers to 64-bit floating numbers. The ASCII string can be converted to floating
without an interim conversion to long long integer.<br>That does not of course have
a direct hardware assist, but masmx can insert a conversion subroutine call into the stream
of algorithm imstructions
<pre>

$ masmx -lnky r3xample.msm
MASMX 7r3
3/r3xample.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	express.def
  :                            4: 	$include	fpxpress.def
  :                            5 	$path
  :                            6: 	$include	espresso.def
  :                            7: 	$include	ieee754.def
  :                            8 
  :                            9 $(4:16384,a5/$literal)
  :                            10 
  :                            11 one	$res	8
  :                            12 two	$res	8
  :                            13 three	$res	8
  :                            14 
  :                            15 westward $res	2
  :                            16 ho	$res	2
  :                            17 
  :                            18 $(5:16384+1024)
  :                            19 rastore	$res	8
  :                            20 rapointer $res	4
  :                            21 
  :                            22 $(1:131072,pc/$azlit)
01:00000000 3A7C4000          +23 	movea.w	#$a(one), a5
  :                            24 
01:00000004 F22D54000010      +25 	$xqt_fp	one-two+three*(*rapointer floating_string)
01:0000000A 20784408          +25 
[+0000]20
01:0000000E 4EB900000000      +25 
01:00000014 F2000423          +25 
01:00000018 F22D54220000      +25 
01:0000001E F22D54280008      +25 
  :                            26 
*EOF*
:$(01):00020000:00020024 :$(04):00004000:0000401C :$(05):00004400:0000440C 


</pre>
A string pointer is associated with a macro floating_string, which will call a
subroutine conversion and presents the resulting 64-bit floating value to the
algorithm instruction stream. This is how most conversions are carried out on
architectures with fewer hardware assists than ColdFire

<p>
The external subroutine call is seen at location 0x000E of the instruction stream
and has this appearance in text-encoded binary output
<pre>

$01:00020000
3A7C4000 F22D54000010 20784408 [0000]20:4EB900000000 F2000423
F22D54220000 F22D54280008
-s2double:[0000]
:$01*00000000:00020000:00020024
:$04*00000000:00004000:0000401C
:$05*00000000:00004400:0000440C

</pre>
The fourth instruction calls external routine s2double. A link
request tuple awaits its address for addition to the instruction
address field bits 31..0

<p>
<b>$xqt_fp</b> and ColdFire-specific macro code organise the call with these
two macros

<pre>

IEEE754_64_ACQUIRE$ $equ 1111

p       $proc
FOP*    $name
"$TYPE" $set    $t(p(1, 1))
"$RING" $set    0
        $do     p()>1,  $do     $t(p(2, 1))=$name,"$RING"       $set    p(2, 1)
        $if     $RING=IEEE754_64_ACQUIRE$
        p(2,1)  p(1)
"$FOP"* $equ,$fp_reg    fp1
        $elseif $t(p(1, 1))=$fp_reg
"$FOP"* $equ,$fp_reg    p(1, 1)
        $elseif $t(p(1, 1))=$d_reg
"$FOP"* $equ,$d_reg     p(1, 1)
        $elseif $t(p(1, 1))=$a_reg
        $flag   sending register may not be a0..a7
        $elseif ($t(p(1, 1))=$a_reg_@)++|
                ($t(p(1, 1))="$a_reg_@+")++|
                ($t(p(1, 1))="$a_reg_@-")
"$FOP"* $equ,$TYPE      p(1, 1)
        $elseif $t(p(1, 1))=127
        $if     p(1, *1)
        move    p(1, 1), a0
        $else
        lea     p(1, 1), a0
        $endif
"$FOP"* $equ,$a_reg_@   a0
        $elseif $inside\p(1, 1)=2
"$FOP"* $equf   $inside\p(1, 1), $base_a\p(1, 1)
        $elseif $itype\p(1, 1)="$a_reg"
"$FOP"* $equf   p(1, 1), $ibase\p(1, 1)
        $elseif $t(p(1, 1))=$equf
"$FOP"* $equf   p(1, 1), p(1, 2)
        $else
"$UP"*  $equf   p()
"$FOP"* $equf   $UP
        $do     $o('V'),        $trace  $FOP
        $do     $o('V'),        $trace  $FOP\2
        $endif
        $end

p       $proc
floating_string* $name  IEEE754_64_ACQUIRE$
        $do     $o('V'),        $note   call s2double
        $if     p(1, *1)
        movea   p(1, 1), a0
        $else
        lea     p(1, 1), a0
        $endif
        jsr     (s2double).l
        $end

</pre>

The first part of the first macro examines

	<blockquote>
	is the attribute label a $name as macros export them?<br><br>

	is the latent value of that name a ring number arbitrarily designated for subroutine conversions?<br><br>

	if so, assemble the macro and expect the 64-bit floating value to return in floating register fp1
	</blockquote>

The macro floating_string places the string pointer in a0 and calls s2double

<p>
s2double is shown among examples of masmx macro-language for ColdFire instruction code at
Appendix <a href="#coldfire">F.3.1: ColdFire</a>


<p>
masmx decides whether a token is a self-evident value or a storage reference
by these rules

	<blockquote>
	a field of digits is a value<br><br>
	a label on a line describing storage is a location<br><br>
	a label equated or set to digits is a value<br><br>
	a label equated or set to a storage label or to a location counter is a location<br><br>
	a label equated or set to another label is what that label is<br><br>
	a <b>$equf</b> label is a location<br><br>
	a label with a category 128..255 assigned by the developer is a location, typically a register
	</blockquote>

Therefore a construction
<pre>

bucket	$equ	4096

</pre>
would not cause a storage reference, but an immediate value.

<p>
The construction
<pre>

bucket	$equf	4096

</pre>
would cause a storage reference

<p>
In this assembly <b>FACTOR</b> has been generated as a constant (visible at
the foot of the program) because <b>$equ</b> connected <b>FACTOR</b> to a
number value and not a stored location
<pre>

$ ~/masmx mammoth -lnk
MASMX 7r3
3/mammoth.msm
*EOF*
  :                            1 	$path		../
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/stack.def
  :                            4: 	$include	language/fpxpress.def
  :                            5 $(0)
00:000000 B60040              +6 mammoth* $vector	sum
  :                            7 $(3:03000)
03:003000 40000F800000000000000000
                              +8 left	16384*+0
03:003004 7CD38AFBEEFAC15E58C049D8
                              +9 right	1.2*+1200000
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 FACTOR	$equ	1.875
  :                            14 
                                sum	$head_far	 params(first,	float	;
  :                            16 				second,	float	)
  :                            17 
00:000040 4FF007              +18 	$xqt_fp		-left-right+first+second*FACTOR
00:000041 770100              +18 
00:000042 6F3000              +18 
00:000043 6F3004              +18 
00:000044 67F003              +18 
00:000045 3D0000              +19 	$ret
  :                            20 	$do	$<256,$(0:256)
  :                            21 
*EOF*
00:000100+400001F00000000000000000
:$(00):000000:000104 :$(03):003000:003008 


</pre>


<a      name="sections"/>
<h1>7: Constructing Program Sections</h1>

<a      name="abslocs"/>
<h2>7.1: Absolute Location Counters</h2>
<a      name="sabslocs"/>
<h3>7.1.1: Simple Absolute Location Counters</h3>

The plainest use of location counter controls has the syntax
<pre>

$(counter_id:value)

</pre>
at the start of the assembly, and later
<pre>

$(counter_id)

</pre>
to switch between the program sections

<p>
If for example location counter zero has been chosen for code,
and location counter one for data:
<pre>

$(0:code_start_address)

	some code

$(1:data_start_address)

	some data

$(0)

	some more code

$(1)

	some more data

</pre>

Sections can be identified by name

<pre>

text	$equ	1
data	$equ	3

$(text:START_OF_TEXT)
$(data:START_OF_DATA)
.	end of header information

.	start of application information
$(data)
.	data declarations

$(text)
.	instructions

$(data)
.	more data

$(text)
.	more instructions

</pre>

A construct
<pre>

$(0:0)

</pre>
means switch to location counter 0 and initialise it 
to absolute unrelocatable 0. This the default environment
at the start of main assembly

<p>
Sections can be named to match assembly language output from compilers
<pre>

CODE    $equ    0
STATIC  $equ    1
$(CODE:0/STRING_LITERALS)
$(STATIC:32768)
$(STATIC)
buffer...
$(CODE)
Start   load... ,STRING_LITERALS("Text...
	call..
	store  ...,buffer...
$(STATIC)
another_variable..
$(CODE)
	load_address ..,another_variable


</pre>
The possible fields in a location counter control
are for absolutely addressed segments:
<pre>

$(id:address:breakpoint,base_register/literal_pool_tag)

</pre>
or
<pre>

$(id:address:*breakpoint,base_register/literal_pool_tag)

</pre>
All fields except id (0..71) may be absent.

<p>
If addresses are absent
<pre>

$(id[,base_register][/literal_pool_tag])

</pre>
then addressing in this segment picks up where it last reached.

<p>
If base register is specified, labels of locations in this
section have base+displacement tuple values.<br>
See <a href="#bdflat">7.1.3: Simple Base Displacement</a>,
<a href="#bdbreakpt">7.1.4</a>, <a href="#bdgiant">7.1.6.2</a>
<a href="#voidsection">7.1.5: Void Sections</a>,

<p>
See also <a href="#lptag">7.1.7: Literal Pool Tag</a>


<a      name="breakpoint"/>
<h3>7.1.2: Breakpointed Location Counters</h3>

Breakpointed location counters concern targets with hardware relocation.<br>
A physical or translated relocation value for a block of program space
is known at assembly time
<p>
<i>breakpoint value</i> in the location counter switch identifies
a load space
<pre>

$(id:logical_base_address:<i>breakpoint value</i>)

</pre>

Code only accesses program-absolute addresses. <i>breakpoint value</i> is
not code-visible but can be retrieved to construct vector information

<a      name="abreakpt"/>
<h4>7.1.2.1: Physical Address Offset</h4>

In this example of direct physical relocation, code points at program-absolute
addresses starting at zero and at 16384. Load strings are at 8192, 12288 and 65536.<br>
Those memory blocks must be hardware-selected at runtime in address windows
zero and 16K
<pre>

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
	$word	16
	$quantum 8      
	$awidth	32

PAGE2   $equ    8192
PAGE3	$equ	12288
PAGE16	$equ	65536

$(0::PAGE2)
	+	location(1)l

$(0::PAGE3)
	+	location(2)l

$(5:16384:PAGE16)
?	$do	2,location(?)	+	?*100
	$end
  :                            1  $word 16
  :                            2  $quantum 8      
  :                            3  $awidth 32
  :                            4 
  :                            5 PAGE2   $equ    8192
  :                            6 PAGE3 $equ 12288
  :                            7 PAGE16 $equ 65536
  :                            8 
  :                            9 $(0::PAGE2)
00:00000000 00004000          +10  + location(1)l
  :                            11 
  :                            12 $(0::PAGE3)
00:00000000 00004002          +13  + location(2)l
  :                            14 
  :                            15 $(5:16384:PAGE16)
05:00004000 0064              +16 ? $do 2,location(?) + ?*100
05:00004002 00C8              +16 
  :                            17  $end
PAGE2=2000
PAGE3=3000
PAGE16=00010000
?=0002
location(1)=$05:4000
location(2)=$05:4002
-INPUT>>=0<00000000
:$(00):00000000:00000004 :$(05):00004000:00004004 
-INPUT>>: object code 131 bytes: 0 errors: 0 undefined labels

$ cat temp.txo

$00:00002000
00004000
$00:00003000
00004002
$05:00010000
0064 00C8
:$00*00000000:00000000:00000004
:$05*00000000:00004000:00004004

</pre>

<p>
Physical PAGE2 and PAGE3 are both in address window zero, but not both at once

<p>
On simple hardware without MMU, memory blocks are sometimes mapped
to windows of address space by I/O operations.

<p>
Flags -dl list load addresses instead of program-absolute addresses

<p>
masmx internal function <a href="#bix">$bank_index</a> retrieves the
breakpoint value in order to construct vector information
<a href="#ifunction">(4.2.2.3 masmx Internal Functions)</a>

<a      name="vbreakpt"/>
<h4>7.1.2.2: Breakpointed Location Counters: -v Option</h4>

With -v option, the <i>breakpoint value</i> value in
$(id:logical_start_address:<i>breakpoint value</i>)
is not assumed to be an address and is not added to the load addresses

<p>
Instead, the value is prefixed before the load string offset addresses in the
text-encoded binary output

<p>
The breakpoint value may be a memory granule or paragraph address,
a page identifier or a virtual translation index.<br>
By prefixing it instead of adding it, masmx -v assigns the breakpoint value to
separate interpretation. -dv options list breakpoint values
<pre>


$ masmx -lnkxdv
MASMX 7r3
0/-INPUT>>
	$word	16
	$quantum 8      
	$awidth	32:64

PAGE2   $equ    8192
PAGE3	$equ	12288
PAGE16	$equ	65536

$(0::PAGE2)
	+	location(1)l

$(0::PAGE3)
	+	location(2)l

$(5:16384:PAGE16)
?	$do	2,location(?)	+	?*100
	$end
  :                            1  $word 16
  :                            2  $quantum 8      
  :                            3  $awidth 32:64
  :                            4 
  :                            5 PAGE2   $equ    8192
  :                            6 PAGE3 $equ 12288
  :                            7 PAGE16 $equ 65536
  :                            8 
  :                            9 $(0::PAGE2)
00:00002000:00000000 00004000 +10  + location(1)l
  :                            11 
  :                            12 $(0::PAGE3)
00:00003000:00000000 00004002 +13  + location(2)l
  :                            14 
  :                            15 $(5:16384:PAGE16)
05:00010000:00000000 0064     +16 ? $do 2,location(?) + ?*100
05:00010000:00000002 00C8     +16 
  :                            17  $end
PAGE2=2000
PAGE3=3000
PAGE16=00010000
?=0002
location(1)=$05:4000
location(2)=$05:4002
-INPUT>>=0<00000000
:$(00):00000000:00000004 :$(05):00004000:00004004 
-INPUT>>: object code 158 bytes: 0 errors: 0 undefined labels

$ cat temp.txo

$00:00002000:00000000
00004000
$00:00003000:00000000
00004002
$05:00010000:00000000
0064 00C8
:$00*00000000:00000000:00000004
:$05*00000000:00004000:00004004

</pre>


<a      name="bdflat"/>
<h3>7.1.3: Simple Location Counter without Breakpoint:
	 Base+Displacement in Flat Address Spaces</h3>

If a section is at a high address, and part of the section is beyond
the direct address range of the instruction set,<br>
the section may relate to a base register which is loaded with
the section start address at run-time.

<p>
Identifier labels in the section are base+displacement tuples.
Displacements start at zero, not at the section start address.
Load string addresses start at the section start address
<pre>

$(35:<i>big_address_where_it_loads</i>,r15)

</pre>
<i>big_address_where_it_loads</i> must be placed in r15 at run-time.

<p>
The following assembled base-displacement example shows: 

<p>
Line 4 declares a segment which will be accessed 
using R15 as a cover or base register.

<p>
Lines 12..13 place the section start address in r15 at runtime

<p>
Lines 14..16 retrieve operands which r15 covers.
Identifiers in section $(48) are base-displacement. r15 is referenced automatically

<p>
Function <b>.absolute</b> at lines 9, 12, 13 is an equate of masmx internal function
<a href="#absolute">$a</a>,<br>
which retrieves the absolute value of a base-displacement identifier 

<pre>

$ masmx qplain -lnkyd
MASMX 7r3
3/qplain.msm
LTERM=#
CONT_CHAR=\
STERM=.
  :                            1:         $include        "../aside.dem/ppc_603.def"
  :                            2 
  :                            3 SEGMENT .equ    511*1024
  :                            4 $(48:SEGMENT,r15)
30:0007FC00 0000000000400000  +5 part1   +       2048*2048d
30:0007FC08 0000000000000064  +6 part2   +       100d
  :                            7 part3   $res    2048*2048-16
  :                            8 
30:0047FC00 0007FC10          +9 	+	.absolute(part3)
  :                            10 
  :                            11 $(0:3*65536)
00:00030000 640F0008          +12 start   oris    r15,, .absolute(part1)@ha     
00:00030004 39E0FC00          +13         addi    r15, .absolute(part1)@l 
00:00030008 806F0000          +14         lwz     r3, part1
00:0003000C 808F0008          +15         lwz     r4, part2
00:00030010 80AF0010          +16         lwz     r5, part3
00:00030014 4E800020          +17         blr
  :                            18         $end    start
:$(00):00030000:00030018 :$(30):0007FC00:0047FC04 

</pre>

<a      name="bdbreakpt"/>
<h3>7.1.4: Breakpointed Location Counters:
             Base+Displacement in Translated Address Spaces</h3>

Base-displacement operates identically with or without a load address breakpoint

<p>
The following example has a base+displacement section at a high
program-absolute address which will be loaded at a different high physical<br>
address known at assembly time. The physical load addresses do not affect
base-displacement operation, which only concerns program-absolute addresses

<p>
The breakpoint address does not change code's view of storage

<p>
The physical address HARDWARE_LOADA is not visible to target code but is
used in load strings.

<p>
Multi-bank images for relocating hardware can be generated in this way.

<p>
The displacements used in operand reference do not reflect either
HARDWARE_LOADA or SEGMENT, but SEGMENT is in r15

<p>
Function <b>.absolute</b> at lines 11, 14, 15 is an equate of masmx internal function
<a href="#absolute">$a</a>,<br>
which retrieves the program-absolute value of a base-displacement identifier.<br>
The breakpoint address HARDWARE_LOADA is not part of program-absolute addresses


<p>
The assembly is run with -d Flag to show absolute load addresses.
<pre>

$ masmx rplain -lnkyd
MASMX 7r3
3/rplain.msm
LTERM=#
CONT_CHAR=\
STERM=.
  :                            1:         $include        "../aside.dem/ppc_603.def"
  :                            2 
  :                            3 SEGMENT .equ    511*1024
  :                            4 HARDWARE_LOADA .equ	511*32768
  :                            5 
  :                            6 $(48:SEGMENT:HARDWARE_LOADA,r15)
30:00FF8000 0000000000400000  +7 part1   +       2048*2048d
30:00FF8008 0000000000000064  +8 part2   +       100d
  :                            9 part3   $res    2048*2048-16
  :                            10 
30:013F8000 0007FC10          +11 	+	.absolute(part3)
  :                            12 
  :                            13 $(0:3*65536)
00:00030000 640F0008          +14 start   oris    r15,, .absolute(part1)@ha     
00:00030004 39E0FC00          +15         addi    r15, .absolute(part1)@l 
00:00030008 806F0000          +16         lwz     r3, part1
00:0003000C 808F0008          +17         lwz     r4, part2
00:00030010 80AF0010          +18         lwz     r5, part3
00:00030014 4E800020          +19         blr
  :                            20         $end    start
:$(00):00030000:00030018 :$(30):0007FC00:0047FC04 


</pre>


<a      name="voidsection"/>
<h3>7.1.5: Void Sections</h3>

A void section has zero base address, no breakpoint address, is not
relocatable and has a base register

<p>
Data is described in a void section but not generated. It reserves
no storage but is a map of storage. Labels in a void section map
to displacements on the base register

<p>
It is an advantage to type two colons :: in a void section control,
specifying a blank start address and a zero breakpoint address

<pre>

$(id::,rX)

</pre>
<p>
One location counter can be used for many different void segments if a
zero breakpoint value is specified
<pre>

$(66::,rX)
name1	descriptor_type_A

$(66::,rY)
name2	descriptor_type_B

</pre>
Void section addresses two cases, where 

	<blockquote>
	The data is supplied by a calling
	routine which hands "this" routine
	a parameter address in a register<br><br>

	The data is generated in a large
	array and based a part at a time 
	with a register
	</blockquote>

It is safe to place data-generating macros in the void section. 
They will not generate data. This allows the same macros to construct
data and to map instances of it into a void section for attention.
	
<p>
Macro "tree" in this example is called both in section $(55) ARRAY
where it does generate data, and section $(56) VSEGMENT, where it doesn't.
<pre>

MASMX 7r2
3/pusingv.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1:         $include        "ppc1.def"
  :                            2         $set_option     "u"
  :                            3         $plist  8
  :                            4         
  :                            5 record* $proc        
  :                            6 *       $tree
  :                            7 h       +       record(1,1)
  :                            8 t       $res    record(1,1)
  :                            9         $root
  :                            10         .align  2
  :                            11         $end
  :                            12         
  :                            13 tree*   $proc
  :                            14 *       $tree
  :                            15 times   $do     3,dibber(times) record    tree(1,1)
  :                            16         $root
  :                            17         $end
  :                            18 
  :                            19 
  :                            20 ARRAY   $equ    262144*24
  :                            21 GRANULE $equ    22//4*4*2*3//8*8
  :                            22 
  :                            23 grains*       $proc
  :                            24       $do     index=2,        $list   0
  :                            25 $(55:ARRAY+index*GRANULE-GRANULE)
  :                            26 cluster(index)* $tree
  :                            27 times   $do     2,raddle(times)  tree 18
  :                            28         $root
  :                            29       $do     index=20000/GRANULE-1,  $list  1
  :                            30         $end
  :                            31 
37:00600000 00000012          +32 index $do     20000/GRANULE,  grains
37:00600018 00000012          +32 
37:00600030 00000012          +32 
37:00600048 00000012          +32 
37:00600060 00000012          +32 
37:00600078 00000012          +32 
37:00604D10 00000012          +32 
37:00604D28 00000012          +32 
37:00604D40 00000012          +32 
37:00604D58 00000012          +32 
37:00604D70 00000012          +32 
37:00604D88 00000012          +32 
  :                            33 
  :                            34 VSEGMENT $equ    0
  :                            35 
  :                            36 $(56:VSEGMENT,r12)
  :                            37 .this_segment $equ $(55)
38:00000000                   +38 times   $do     2,raddle(times) tree    18
38:00000018                   +38 
38:00000030                   +38 
38:00000048                   +38 
38:00000060                   +38 
38:00000078                   +38 
38:00000090                   +39 raddle2 tree    30
38:000000B4                   +39 
38:000000D8                   +39 
  :                            40 $(0:32768/.lit)
00:00008000 640C0060          +41         oris    r12,0,hi16(cluster(40).raddle(1))
00:00008004 618C15F0          +42         ori     r12,r12,lo16(cluster(40).raddle(1))
00:00008008 806C0018          +43         lwz     r3,raddle(1).dibber(2)
00:0000800C 808C0000          +44         lwz     r4,raddle(1).dibber(1)
00:00008010 80AC0078          +45         lwz     r5,raddle(2).dibber(3)
00:00008014 80CC0048          +46         lwz     r6,raddle(2)
00:00008018 80EC0090          +47         lwz     r7,raddle2
00:0000801C 616C0000          +48         mr      r11,r12
00:00008020 90EB0090          +49         stw     r7,raddle2(r11)
00:00008024 A0EB0078          +50         lhz 	r7,raddle(2).dibber(3)(r11)
00:00008028 8180802C          +51       lwz r12,.lit(cluster(20).raddle(2))
*EOF*
00:0000802c+00600AF8
:$(00):00008000:00008030 :$(37):00600000:00604DA0 :$(38):00000000:000000FC 
pusingv.msm: object code 18447 bytes: 0 errors: 0 undefined labels

</pre>
<a      name="giantspace"/>
<h3>7.1.6: Breakpointed Location Counters: Giant Address Spaces</h3>

<a      name="giantdirect"/>
<h4>7.1.6.1: Very Large Direct Addressed Segments</h4>

If breakpoint is prefixed with an asterisk, it is a
<i>*giant_breakpoint</i> 
<pre>

$(id:<i>base</i>:*<i>giant_breakpoint</i>[,base_register][/literal_pool_tag])

</pre>
<p>
<i>giant_breakpoint</i> is an address expression up to 192 bits wide. Giant breakpoints
are steps in a large linear absolute address space and are a component of the program-visible 
address reported in labels and in $ location counters

<p>
displacements within the breakpointed part may only reach four gigaquanta beyond <i>base</i>,
but the section may have billions of breakpointed parts at locations up to
0FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF (4 tera-peta-peta-petaquanta
or 4 giga-yotta-yottaquanta)

<p>
Linear addresses in the breakpointed part start at <i>base</i> plus <i>giant_breakpoint</i>

<p>
The size of the giant part of the address
is the second part of the $awidth declaration, in the example of PowerPC
<pre>

        <a href="#awidth">$awidth</a>   32:64

</pre>
The first part of the $awidth value may
not be more than 32. An address may not be higher than *breakpoint+0FFFFFFFF

<p>
Locations running from <i>base</i> may not reach more
than 4 gigaquanta without being stepped. <i>base</i> may be zero
<pre>

$(id:<i>base</i>:*giant_breakpoint)
$(id::*giant_breakpoint)

</pre>
The default value of the giant part of $awidth is 48 and the limit is 192.

<p>
Memory is referenced and labelled are in one linear space. Each breakpoint part may start at the
exact giant address reached in the previous part.<br>This example is a linking assembly which
catenates four relocatables each containing space of three gigabytes

<p>
<a href="#option_d">Option -d</a> adds the giant step component to address summary information

<pre>

$ masmx globules -lnkydx
MASMX 7r3
3/globules.msm
../result.txo/globule1.txo:$(25) 3221225476 bytes decimal from hexadecimal 00000000 to C0000004 +000FC00A80000028
../result.txo/globule2.txo:$(25) 3221225476 bytes decimal from hexadecimal 00000000 to C0000004 +000FC00B4000002C
../result.txo/globule3.txo:$(25) 3221225476 bytes decimal from hexadecimal 00000000 to C0000004 +000FC00C00000030
../result.txo/globule3.txo:$(27) 8 bytes decimal from hexadecimal 00000000 to 00000008 +000FC010000B0000
../result.txo/globule4.txo:$(25) 3221225476 bytes decimal from hexadecimal 00000000 to C0000004 +000FC00CC0000034
*EOF*
  :                            1: 	$include	../aside.dem/ppc64map.def
  :                            2 
  :                            3 $(27::*000FC010000B0000)
  :                            4 $(25::*000FC00A80000000)
19:000FC00A80000000:000FC00A80000028
                              +5 	+	globule1:d
19:000FC00A80000008:000FC00B40000030
                              +6 	+	globule2:d
19:000FC00A80000010:000FC00C00000030
                              +7 	+	globule3:d
19:000FC00A80000018:000FC00CC0000038
                              +8 	+	globule4:d
19:000FC00A80000020:000FC00D80000038
                              +9 	+	tally:d
  :                            10 	$list	2
  :                            11 $(25::*$)
  :                            12: 	$include,$binary	../result.txo/globule1
19:000FC00B40000028:0000005A  +4 0000005A
  :                            13 $(25::*$)
  :                            14: 	$include,$binary	../result.txo/globule2
19:000FC00B4000002C:0000005B  +4 0000005B
  :                            15 $(25::*$)
  :                            16: 	$include,$binary	../result.txo/globule3
19:000FC00CC0000030:0000005C  +4 0000005C
1B:000FC010000B0000:6162636465662020
                              +7 6162636465662020
  :                            17 $(25::*$)
  :                            18: 	$include,$binary	../result.txo/globule4
19:000FC00CC0000034:0000005D  +4 0000005D
  :                            19 $(25::*$)
19:000FC00D80000038:00000063  +20 tally	+	99
  :                            21 rally	$equ	$
*EOF*
$map=:N129:P:0:00000000
drastique+=$1B:000FC010000B0000
globule1+=$19:000FC00A80000028
globule2+=$19:000FC00B40000030
globule3+=$19:000FC00C00000030
globule4+=$19:000FC00CC0000038
rally=$19:000FC00D8000003C
tally=$19:000FC00D80000038
trip1+=$19:000FC00B40000028
trip2+=$19:000FC00B4000002C
trip3+=$19:000FC00CC0000030
trip4+=$19:000FC00CC0000034
../result.txo/globule4.txo=1<00000005
../result.txo/globule3.txo=1<00000005
../result.txo/globule2.txo=1<00000005
../result.txo/globule1.txo=1<00000005
../aside.dem/ppc64map.def=1<00000005
globules.msm=0<00000003

@:000FC00D80000038:$(19):00000000:00000004 
@:000FC010000B0000:$(1B):00000000:00000008 

</pre>
Another example shows 128-bit addressing, covering potentially
256 exa-exaquanta
<pre>

	$word	32
	$quantum 8
	$byte	8
	$awidth	32:128

ARRAY		$equ	5*/96
ELEMENT_SIZE	$equ	1024*1024*1024
HOW_MANY	$equ	112000

element* $proc
*	+	subscript
	$res	ELEMENT_SIZE-4
	$end
	
newpart* $proc
$(45::*ARRAY+ELEMENT_SIZE*subscript-ELEMENT_SIZE)
	$do	subscript=4,		$list	0
part(subscript)*	element
	$do	subscript=HOW_MANY-3,	$list	1
	$end

subscript	$do	HOW_MANY,	newpart

2D:00000005000000000000000000000000:00000001      +23
2D:00000005000000000000000040000000:00000002      +23 
2D:00000005000000000000000080000000:00000003      +23 
2D:000000050000000000006D5F40000000:0001B57E      +23 
2D:000000050000000000006D5F80000000:0001B57F      +23 
2D:000000050000000000006D5FC0000000:0001B580      +23 
*EOF*
:$(2d):00000000:40000000 
Object Code 5264032 Bytes: 0 Errors: 0 Undefined Labels

</pre>
In the above example, location counter 45 starts at an address of
5*/96 (five times 65536 tera tera bytes) and is stepped 112000 times
by one gigabyte.

<p>
The giant breakpoint value is not catenated but added to the location
counter rightmost bit to rightmost bit to obtain absolute addresses
<pre>

                                                   _______________
	running location counter:                  |_____________|
                                                          +
                   _______________________________________________
	step value:|_____________________________________________|


</pre>
The address values in location labels and in load strings are
the sum of the location counter plus step or giant breakpoint value.

<p>
See also <a href="#file_formats">9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools</a>


<a      name="bdgiant"/>
<h4>7.1.6.2: Very Large Load Address Base-Displacement Examples</h4>

A giant address breakpoint concerns absolute direct addressing. Program-visible addresses<br>
start at <i>base</i> plus <i>*giant_breakpoint</i> and a base register contains this sum at runtime
<pre>

$(id:<i>base</i>:<i>giant_breakpoint</i>,base_register[/literal_pool_tag])

</pre>

<a      name="staticbdg"/>
<h4>7.1.6.2.1: Giant Absolute Address Base-Displacement Static Reference Example</h4>

	<blockquote>
        <b>
	Giant Absolute Address Base-Displacement Example<br>
	With Static Base-Displacement Referencing
	</b>
	</blockquote>

This example is called static because the base-displacement view
does not move. It is mapped to the start of the code section

<p>
Base register r15 is first loaded to point to the array start

<pre>

MASMX 7r2
3/modest.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1:         $include        "ppc_64.def"
  :                            2 
  :                            3 SEGMENT $set    0x00FFFC0000000000
  :                            4 $(48::*SEGMENT,r15)
30:00FFFC0000000000:0000000000400000
                              +5 part1   +       2048*2048d
30:00FFFC0000000008:0000000000000064
                              +6 part2   +       100d
  :                            7 part3   $res    2048*2048-16
  :                            8 
  :                            9 $(0:3*65536)
00:00030000 4800000D          +10 start   bl      loaded      
00:00030004 00FFFC0000000000  +11         +       SEGMENT
00:0003000C 7DE802A6          +12 loaded  mfspr   r15, LR
00:00030010 E9EF0000          +13         ld      r15,,r15
00:00030014 E86F0000          +14         ld      r3, part1
00:00030018 E88F0008          +15         ld      r4, part2
00:0003001C E8AF0010          +16         ld      r5, part3
*EOF*
:$(00):00030000:00030020 :$(30):00000000:00400000 
modest.msm: object code 217 bytes: 0 errors: 0 undefined labels

</pre>
<a      name="dynamicbdg"/>
<h4>7.1.6.2.1: Giant Absolute Address Base-Displacement Dynamic Reference Example</h4>


	<blockquote>
        <b>
	Giant Absolute Address Data Example<br>
	with Dynamic Base-Displacement Reference
	</b>
	</blockquote>

The base-displacement view and the code-generating section are declared
separately in the following example

<p>
The base-displacement view <b>$(49)</b> is called dynamic because it may
be mapped to to different array locations at different moments.<br>
It is a void section with base register but no address, breakpoint address
or relocation rule. See <a href="#voidsection">7.1.5: Void Sections</a>


<pre>

MASMX 7r2
3/qbig.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1:         $include        "ppc_64.def"
  :                            2 
  :                            3 ARRAY   $equ    0x00FFFC0000000000
  :                            4 GRANULE $equ    2048*2048
  :                            5 
  :                            6 proces*	$proc
  :                            7 $(48::*ARRAY+GRANULE*x-GRANULE)
  :                            8         $do     x=3,    $list 0
  :                            9         $do     x=4094, $list 1
  :                            10 item(x)* +       x*2048*2048+ARRAY
  :                            11         $end
  :                            12 
30:00FFFC0000000000:00FFFC0000400000
                              +13 x	$do	4096,	proces
30:00FFFC0000400000:00FFFC0000800000
                              +13 
30:00FFFC03FF400000:00FFFC03FF800000
                              +13 
30:00FFFC03FF800000:00FFFC03FFC00000
                              +13 
30:00FFFC03FFC00000:00FFFC0400000000
                              +13 
  :                            14 
  :                            15 $(49::,r15)
  :                            16 h       $res    8
  :                            17 t       $res    2048*2048-8
  :                            18 
  :                            19 $(0:3*65536)
00:00030000 4800000D          +20 start   bl      loaded      
00:00030004 00FFFC017FC00000  +21         +       item(1536)
00:0003000C 7DE802A6          +22 loaded  mflr	  r15
00:00030010 E9EF0000          +23         ld	  r15,,r15
00:00030014 E86F0000          +24         ld      r3, h
00:00030018 E88F0008          +25         ld      r4, t
*EOF*
:$(00):00030000:0003001C :$(30):00000000:00000008 :$(31):00000000:00400000 
qbig.msm: object code 213163 bytes: 0 errors: 0 undefined labels

</pre>


<a      name="lptag"/>
<h3>7.1.7: Literal Pool Tag</h3>

Literals may be generated in any sort of section where code is
allowed. The only other sort of segment is a void section,<br>
sometimes known as a dsect. That is a base-displacement section
with no addresses and no relocation rule.
<a href="#voidsection">7.1.5:Void Sections</a>

<p>
Where <i>/literal_pool_tag</i> appears in the location counter control
<pre>

$(id[:base][:breakpoint][,base_register]/<i>literal_pool_tag</i>)

</pre>
or
<pre>

$(id[:*relocation_alignment][,base_register]/<i>literal_pool_tag</i>)

</pre>
<i>literal_pool_tag</i> gives a handle to the literal pool in the counter.

<p>
Literals are assigned to a specific program section by reference to the tag
<pre>
 
	<i>literal_pool_tag</i>(LITERAL_VALUE)

</pre>
Without -a flag, literals can only be generated via literal-pool-tag. See
<a href="#literals">4.5: Literals</a>

<p>
Literals are produced at the end of the section or section breakpoint.

<p>
For example, in the definition header "8051.def":
<pre>

$(0:0/$literal)

</pre>
means start location counter zero at address zero, and 
gives the tag "$literal" to a literal pool at the end of 
the other code assembled in location counter zero. Tag 
"$literal" may then be referenced to assemble literals 
and return their address:
<pre>

	mov     dptr, #$literal("A Long String of Text")

</pre>
See also Sections 4.6: Function Macros and 4.5: Literals.
A forward slash signals the start of the literal pool
name. Therefore any expression which contains an operator 
/ // /// */ /* in the preceding expressions should be 
in parentheses. Or equated to a label in advance:
<pre>

OFFSET	$set	TOTAL_SIZE/GRANULE_LOGARITHM
$(.array::BASE+OFFSET/$literals_tag)

</pre>

<b>$lit</b> directive can also tag a literal pool. See section 8.28

<a      name="relocate"/>
<h2>7.2: Relocatable Location Counters</h2>

<pre>

$(<i>id:*alignment[:initial_offset][,base_reg][/literal_pool_tag]</i>)

</pre>
<i>id</i> is the number 0..71 of the location counter

<p>
<i>*alignment</i> identifies relocatable code. It gets rounded to the
containing power of 2. *alignment is recognised by leading asterisk.

<p>
<i>initial_offset</i> is optional. It declares an offset or unlabelled buffer
at the front of the segment. initial_offset is usually absent = zero.

<p>
<i>base_register</i> and <i>literal_pool_tag</i> are optional

<p>
The first section in the following assembly, $(33) at line 3
is relocatable and no base register is used to address it.
The text-encoded binary output has relocation information added to
references (line 16) in this segment.

<p>
Relocation tuples are printed just above the generated code
at the left of the listing when -ln flags are opted

<p>
The second section $(34) at line 6 in this example has a base register.
Instruction  reference to labels and literals in that section
are base+displacement

<p>
The code in the segment will be relocated and pointers to it
updated with relocation information (line 11), but base-displacement
references (lines 15, 17) are never relocatable

<pre>

$ masmx -lnk ragaline
MASMX 7r3
3/ragaline.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1: 	$include ../aside.dem/ppc_603.def
  :                            2: 	$include ieee754.def
  :                            3 $(33:*8)                                  
21:00000000 3FF8000000000000  +4 one	ieee754_64	1.5
21:00000008 3FFC000000000000  +5 two	ieee754_64	1.75
  :                            6 $(34:*8,30/.literals34)
22:00000000 BFC8000000000000  +7 first	ieee754_64	-1.5
22:00000008 BFC4000000000000  +8 second	ieee754_64	-1.75
  :                            9 $(.text:131072)
01:00020000 48000009          +10 	bl	load_base30
(+22)20
01:00020004 00000000          +11 	+	.absolute(first)
  :                            12 load_base30
01:00020008 7FC802A6          +13 	mflr	r30
01:0002000C 83DE0000          +14 	lwz	r30,,r30
01:00020010 C81E0008          +15 	lfd	0, second
(+21)10
01:00020014 C8400008          +16 	lfd	2, two
01:00020018 C89E0010          +17 	lfd	4, .literals34(ieee754_64 37.5e-115)
  :                            18 
*EOF*
22:00000010+2862783DA15ED470
:$(01):00020000:0002001C :$(21):00000000:00000010 :$(22):00000000:00000018 


</pre>

The final revising assembly or link may construct from relocatable segments
sections which are

	<blockquote>
	<a href="#sabslocs">7.1.1 simple absolute</a><br><br>
	<a href="#abreakpt">7.1.2.1 absolute with offset load address (breakpoint)</a><br><br>
	<a href="#vbreakpt">7.1.2.2 absolute with translating load address (virtual breakpoint)</a><br><br>
	<a href="#giantspace">7.1.6 giant (*breakpoint)</a>
	</blockquote>

<p>
The link may instead produce new relocatable sections


<p>
See also <a href="#file_formats">9: Output File Formats, Relocation and Linking,
    			Giant Address Spaces, Interfacing with GNU Tools</a>





<a      name="Directives"/>
<h1>8: masmx Directives:</h1>

<a	name="ascii"/>
<h2>8.1:  $ascii             Set Character Set to ASCII</h2>

<p>
$ascii switches string contents and values in apostrophes to source input
values unchanged

<p>
Directives $ascii and $data_code switch text strings between unchanged input
(ASCII / Roman-8 / Latin-1 / UTF8)<br>and tabled byte translation values stored by $data_code
for code points 0..255

<p>
Language elements outside of strings are composed from ASCII code points 0..126

<p>
Assembly initial setting is $ascii


<a      name="awidth"/>
<h2>8.2:  $awidth            Output File Load Address Width</h2>


<p>
$awidth governs the width of addresses placed in the output file
for inclusion in load strings. If it is a different value from
$word it must be submitted to the assembly later than $word. For
example, a suitable $word value for 8-bit microcontrollers is 8, but
a suitable $awidth is 16:
<pre>

	$word   8       . 8-bit microcontroller
	$awidth 16      . Load Strings have a 16-bit address

</pre>
<p>
A suitable $word for ColdFire is 16, but a suitable $awidth is 32
<pre>

	$word   16      ; Standard Size Generated Data Item is 16 bits
	$awidth 32      ; Load Strings have a 32-bit address 

</pre>
<p>
If giant address spaces are used, then the giant part of the address
is stated after the primary part.
<pre>

	$awidth 32:64

</pre>
<p>
The maximum size of the first or "net" part is 32 bits.

<p>
The maximum size of the second or giant-stepped part is 192 bits.

<p>
See <a href="#sections">7: Constructing Program Sections</a>

<p>
See <a href="#file_formats">9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools</a>


<a      name="blank"/>
<h2>8.3:  $blank		Set the Globality of a Future Label</h2>


<p>
$blank sets the globality of a label which is not yet declared,
for example
<pre>

entry_point*	$blank	0
	.
	.
entry_point
	la	r1, #initial_stack
	.
	.

</pre>


<a      name="branch"/>
<h2>8.4:  $branch		Structure Overlay</h2>

<p>
$branch is the start of a structure overlay. The following assembly
with label listing shows an  example of overlaid storage definition.<br>
See also <a href="#wstradata">5.2.2: Word-Aligned Structures $tree / $branch..$root</a>
<pre>

$ masmx welblech -lnkx
MASMX 7r3
3/welblech.msm
*EOF*
  :                            1 p	$proc
  :                            2 yooz*	$name
  :                            3 *	$tree
  :                            4 yo*	$branch
  :                            5 	+	7
  :                            6 	+	8
  :                            7 	+	9
  :                            8 	$root
  :                            9 ho*	$branch
  :                            10 	+	12
  :                            11 	$root
  :                            12 	$root
  :                            13 	$end
  :                            14 
  :                            15 $(6:06000)
  :                            16 well $tree
  :                            17 switch $res 1
  :                            18 blech $branch
06:006001 000001              +19 up + 1
06:006002 000007              +20 halfway yooz
06:006003 000008              +20 
06:006004 000009              +20 
06:006002 00000C              +20 
06:006005 000063              +21 down	+	99
  :                            22  $root
  :                            23 
  :                            24 fest	$branch
06:006001 000002              +25 left	+	2
06:006002 000007              +26 centre	yooz
06:006003 000008              +26 
06:006004 000009              +26 
06:006002 00000C              +26 
06:006005 000064              +27 right	+	100
  :                            28 	$root
  :                            29 	$root
  :                            30 
06:006006 006002              +31 	+	well:blech:halfway:ho
06:006007 006002              +32 	+	well:fest:centre:yo
06:006008 006005              +33 	+	well:blech:down
06:006009 006001              +34 	+	well:fest:left
*EOF*
yooz=:N129:P:0:000000
well=$06:006000
well:switch=$06:006000
well:blech=$06:006001
well:blech:up=$06:006001
well:blech:halfway=$06:006002
well:blech:halfway:yo=$06:006002
well:blech:halfway:ho=$06:006002
well:blech:down=$06:006005
well:fest=$06:006001
well:fest:left=$06:006001
well:fest:centre=$06:006002
well:fest:centre:yo=$06:006002
well:fest:centre:ho=$06:006002
well:fest:right=$06:006005
welblech.msm=0<000003
:$(06):006000:00600A 


</pre>

<a      name="byte"/>
<h2>8.5:  $byte              Set the Width of a Data Character</h2>


<p>
$byte is defaulted to 8, and is only likely to be anything different
if the target machine's address quantum is other than a byte, for
example a word of 30 or 48 or 60 bits. See directive <a href="#quantum">8.41: $quantum</a>,
<a href="#alignments">Appendix F.4: Byte-Addressing Machines with 32 and 64 Bit Bus: Managing 
Alignments</a>

<p>
$byte also applies with +'symbols' bounded by single quote in number
expressions. ASCII is read in source code, but the +'expression' token
has a value in the current character set and size.

<p>
See also <a href="#data_code">8.8: $data_code</a> directive.

<p>
Here is an example of an assembly for a 48-bit architecture generating
string constants first of 8-bit then 6-bit bytes.
<pre>

MASMX/-240 1r1X
big48.msm 5
*EOF*  :                        1:         $word   48
:                        2:         $quantum 48
00:00000000 496E697469616C20537472696E6773206F6620382D626974
		 +3         "Initial Strings of 8-bit data"
00:00000004 206461746120  +3 
:                        4:         $byte   6
00:00000005 B21D25C80CF4CA9BA7CC0BE6034A67A34B39030863AE5900
		 +5         "Later Strings of Tightly Packed Data"
00:00000009 921D21000000  +5 
*EOF*:$(00):0000000A 
Object Code 150 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Where the width of $byte is less than 7 and the character code is still
ASCII, the character values are compressed by discarding bit 5 and
placing 6-bits right justified in the target field. Truncation then
takes place if the target field is less than 6 bits.
<pre>

________________________________________________________________|
|   0   |   d   |discard|   d   |   d   |   d   |   d   |   d   |
Input   |_______|_______|_______|_______|_______|_______|_______|_______|
	    |               |       |       |       |       |   |
	    |_______        |       |       |       |       |   |
		____|_______|_______|_______|_______|_______|___|
		|   d   |   d   |   d   |   d   |   d   |   d   |
Receiving Field         |_______|_______|_______|_______|_______|_______|
								|

</pre>
<p>
$data_code directive tables and activates byte translate values for strings

<p>
If $word is not a  multiple of the $byte, bytes in strings straddle words.
New strings start at a word, except in bit-aligned $record structures
<pre>

$ ../masmx qzuli -ln
MASMX 7r2
3/qzuli.msm
*EOF*
:                            1         $set_option "e"
:                            2         $word   30
:                            3         $octal
:                            4         $byte   7
000:0000000000  3757677375 7677375767 7375767737 5767737576 7737576773 7576773757
		      +5         "???????????????????????????????"
Note: qzuli.msm Line 5: trailing zero bits in last data word of string
000:0000000006  6773757677 3750040200
		      +5 
000:0000000010  3757677375 7677375767 7375767737 5767737576 7737576773 7576773757
		      +6         "??????????????????????????":127:127:127:127
000:0000000016  7777777777     +6 
*EOF*
:$(0):0000000000:0000000017 
qzuli.msm: object code 162 bytes: 0 errors: 0 undefined labels

</pre>

<p>
<b>$octal</b> directive shows the 30-bit words and adresses in octal.

<p>
In line 5, the assembler added three 7-bit space characters to fill the
last data word, but still needed to add two trailing zero bits.

<p>
The first 30 characters had exactly filled seven data words, but the last
character left 23 bits.

<p>
Space fill in the last word is added. <b>-c</b> or
<b>-z</b> flag causes zero fill instead of space.
<b>-zc</b> flags combined fill with space

<p>
Slack bits remaining after the last character position are zeroed

<p>
The constant in line 6 exactly fills 210 bits or seven data words.

<p>
This 30-bit architecture has a 30-bit quantum. So only 15 locations
have been filled.

<p>
The <b>-e</b> flag causes a space to be printed between each word of generated
code

<p>
A text string may be placed in a field not a multiple $byte in a $form template
<pre>

$ masmx ldes -ln
MASMX 7r2
3/ldes.msm
*EOF*
:                            1         $word   32
:                            2         $quantum 8
:                            3         $byte   8
:                            4 label_descriptor $form  8, 8, 16, 4, 60   
:                            5 
00:00000000 0700FFF63404C4142454C310
		      +6      label_descriptor 7,0,-10,3,"@LABEL1"
*EOF*
:$(00):00000000:0000000C 
ldes.msm: object code 70 bytes: 0 errors: 0 undefined labels

</pre>
<p>
In this example the characters @LABEL1 have been placed 
in the first 56 bits of their 60-bit field, and four zero 
bits appended.

<p>
Quoted character fields in a $form structure are zero-padded
in any untyped columns. The columns can be typed as space to force
space, as "@VOL2&nbsp;&nbsp;" distinct from "@VOL1" here
<pre>
$ masmx ldes2 -ln
MASMX 7r2
3/ldes2.msm
*EOF*
:                            1         $word   32
:                            2         $quantum 8
:                            3         $byte   8
:                            4 label_descriptor $form  8, 8, 16, 4, 60   
:                            5 
00:00000000 0700FFF6340564F4C3100000
		      +6 	label_descriptor 7,0,-10,3,"@VOL1"
00:0000000C 0707000A740564F4C3220200
		      +7 	label_descriptor 7,7, 0a,7,"@VOL2  "
*EOF*
:$(00):00000000:00000018 
ldes2.msm: object code 95 bytes: 0 errors: 0 undefined labels

</pre>
<p>
A quoted string in a macro expansion may contain parameter
references:
<pre>

MASMX/-240 1r1X
bdw.msm 5
*EOF*  :                        1: bdw     $form   24,12,6,6,48
:                        2: p       $proc   5
:                        3: bd      $name        
:                        4:         $byte   6
:                        5:         bdw     p(1, 1), 0, 0, p(1, 2), "p(1, 1)"
:                        6:         $byte   8
:                        7:         $end
:                        8: 
00:00000000 0000000000038A1BAB440000+9         bd      bank1, 3
00:00000004 0000000000078A1BAB450411+10         bd      bank1001, 7
*EOF*:$(00):00000008 
Object Code 127 Bytes: 0 Errors: 2 Undefined Labels

</pre>
<p>
The right half of the first structure contains the text
"bank1   " compressed to 6-bit characters.

<p>
The right half of the second structure contains the text "bank1001"
compressed to 6-bit characters (bit 5 of each ASCII symbol is dropped):
<pre>

    62     61     6e     6b     31     20     20     20
100010 100001 101110 101011 010001 000000 000000 000000

    62     61     6e     6b     31     30     30     31
100010 100001 101110 101011 010001 010000 010000 010001

</pre>
<p>
The macro references "bank1 and "bank1001" as well as capturing the
names as text. External references have been marked 
in the output file. Those are the two undefined labels.


<a      name="characteristic"/>
<h2>8.6:  $characteristic    Set Floating Point Characteristic Size</h2>

<p>
Floating point values are calculated to 192 bits precision, and the
default floating constant size is 96 bits with 24-bit characteristic.
See also <a href="#floating_point">8.19: $floating_point</a> directive

<p>
Characteristic means exponent size plus a sign position

<p>
$characteristic directive sets the size of the characteristic part
of floating constants. If $characteristic directive has a subcommand,
for example
<pre>

	$characteristic,64      <i>SIZE</i>

</pre>
<p>
then <i>SIZE</i> is the characteristic size of a 64-bit floating point number

<p>
Without the subcommand, SIZE is the characteristic size of a
default-size floating point item. 

<p>
A default-size floating point item is 96 bits unless
<a href="#floating_point">$floating_point</a> directive has changed it.

<p>
The default 96-bit floating point item has the default characteristic
size 24 bits, and the mid-pointed exponent is 23 bits:
<pre>


_______________________________________________________________
|s|94 exponent 72|71          mantissa                       0|
|_|______________|____________________________________________|


</pre>

Default characteristic sizes are

<blockquote>

8 bits for a floating number less than one word in size<br><br>
8 bits for a floating number one word in size<br><br>
12 bits for a floating number two words in size<br><br>
24 bits for a floating number three words or more in size

</blockquote>

<p>
$word is programmable and each possible constant size in words up to 192
bits has a separate $characteristic size

<p>
$characteristic directive changes characteristic size for one word size, expressed
in bits

<p>
The developer applies a characteristic size for each number size where
the masmx default characteristic field is not the required size. See
also  <a href="#fdemens2">11.2.2: Exponent Field Size</a>


<p>
In the following example, a default sized floating constant
is 32 bits, set with <a href="#floating_point">$floating_point</a> directive, 
but there may also be 64-bit and 80-bit floating constants 
with larger characteristic fields

<p>
The largest characteristic size is 24 bits. The largest
floating constant size is 192 bits.
<pre>


$ masmx -ln dfp16
MASMX 7r2
3/dfp16.msm
*EOF*
:                            1         $word   16
:                            2         $quantum 8
:                            3         $awidth 32
:                            4         $floating_point 32
:                            5         $characteristic 8
:                            6         $characteristic,64 12
:                            7         $characteristic,80 16
:                            8 $(2:*8:256)        
02:00000100 41C00000          +9 one     +1.5
02:00000104 401E000000000000  +10 two     +1.75:q
02:0000010C 4001C000000000000000
		      +11 three   +15.0e-1:p
02:00000116 B837FFFF          +12 four    -100.0
02:0000011A 47C80000          +13 	+100.0
02:0000011E 438CC2DC14A740E08BDA
		      +14 five    +33*+20000:p
*EOF*
:$(02):00000000:00000128 
dfp16.msm: object code 145 bytes: 0 errors: 0 undefined labels

</pre>
<p>
Here, 64-bit floating point items (quadwords where $word 
is 16) are given  a 12-bit characteristic, and 80-bit 
floating point items (pentawords) have a 16-bit characteristic. 

<p>
The default floating model has a mid-pointed exponent 
occupying all the $characteristic width except the high-order 
sign bit, the mantissa is normalised fraction-only with no 
integral part either represented or imputed, and negative 
representation is the ones complement of the entire item.

<p>
This is not IEEE 754 encoding. IEEE 754, or any 
other encoding different from masmx default, is generated 
with macros which use the <a href="#set">$set</a> directive to capture
and manipulate a number argument. See <a href="#ieeefloat">11.3: IEEE754 Floating Values</a>

<p>
Macro language reverses byte order if required

<p>
Code written for other assemblers has constant-generating
commands (for example, .float).

<p>
Macros implement commands like DF or .float in masmx.

<p>
24 is the maximum characteristic width, and the default for floating-point
items three or more words in size. The default for a single floating-point
word is 8 bits and for a double 12:
<pre>

$ masmx hflo -lnky
MASMX 7r3
3/hflo.msm
*EOF*
:                            1         $word   32
:                            2         $quantum 8
:                            3         $awidth 32
:                            4         $floating_point 32
00:00000000 41C00000          +5         +1.5
00:00000004 401C000000000000  +6         +1.5d
00:0000000C 400001C00000000000000000
		      +7         +0.15t*+1
00:00000018 400001C0000000000000000000000000
		      +8         +15:q*-1
00:00000028 400001C000000000000000000000000000000000
		      +9         +1.5p
00:0000003C BFFFFE3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
		      +10         -1.5h
Note: hflo.msm Line 11: floating number is maximum words
00:00000054 400001C00000000000000000000000000000000000000000
		      +11         +1.5o
*EOF*
:$(00):00000000:0000006C 

</pre>
<p>
The request to generate an octaword item only resulted in
a hexaword, because 192 bits is the limit of a number size in masmx.


<a      name="cont_char"/>
<h2>8.7:  $cont_char          Change Line Continuation Character</h2>

<p>
Default $cont_char is semicolon. The line is catenated with the
first noncomment non-white-space non-continuation character
on the next line:
<pre>

MASMX/-240 1r1X
leggy.msm 5
*EOF*00:00000000 00055555      +10         +       262144;
					  ++65536;
					  ++16384;      
					   ++4096;
					   ++1024;
					    ++256;
					     ++64;
					     ++16;
					      ++4;
					      ++1
	 
*EOF*:$(00):00000001 
Object Code 25 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
To use semicolon for comment or for anything else,
continuation must be changed first.

<p>
Then semicolon is immediately available for reassignment
as comment character (and then period is immediately available for
reassignment as substring terminator).
<pre>

$cont_char      0
$lterm          ';'

</pre>
<p>
Setting continuation to zero means there is no line continuation.

<p>
If another character is wanted for line continuation,
then the $cont_char argument is not zero, but the value
of the required character. All of these are tilde ~
<pre>

$cont_char       '~'
$cont_char       07e
$cont_char       126

</pre>
<p>
To get space into a continued line, the space must be before the
continuation character, because leading whitespace on the next line
is skipped:
<pre>

$cont_char	'\'

command		field1	\
		field2	\
		field3

</pre>

<p>
Line continue character does not act if a nonspace symbol follows
it immediately:
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	$cont_char       '\'
CONT_CHAR=\
	$word		32
	+		\10101010\	bit pattern 0xAA and line continue
			*/16\		shift left 16 and line continue
			++3     	. OR 3
	$end
  :                            1  $cont_char '\'
  :                            2  $word  32
00:00000000 00AA0003          +3  +  \10101010*/16++3  . OR 3
  :                            4  $end
:$(00):00000000:00000001 
-INPUT>>: object code 54 bytes: 0 errors: 0 undefined labels

</pre>


<a      name="data_code"/>
<h2>8.8:  $data_code             Set Alternative Character Set</h2>

<p>
$data_code tables and activates byte translate values for quoted
text strings and value strings in apostrophe

<p>
masmx input is octets containing ASCII values plus possible extensions like
Latin-1 in code points 0..255

<p>
$data_code directive allows "text strings" and +'character value constants'
to be composed in a translated character code.

<p>
256 code points are translated to values up to 32 bits in size, but
only single-octet input values may be translated.<br>$data_code cannot
meaningfully translate multi-byte values from for example UTF-8
<pre>

MASMX/-240 1r1X
code.msm 5
*EOF*  :                        1:         $word   32
  :                        2:         $quantum  8
  :                        3:         $byte   8
  :                        4:         $awidth 32
00:00000000 41424320      +5         "ABC"
  :                        6:         $data_code  'A', 0c1, 0c2, 0c3, 0c4, 0c5, 0c6, 0c7, 0c8, 0c9
  :                        7:         $data_code  32, 64
00:00000004 C1C2C3C4C5C64040+8         "ABCDEF"
  :                        9:         $ascii
00:0000000C 4142434445462020+10         "ABCDEF"
  :                        11:         $data_code
00:00000014 C1C2C340      +12         "ABC"
*EOF*:$(00):00000018 
Object Code 73 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Here the $data_code has generated alternative 
values for the first nine letters of the alphabet, and for the 
space character.

<p>
$data_code also switches to the alternative data code as it constructs it.

<p>
$ascii directive switches to the assembly initial setting of unchanged
input values (ASCII / Roman-8 / Latin-1 / UTF-8) for strings, but leaves
the tabled translate values available

<p>
$data_code with or without arguments switches to byte translate. The initial
translate table has all code points unchanged. $data_code may table translate
values for code points 0..255

<p>
Both assembly passes begin in $ascii mode


<a      name="do"/>
<h2>8.9: $do                Generate Repeated Code</h2>     

$do repeats code.

<p>
The arguments are the repeat count, a comma, and the line of code
to be repeated:
<pre>

MASMX 7r2
3/do1.msm
*EOF*
00:000000 000021              +1         $do      5, +   33
00:000001 000021              +1 
00:000002 000021              +1 
00:000003 000021              +1 
00:000004 000021              +1 
*EOF*
:$(00):000000:000005 
do1.msm: object code 72 bytes: 0 errors: 0 undefined labels

</pre>

<p>
$do may be nested and the label on the $do line represents a relative-1
ascending counter
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
?	$do	10,     1.5*+?-1
	$end
00:000000 400001C00000000000000000
                              +1 ? $do 10, 1.5*+?-1
00:000004 400004F00000000000000000
                              +1 
00:000008 400008960000000000000000
                              +1 
00:00000C 40000BBB8000000000000000
                              +1 
00:000010 40000EEA6000000000000000
                              +1 
00:000014 400012927C00000000000000
                              +1 
00:000018 400015B71B00000000000000
                              +1 
00:00001C 400018E4E1C0000000000000
                              +1 
00:000020 40001C8F0D18000000000000
                              +1 
00:000024 40001FB2D05E000000000000
                              +1 
  :                            2  $end
:$(00):000000:000028 

</pre>
<p>
The repeat argument to $do is evaluated to a precision of 192 bits.
32 bits of the expression's final value are used as a count.

Therefore the expression
<pre>

	$do     label>07FF0000000000000000000

</pre>
<p>
Is evaluated correctly. Its value is either one for "greater" or zero for "not greater". 

<p>
Comparison operators <b>= ^= &gt; &lt;</b> and option flags have a value of zero or one
<pre>

	x=y

	x^=y
	
	$o('x')

</pre>
<p>
Then  $do has the effect of a decision. The code line argument is
assembled once or not.

<p>
When the count argument of $do is zero, the code line argument
is not assembled.

<p>
$do can only iterate one line of code, but that line can be a macro call.
See section 5.1 <a href="#domac">$do Directive and $proc Macros</a>


<a      name="else"/>
<h2>8.10: $else              Conditional Assembly</h2>
      

<p>
Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif

</pre>
<a      name="elseif"/>
<h2>8.11: $elseif            Conditional Assembly</h2>                

<p>
Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif


</pre>

<a      name="end"/>
<h2>8.12: $end               End of Macro or Assembly</h2>          

<p>
This image is required at the end of all subassemblies (macros)
<pre>

name_of* $proc
	.
	.
	$end

tag_of*	$func
	.
	.
	$end

</pre>
<p>
If $end is encountered in the main assembly, its effect is end of
assembly. In the main assembly a program transfer address may be supplied
as an argument to $end
<pre>

	$end    program_transfer_address

</pre>
<p>
$end in an include file doesn't stop the assembly, so $end can be
used in an include file to give a transfer address.



<a      name="endif"/>
<h2>8.13: $endif             Conditional Assembly</h2>              

<p>
Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif



</pre>
<a      name="equ"/>
<h2>8.14: $equ               Assign Value to Label</h2>


<p>
$equ assigns a value to a label for the duration of the 
assembly or subassembly (macro). 

<p>
The label may be assigned any value which can be expressed
in 192 bits.
<pre>

label   $equ    10*44*/180

</pre>
<p>
A label is equated on the second assembly pass if it does not yet exist.

<p>
Labels cannot be changed between types location, $equ, $set,
and cannot except for $set labels be redefined.
See <a href="#set">8.46:$set Directive</a>

<p>
$equ may have a subfunction which assigns a TYPE to the label.
Two types supplied within the assembler, $directive and $function,
may be used for aliasing:
<pre>

.macro  $equ,$directive $proc
.endm   $equ,$directive $end

.       $equ,"$function" "$"

</pre>
<p>
$function means assembler supplied functions, like the location
counter, not user-written $func..$end macro functions.

<p>
To make . functionally the same as $ location counter, "$" is in
quotes. Otherwise $ returns its functional value, the current location.

<p>
The developer may use a range of type values 128..255 to type,
for example, register sets:
<pre>

data_register   $equ    128
address_register $equ   129

d0      $equ,data_register      0
d1      $equ,data_register      1
	.
	.
d7      $equ,data_register      7

a0      $equ,address_register   0
a7      $equ,address_register   7
	.
	.
a7      $equ,address_register   7

</pre>
<p>
This allows the actual parameters of instruction macros to have a type.
The type of a tag can be retrieved with the <b>$t</b> internal function:
<pre>

p       $proc
move.w  $name
	$if     $t(p(1,1))=address_register
	.
	.

</pre>
<p>
This is useful in dialects where many instructions have the same
name but the encodings change for different operand types.

See also <a href="#labeltyp">4.7.10: (function) $t(<i>ARGUMENT</i>) Label Type</a>



<a      name="equf"/>
<h2>8.15: $equf              Assign List of Values to Label</h2>

<p>
$equf equates a label to a list of values.

<p>
Macro expansion can then retrieve each value individually as a
separate argument. 

<p>
Each value corresponds to a subfield in the FIELD, SUBFIELD macro argument construct

<p>
$equf is typically used to identify a  base-displacement tuple with possible
further attributes like indirection or field-size:
<pre>

aName   $equf   buffer, r9, halfaword
	.
	.
	addto   r6, aName

</pre>
<p>
has the effect
<pre>

	addto   r6, buffer, r9, halfaword

</pre>
<p>
Arithmetic is possible on the first or principal $equf value:
<pre>

	addto   r6, aName+5

</pre>
<p>
has the effect
<pre>

	addto   r6, buffer+5, r9, halfwaword

</pre>
<p>
The $equf name must be on the left of any +- expression or the
other attributes aren't retrieved.

<p>
That is,
<pre>

	addto   r6, aName+5

</pre>
<p>
works as
<pre>

	addto   r6, buffer+5, r9, halfwaword

</pre>
<p>
but
<pre>

	addto   r6, 5+aName

<p>
only works as

	addto   r6, 5+buffer


</pre>
<p>
In "addto r6,aName+5", the addto macro receives for its
arguments:
<pre>

	addto(1, 1)     is      r6
	addto(1, 2)     is      buffer+5
	addto(1, 3)     is      r9
	addto(1, 4)     is      halfaword

</pre>
<p>
Each binary token in the $equf may have a retrievable 
unary * flag, as subfields always can

<p>
Where
<pre>

aName   $equf   buffer, *r9, halfaword
	.
	.
	addto   r4, aName

</pre>
<p>
Then
<pre>

	addto(1, *3)    is      1

</pre>
<p>
*R9 is only the second subfield of aName, but R4 is a subfield before
aName. addto can see four subfields.

<p>
Where r9 is supplied, not *r9, the value of "addto(1, *3)" is zero.
The value of "addto(1, 3)" is r9 with or without the flag

<p>
It's possible to override the trailing attributes. Where:
<pre>

aName   $equf   buffer, r9, halfaword
	.
	.
	addto   r6, aName,,all_of_aword

</pre>
<p>
The effect is
<pre>

	addto   r6, buffer, r9, all_of_aword

</pre>
<p>
And the effect of
<pre>

	addto   r6, aName+20, r7

</pre>
<p>
is
<pre>

	addto   r6, buffer+20, r7, halfaword

</pre>
<p>
Only one subfield in a field of actual arguments can be a 
$equf label. If there are two $equf identifiers on an argument line,
they should not be subfields in the same field. They should be in
separate fields
<pre>

left    $equf   input_buffer, a0, d0.w, 4, L        
right   $equf   output_buffer, a1@+,,, L
	.
	.
	eor.l   left right

NOT:::  eor.l   left, right     

</pre>
<p>
In the following assembly, a procedural macro "p" 
retrieves some integer tokens from the $equf laBEL and 
uses them to generate integer constants. A flag * can 
be set and retrieved for each subfield. * has a value 
of 1 when it is present.
<pre>

MASMX 7r2
3/equf.msm
*EOF*
  :                            1         $word   32
  :                            2 p*      $proc
  :                            3         +       p(1, 1):S
  :                            4         +       p(1, 2):s
  :                            5         +       p(1, 3)s
  :                            6         +       p(1, 4)s
  :                            7         +       p(1, *1)s
  :                            8         +       p(1, *4)s
  :                            9         $end
  :                            10 
  :                            11 laBEL   $equf   5, 4, 3, *2
00:00000000 00000005          +12         p       laBEL
00:00000001 00000004          +12 
00:00000002 00000003          +12 
00:00000003 80000002          +12 
00:00000004 00000000          +12 
00:00000005 00000001          +12 
*EOF*
:$(00):00000000:00000006 
equf.msm: object code 99 bytes: 0 errors: 0 undefined labels

</pre>
<p>
laBEL is the only argument on the 
"p laBEL" line, and it delivers subfields 1,1 1,2 1,3
and 1,4 (the first four subfields of field 1) to the macro.

<p>
Where a $equf label is the second subfield in the field:
<pre>

	mnemonic   register_tag,EQUF_LABEL

</pre>
<p>
then EQUF_LABEL supplies parameters 1,2 1,3 1,4 ...  

<p>
If there are two actual arguments before EQUF_LABEL, the argument
subfields supplied by EQUF_LABEL are 1,3 1,4 1,5...
<pre>

	mnemonic        register_tag, another_register_tag, EQUF_LABEL

</pre>
<p>
Macro language calls its formal arguments <b>p(argument numbers)</b>
if the macro is called <b>p</b>. The macro can be called anything
and can have extra names each attached to a latent parameter value

<p>
The load/add/store macro generates instructions with a register left-side
operand and a storage right-side operand.

<p>
The left-side operand is a register tag in the range 0..15.

<p>
This register tag is one formal argument on the instruction call line,
and is the first subfield <b>p(1,1)</b> of the one argument field.

<p>
There are 1..3 more formal arguments, and they all describe the
storage operand.

<p>
Macro language calls these last three formal arguments 
<b>p(1,2) p(1,3) p(1,4)</b>. The formal arguments get translated
to the actual arguments

<p>
<b>p(1, 2)</b> is the operand address.

<p>
<b>p(1, 3)</b> is an optional index register tag.

<p>
<b>p(1, 4)</b> is an optional tag describing the size and bit-position of
the operand.

<p>
The RISC architecture has an address quantum of 32 bits.

<p>
Some of its instructions can access fields within 32-bit words using 
a selector encoded in the second quartet of the instruction layout.

<p>
$equf names INPUT1 INPUT2 OUTPUT hold an address and maybe an index register and a field designator:
<pre>

MASMX 7r2
3/equf32.msm
*EOF*
  :                            1         $word   32
  :                            2 "$instru" $form        4, 4, 4, 4, 16
  :                            3 
  :                            4 b1      $equ    4
  :                            5 b2      $equ    5
  :                            6 b3      $equ    6
  :                            7 b4      $equ    7
  :                            8 
  :                            9 immediate $equ  1
  :                            10 h1      $equ    2
  :                            11 h2      $equ    3
  :                            12 
  :                            13 r0      $equ    0
  :                            14 r1      $equ    1
  :                            15 r5      $equ    5
  :                            16 r6      $equ    6
  :                            17 r15     $equ    15
  :                            18 
  :                            19 p       $proc
  :                            20 load*   $name   1
  :                            21 add*    $name   2
  :                            22 store*  $name   3
  :                            23         $instru       $n, p(0,2)++p(1,4), p(1, 1), p(1,3), p(1,2)
  :                            24         $end
  :                            25 
  :                            26 code    $equ    1
  :                            27 static  $equ    2
  :                            28 $(static:16384)
  :                            29 buffer  $res    1024
  :                            30 $(code:256)
  :                            31 
  :                            32 INPUT1  $equf   buffer+512, r5, b1
  :                            33 INPUT2  $equf   buffer
  :                            34 OUTPUT  $equf   buffer, r1, h2
  :                            35 
01:00000100 14F54200          +36         load    r15, input1
01:00000101 20F04000          +37         add     r15, input2
01:00000102 33F14000          +38         store   r15, output
  :                            39 
01:00000103 16654200          +40         load    r6, INPUT1,,b3
01:00000104 33654000          +41         store   r6, OUTPUT,r5
01:00000105 33614063          +42         store   r6, OUTPUT+99
*EOF*
:$(01):00000100:00000106 :$(02):00004000:00004400 
equf32.msm: object code 131 bytes: 0 errors: 0 undefined labels

</pre>
<p>
See also <a href="#sections">7: Constructing Program Sections</a>,
<a href="#bdflat">7.1.3..5 base-displacement</a>

<p>
The six possible attributes in a $equf label are intended for
high-level language development requiring complex attribute information.


<a	name="exit"/>
<h2>8.16: $exit              Stop the Assembly with a Message</h2>

<p>
$exit outputs the argument text and exits the assembly, for example:
<pre>

case_required $proc
	$if     $o(k)=0
	$exit   Option -k Required
	$end

</pre>
<p>
The developer needed <a href="#option_k">-k flag</a> (case significant labels) to be set on the
command line. -k may not be opted with <b>$set_option</b> directive


<a      name="flag"/>
<h2>8.17: $flag              Diagnostic, Mark Assembly in Error</h2>


<p>
Display a message and mark the assembly in error. $flag
is actioned on the second pass. Example:
<pre>

	$if     address>64*1024*1024*1024*1024
	$flag   That was a mistake
	$endif

</pre>
<p>
File and line number are listed with the message.


<a      name="flagf"/>
<h2>8.18: $flagf             First Pass Diagnostic, Mark in Error</h2>


<p>
Display a message and mark the assembly in error. $flagf
is actioned on the first pass and the second pass is not
begun. Example:
<pre>

	$if     length>64*1024*1024*1024*1024
	$flagf  That's never going to work
	$endif

</pre>
<p>
File and line number are listed with the message.


<a      name="floating_point"/>
<h2>8.19: $floating_point    Default Size of Floating Point Item</h2> 


<p>
$floating_point sets the default size of floating point items.

<p>
The default is initially 96 bits:
<pre>

	_______________________________________________________________
	|s|94 exponent 72|71          mantissa                       0|
	|_|______________|____________________________________________|


</pre>
<p>
Floating point numbers are generated automatically when a number
item (command code + - ^) has a decimal point or a scale operator
*+ or *-
<pre>

	+	1.9
	-	MANTISSA*+1200000
	+	1.37*-SCALE

</pre>
<p>
masmx internal floating-point numbers have an all-fractional mantissa with no
integral part whether hidden or represented. The value can be converted to
constants in other formats

<p>
Exponent is midpointed.

<p>
Negative polarity is represented by the entire item in 1-s complement.
Sign-bit 1 indicates that all bits are inverted.

<p>
This is not IEEE 754 format. That is supported with macros.
See Section 1.5: Any floating-point format, Section <a href="#ieeefloat">11.3: IEEE754 Floating Values</a>


<p>
Octaword on line 11 with 32-bit <b>$word</b> generates 192 bits the same as hexaword.
Numbers in masmx are not larger than 192 bits.

<p>
Scale expression beginning [ e E e+ E+ e- E- ] is only detected in
an all-decimal string containing a decimal point
<pre>

$ masmx hflo -lnky
MASMX 7r3
3/hflo.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3         $awidth 32
  :                            4         $floating_point 32
00:00000000 41C00000          +5         +1.5
00:00000004 401C000000000000  +6         +1.5d
00:0000000C 400001C00000000000000000
                              +7         +0.15t*+1
00:00000018 400001C0000000000000000000000000
                              +8         +15:q*-1
00:00000028 400001C000000000000000000000000000000000
                              +9         +1.5p
00:0000003C BFFFFE3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                              +10         -1.5h
Note: hflo.msm Line 11: floating number is maximum words
00:00000054 400001C00000000000000000000000000000000000000000
                              +11         +1.5o
*EOF*
:$(00):00000000:0000006C 

</pre>
<p>
$floating_point sets both the default size of a floating number constant,
and the bit layour of $set and $equ labels containing floating values


<p>
The largest size is 192 bits, which is also the size of value which a label may hold
<pre>

	__________________________________________________________________
	|s|190 exponent 168|167          mantissa                       0|
	|_|________________|_____________________________________________|



</pre>
<a      name="form"/>
<h2>8.20: $form             Layout Template of Bit Structure or Instruction</h2>


<p>
$form declares layouts of bitfields into which instruction 
codes and operand addresses and tags can be assembled.

<p>
$form can also be used for structures which are not instructions.

<p>
An example of a $form is the template of load and store 
instructions in PowerPC:
<pre>

i$type_load_store $form 6, 5, 5, 16

</pre>
<p>
The label of the $form is the command name in the code-generating
line of the instruction macro:
<pre>

p       $proc
lwz     $name   32
stw     $name   36
lhz     $name   40
	.
	.
	i$type_load_store $n, p(1, 1), index$\p(1, 2), p(1, 2)
	$end

index$  $func
	$return index$(1, 1)
	$end

</pre>
<p>
The code fragment:
<pre>

ADDRESS $equ    4094        
	lwz     r6, ADDRESS(R31) 
	
</pre>
<p>
is structured per $form i$type_load_store to fields of
six, five, five, and sixteen bits containing 32.6.31.4094, or
0x80df0ffe:
<pre>

MASMX/-240 1r1X
q.msm 5
LTERM=#
CONT_CHAR=
STERM=.
*EOF*  :                        2: ADDRESS $equ    4094
00:00000000 80DF0FFE      +3         lwz     r6, ADDRESS(R31)
*EOF*:$(00):00000000:00000004 
Object Code 58 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
A function <b>index$</b> to haul up a base register value from parentheses allows
source code written with the syntax <b>address(Register)</b> to assemble.

<p>
masmx macro language for one-address computers can be written with
the base register as third subfield
<pre>

	lwz	r6, ADDRESS, r31

</pre>
<p>
And the code-generating line of macro text may then be
<pre>

	i$type_load_store $n, p(1, 1), p(1, 3), p(1, 2)

</pre>
<p>
The supplied definition "ppc_603.def" processes either syntax.


<a      name="func"/>
<h2>8.21: $func              Macro to Produce Operand Value</h2>      

<b>$func</b> is the directive at the head of a function macro, which
returns a value to be used as a token in an assembly-time expression
<pre>

functio* $func	[*]
	.
	.
	$return	<i>VALUE</i>
	$end



f	$func	[*]
fname1*	$name	<i>LATENT_VALUE1</i>
fname2*	$name	<i>LATENT_VALUE2</i>
	.
	.
	$return	<i>VALUE</i>
	$end


</pre>
<p>

See <a href="#fmacro">4.6: Function Macros</a>

<p>
The optional argument of asterisk on <b>$func</b> directive suppresses
expansion of the <b>$func</b> macro on the first assembly pass

<p>
This is to inhibit a preliminary expansion of a non-idempotent <b>$func</b> macro

<p>
However second-pass-only expansion may cause an anomaly between the first
and second assembly passes, and then the asterisk must be omitted and the
<b>$func</b> macro expands on both assembly passes



<a      name="hex"/>
<h2>8.22: $hex               Set Binary Notation to Hex</h2>

<p>
Default binary notation is hex.

<p>
A number string beginning 0 is in current binary notation. 

<p>
Therefore 1000 and 03e8 both mean one thousand, unless the opposite
directive
<pre>

	<a href="#octal">$octal</a>

</pre>
<p>
has been issued. Then 03e8 means three and 01750 means one thousand,
but 1000 still means one thousand.

<p>
the $hex directive
<pre>

	$hex

</pre>
<p>
gets hex back.

<p>
Each assembly pass begins in hex mode.

<p>
When hex is on, display is also in hex

<p>
When octal is on, display is also in octal

<p>
See also <a href="#describe1">10.1: Establishing Your Syntax</a>,
<a href="#suffix_directive">8.51: $suffix Directive</a>,
<a href="#notate2">4.2.2.1: Number Strings</a>

<p>
<a href="#option_c">option flag -c</a> changes number syntax to C language for hex and octal.

<p>
<a href="#option_m">option flag -m</a> turns on Motorola $hex syntax, @octal and %bit_pattern.



<a      name="if"/>
<h2>8.23: $if                Conditional Assembly</h2>

Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif




</pre>
<a      name="include"/>
<h2>8.24:	$include	Include a Source File or a Binary File</h2>		

<h3>8.24.1:	$include	Read a Nested Source File</h3>           


<p>
Read and assemble a nested source file. Nesting can recurse
to a depth of 16. 
<pre>

	$include        target.def

</pre>
<p>
The default filename extension is .msm

<p>
Therefore
<pre>

	$include	application

</pre>
<p>
reads application.msm

<p>
The following are defaults until definition files change them:

<p>
semicolon is a line continuation character

<p>
The substring separator is colon

<p>
The quote character is "

<p>
The comment character is initially period, but comment character period
is never actioned if it is immediately followed by a nonspace symbol
<pre>

	$include	file2.src	
	+		1.5	. floating number	

</pre>
<p>
If an include definition has changed the quote character,
subsequent includes names cannot be bound with "" but may
be bound with the new quote character.

<p>
Special symbols like comment and line continue are not actioned
within quotes
<pre>

	$include	"rough looking;; file. name. "


</pre>

<a      name="include_b"/>
<h3>8.24.2: $include,$binary	Read a Text Encoded Binary File</h3>

<p>
Linking Directive
<pre>

	$include,$binary	file	$(n, n, n,...

</pre>
<p>
Reads a text encoded binary and submits each text line in it to
the developer-supplied link macro <b>$map</b>

<p>
The optional second argument selects and orders the segments to be taken
from the file.

<p>
Without the second argument, all sections are taken from the file and if
they are relocatable, default behaviour collects the segments
exactly in order of appearance.

<p>
<a href="#option_b">option flag -b</a> causes instead all the relocatable segments of all
the binary files included to be collated by section.

<p>
A cumulative link (where the inputs are relocatable and so are the
outputs) always has the effect of gathering by section.

<p>
Absolute address in the included binaries have the effect
of giving an absolute start addresses to the link.

<p>
An absolute location counter switch before the binary includes
gives an absolute start address to the link:
<pre>

$(0:65536)
	$include,$binary	rel_file1
	$include,$binary	rel_file2

</pre>
<p>
A relocatable location counter switch before the binary includes
causes relocatable segments to be gathered by section and output as
new relocatable segments:
<pre>

$(0:*4)
	$include,$binary	rel_file_A
	$include,$binary	rel_file_B

</pre>
<p>
See <a href="#linkbasic">9.2.2 masmx Linking in Principle</a>,
<a href="#linkdems">9.2.3: Demonstration Links</a>

<p>
The link macro definition including <b>$map</b> macro must be already included.

<p>
The default text encoded binary file name extension is txo
<pre>

	$include,$binary	rel_file[.txo|<i>extension</i>]

</pre>
<p>
The binary includes must be Text Encoded Binary format.
See <a href="#file_formats">9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools</a>



<a      name="include_v"/>
<h3>8.24.3: $include,$void		Bind to an Independent Text Encoded Binary</h3>

<p>
Linking Directive. The default filename extension is .txo
<pre>

	$include,$void	kernel
	$include,$void	absolute_library_bank

</pre>
<p>
include addresses from a text encoded binary file, but do not include
code from it:

<p>
See also <a href="#file_formats">9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools</a>


<a	name="info"/>
<h2>8.25: $info       Linking Directive used within $map macro</h2>
<h3>8.25.1: $info, $offset     Replace Information at the Relocation Stack Top</h3>

<p>
Update relocation information from relocatable input to relocatable
output.

<p>
Applied to the offset value in the tuple at the relocation stack top.

<p>
$offset is the equivalent of addend value in ELF environment.
<pre>

	$info,$offset	expression

</pre>
<p>
Subsequently the $load directive will rewrite the relocation clause to
Text Encoded Binary output from the adjusted relocation tuple on the
internal relocation stack.

<p>
Not all relocation tuples include an offset value, only those which
indicate manipulation (shift/truncate) of the value after relocation.

<p>
Otherwise the offset is obtained from the code.

<p>
See <a href="#file_formats">9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools</a>

<p>
New offset carries an adjusted value forward in cumulative links.

<p>
Macro language must take this action where three circumstances combine:
<pre>

	There is a right-shift to be carried out on the offset
	(and therefore there is an extracted offset in the
	relocation clause)

	A segment base address used in the field value
	has moved as a result of relocation

	The output is relocatable

</pre>
<p>
When there is no extracted offset in the relocation tuple, the necessary
adjustment is made by macro language on the code

<p>
When the output becomes absolute, no further relocation tuple is output

<a      name="info_range"/>
<h3>8.25.2: $info, $range_check
   and   $info, $range_check1: Request Linker Automatic Range Checking</h3>
<pre>

	$info,$range_check	value

</pre>
<p>
requests the linker section of masmx to range check value for the
current field size described at the relocation stack top.

<p>
masmx linker section derives the allowable range geometrically according
to the known field size and signed/unsigned attribute at the relocation
stack top.

<p>
<b>$range_check</b> is used where the <b>$map</b> macro
maintains a 192-bit offset during the successive accumulation of
relocation clauses for one field.

<p>
The check errors if the final value does not fit the field.
See <a href="#linkdems">9.2.3: Demonstration Links</a>

<p>
<b>$range_check1</b> requests more stringent behaviour than <b>$range_check</b>:
where more than one relocation clause applies to one field of code

<pre>

	$info,$range_check1	value

</pre>
<b>$range_check1</b> requests masmx to range check each new intermediate
value at the relocation stack top. In contrast to <b>$range_check</b>, each
addition of a successive relocation tuple (where they are more than one)
to the target field must stay in range.

<p>
If a rightward shift after relocation is requested, intermediate results
must fit a 48-bit offset maintained in the relocation stack. The final result must fit the target field.

<p>
Otherwise each add/subtract must fit the target field.

<p>
See Linker Examples in <a href="#linkdems">9.2.3: Demonstration Links</a>


<a	name="linewidth"/>
<h2>8.26: $linewidth      Text Encoded Binary Line Length</h2>

<p>
Set the guideline maximum line length for the Text Encoded Binary
outupt. The default is 60 columns.
<pre>

	$linewidth      expression


</pre>

<a      name="list"/>
<h2>8.27: $list              Set File Include Depth for Listing</h2>
<h3>8.27.1: $list <i>include_depth</i></h3>

<p>
When <b>$list</b> is > zero, and lowercase <b>-l</b> (list) is opted,
source is listed to a file include  depth of the <b>$list</b> value.
Default is
<pre>

	$list	1

</pre>
This causes the primary input file to be listed, but no include files<br>
<b>$list 2</b> causes the next depth of include files to be listed, and
so on up to maximum include depth

<a	name="list_0">
<h3>8.27.2: $list 0</h3>
When $list is zero
<pre>

	$list   0

</pre>
<p>
Nothing will be listed, and labels declared while $list = zero are also not
exported or included in option -x lists

<p>
When $list is < zero
<pre>

	$list	-1

</pre>
Nothing is listed, but labels declared while $list < zero may be exported.
See <a href="#labelhidden">Appendix E.7: Label fails to be exported</a>

<p>
$list &le; zero allows developers to list the labels in applications without
listing all the names in a complex target machine definition:
<pre>

	$list		0
	$include	ppc_603.def
	$list

</pre>
<p>
Labels which are not catalogued for listing are also not
exported.

<p>
In this example
<b>yasimi</b> is listed and exported and <b>yadont</b> is not
<pre>

$ cat yasimi.msm
	$word		32
	$quantum	8

$(4:1024)
yasimi*	+	yadont
	$list	0
yadont*	+	yasimi

	

$ masmx -lnxy yasimi yasimi
MASMX 7r2
3/yasimi.msm
*EOF*
  :                            1 	$word		32
  :                            2 	$quantum	8
  :                            3 
  :                            4 $(4:1024)
04:00000400 00000404          +5 yasimi*	+	yadont
*EOF*
YASIMI+=$04:00000400
yasimi.msm=0<00000003
:$(04):00000400:00000408 
yasimi.msm: object code 84 bytes: 0 errors: 0 undefined labels

$ cat yasimi.txo

$04:00000400
00000404 00000400
+YASIMI:$04:00000400
:$04*00000000:00000400:00000408


</pre>

<p>
Here is an extract from a cumulative link source. The
names in reloca.txo must be passed on. 
The binary code from reloca.txo is not listed
<pre>

	$list		0
	$include	ppc_map.def
	$list		-1
	$include, $binary reloca
	$list		2
	$include, $binary my_reloc
	$store		newreloc

</pre>
<p>
The exported names in reloca.txo are included in label lists and
re-exported because -1 is not zero


<p>
When source lines are listed, so is code generated from them.


</pre>
<a      name="lit"/>
<h2>8.28: $lit               Set Default Location Counter for Literals</h2>
<pre>

[label] $lit    expression

</pre>
<p>
Identifies the location counter 0..71 in which automatic literals
are generated.

<p>
Automatic literals are by default in counter 0.

<p>
If $lit has no argument, automatic literals are in
the current location counter.

<p>
If there is a label on a $lit line, the label is a literal pool tag.

<p>
See <a href="#sections">7: Constructing Program Sections</a>, <a href="#lptag">7.1.7: Literal Pool Tag</a>
<a href="#labeltyp">4.7.10: Label Types</a>, and
<a href="#literals">4.5: Literals</a>

<p>
Automatic literals are literals not triggered by a literal pool tag
(<a href="#lpooltag">4.5.5: Literal Pool Tags</a>), but by operands and constants in parentheses

<p>
Automatic literals may be generated if <a href="#option_a">option flag -a</a> is opted

<p>
Developers not wishing leading parenthesis on an operand to 
trigger literal generation should not opt <a href="#option_a">flag -a</a>

<p>
By default <a href="#option_a">option flag -a</a> is off, and automatic literals are not
generated.

<p>
<a href="#option_a">option flag -a</a> may be included in target definition files
<pre>

	$set_option     "a"

</pre>
<p>
The places where automatic literals may be generated are:
<ul>
	
	If parenthesis is the first symbol of an actual parameter to
	a $form, for example an operand to an instruction:
<pre>

		load    r11, (from_very_high_address)

</pre>
	If parenthesis is the first symbol in an expression in
	a number constant, for example
<pre>

		+       (0ffffff0000000000)

</pre>
</ul>

<a      name="load"/>
<h2>8.29: $load		Output Text Encoded Binary</h2>

<p>
Linking Directive
<pre>

	$load,$bits	expression

</pre>
<p>
is used in the developer-supplied <b>$map</b> macro to write updated code
to the new Text Encoded Binary output file.

<p>
The subcommand is the code size in bits of the written superword.

<p>
$load is the counterpart of <a href="#set">$set,$binary</a> which caches Text Encoded
Binary Input in a label and automatically sets label <b>$bits</b> to the
size of the superword which has been read:
<pre>

data_label	$set,$binary	superword_parameter

		.
		.

		$load,$bits	data_label

</pre>
<p>

The same size superword must be written as read. Automatic label $bits contains the size

<p>
See <a href="#linkbasic">9.2.2: Linking in Principle</a>


<a      name="lterm"/>
<h2>8.30: $lterm             Change Comment Sentinel</h2>
     

<p>
The default $lterm is period.

<p>
This declaration:
<pre>      
	
	$lterm  03b

</pre>
<p>
or this:
<pre>

	$lterm  ';'

</pre>
<p>
will change the comment sentinel to semicolon. $lterm can be changed
to any ASCII graphic symbol which is not required for something else.
<pre>

	$lterm  '#'

</pre>
<p>
is the same as
<pre>

	$lterm  023

</pre>
<p>
If # is used as the comment sentinel, it cannot 
also be used as a flag value on the front of, for example,
immediate operand expressions. See <a href="#argument_ref">Macro Parameter Reference</a>
Macro Parameters.


<a      name="name"/>
<h2>8.31: $name              Declare Macro Entry Point</h2>         

$name is a species of equate.
<pre>

tag*     $name   <i>VALUE</i>

</pre>
<p>
When declared within the body of of a procedural macro $proc
or a functional macro $func, $name is used to equate a mnemonic
to an opcode or an input parameter. The purpose of this is to
allows similar instructions or functions to be declared
in one macro. The name must be exported with trailing asterisk

<p>
This example from a PowerPC definition shows
an exported $name label providing an
entry point and latent instruction code value
to $proc macro p. 


<p>
In this example the instruction layout i$4 is filled first with 
a 6-bit opcode p(0, 0). That is the latent value on the $name line.
There follow by a 5-bit register tag p(1, 1), a 5-bit index register
which may be unspecified and zero, and a 16-bit storage operand address p(1, 2). 


<div	style="color:A0A0A0">
	<blockquote>
	The optional index or pointer register may in source syntax be parenthesised at the end of the
	storage operand identifier
	<pre>

		stw     r2, address(R15)

	</pre>

	<p>
	ppc_603.def also accepts masmx native syntax which is typed
	<pre>

		stw	r2, address, r15

	</pre>
	<p>
	The parenthesed index name is extracted with a function call <b>.f\p(1, 2)</b>
	</blockquote>
	</div>

PowerPC load and store instructions share a $form and a $proc and each have a $name 

<pre>


i$4     $form   6, 5, 5, 16

.f*     $func
	$return .f(1, 1)
	$end

p       $proc

lwz*     $name   32
lwzu*    $name   33
lbz*     $name   34
lbzu*    $name   35
stw*     $name   36
stwu*    $name   37
stb*     $name   38
stbu*    $name   39
lhz*     $name   40
lhzu*    $name   41
lha*     $name   42
lhau*    $name   43
sth*     $name   44
sthu*    $name   45
lmw*     $name   46
stmw*    $name   47
lfs*     $name   48
lfsu*    $name   49
lfd*     $name   50
lfdu*    $name   51
stfs*    $name   52
stfsu*   $name   53
stfd*    $name   54
stfdu*   $name   55
	
	i$4     p(0, 1), p(1, 1), .f\p(1, 2), p(1, 2)
	$end

</pre>
<p>
An assembly using this definition:
<pre>


MASMX/24592 1r1X
name.msm 5
LTERM=#
CONT_CHAR=
STERM=.
*EOF*  :                        2: 
  :                        3: from    .equ    $ee84
  :                        4: to      .equ    0xc008
  :                        5: 
00:00000000 80C0EE84      +6         lwz     r6, from
00:00000004 98CEC008      +7         stb     r6, to(r14)
00:00000008 4E800020      +8         blr
*EOF*:$(00):00000000:0000000C 
Object Code 76 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
The name lwz has been recognised and 32 has been placed in the
upper 6 bits of the instruction on line 6. The name stb has been
recognised and 38 has been placed in the upper 6 bits of the
instruction on line 7.


<a      name="nop"/>
<h2>8.32: $nop               Do Nothing [+ comment]</h2>
                  
<p>
$nop directive can introduce a comment without using the comment character
<pre>

	$nop	comment-text

</pre>
<p>
Header files included in assemblies of differing syntax can use $nop directive
instead of $lterm character to allow code to be commented.
<p>
$lterm (comment character) may have a different value (for example # ; .)
in each of many assemblies.
<p>
$nop may also annul any unused directives in legacy code, for example:
<pre>

preset  equ,$directive     $nop


</pre>
<a	name="note">
<h2>8.33: $note              Informative Diagnostic, Not Error</h2>   

<p>
$note causes a message to be displayed without causing the 
assembly to fail.

<p>
The push/pop macro nn the definition "8051.def" alerts the
developer to a risky practice with a $note message:
<pre>

p       $proc
push    $name   0c0        
pop     $name   0d0
	$if     p(1,#1)++($t(p(1,1))=POINTER$)++($t(p(1,1))=REGISTERS$)
	  $flag PUSH/POP Direct Addressed IRAM Location or SFR Only
	$else
	  $if $t(p(1,1))=RREGISTERS$
	    $note Caution: RRegister bank might not be at address 0..7
	  $endif
	  i$mova_direct   $n, p(1,1)
	$endif
	$end

</pre>
<p>
There is also a $flag in the macro which marks the assembly in error
if the operand is illegal.

<p>
$note displays on the second assembly pass.


<a      name="notef">
<h2>8.34: $notef             First Pass Informative Diagnostic</h2>

<p>
$notef is similar to $note, except it displays on the first
assembly pass.


<a      name="octal">
<h2>8.35: $octal             Set Binary Notation to Octal</h2>         


<p>
$octal causes input number strings with leading zero to be
interpreted as octal and listings to be octal. 
<pre>

	$octal

</pre>
<p>
The default rule is hexadecimal. Each assembly pass starts in leading-zero-hexadecimal notation

<p>
See also <a href="#hex">8.22: $hex</a> directive

<p>
See also <a href="#describe1">10.1: Establishing Your Syntax</a>,
<a href="#suffix_directive">8.51: $suffix Directive</a>,
<a href="#notate2">4.2.2.1: Number Strings</a>,
<a href="#option_c">command line option flag -c</a> and <a href="#option_m">-m</a>


<a      name="path">
<h2>8.36: $path      	     Alter Include Path</h2>

<p>
<b>$path</b> sets a text value to which is prefixed to the
filename arguments of <b>$include</b> directive.

<pre>

	$path		../math_libs
	$include	math_libs
	$path		../network/ipv4
	$include	netservice.def
	$path		../electromechanical/stepper_type5
	$include	stepper5
	$path
	$include	this_application

</pre>
<p>
Finally the directive <b>$path</b> without an argument cancels
the path prefix, and the next includes are relative to the current
directory.

<p>
Note that Microsoft operating systems recognise the path separator <b>/</b>
as well as <b>\</b> when programs make file-open calls. Pathnames with <b>/</b>
separator therefore work on all developer platforms

<a      name="plist">
<h2>8.37: $plist             Set Depth for Listing Macro Expansion</h2>


<p>
$plist sets the subassembly recursion level to which macro text will
be listed. The default is 0, which means no macro expansions are 
listed.
<pre>

	$plist  3

</pre>
<p>
causes source to be listed to two nested levels of subassembly or
macro expansion, but only if option flag <b>-p</b> or <b>-q</b> is asserted. 

<p>
If <b>-p</b> is off, no <b>$proc</b> text listed. 
<p>
If <b>-q</b> is off, no <b>$func</b> text listed.

<p>
If <b>-r</b> is on, <b>$proc</b> and <b>$func</b> text is listed
on the first assembly pass if $plist is high enough.
This for problems in macro language which
do not allow the second pass to be reached. Otherwise nothing is
ever listed until the second assembly pass.

<p>
Generated code is listed according to the <b>$list</b> level
and <b>-l</b> option, not the <b>$plist</b> level and <b>-pq</b> options.


<a      name="proc">
<h2>8.38: $proc              Declare Procedural Macro</h2>
   

<p>
The head of a procedural macro. $proc must have a label, but the
label need not be unique. If the label on the $proc image is not
unique it may not be promoted*, the macro body must contain $name entry
points which have unique labels and which are made visible*.

<p>
A $proc line must be matched with a $end line:
<pre>

aname   $proc
visible_name*  $name   value        
	.
	.
	$end

</pre>
<p>
When a promoted* label of $proc or $name is in the command
field of a source line, the macro is subassembled.

<p>
This sample program assembles instructions <a style="color:blue">ljmp lcall reti nop ret</a>
 
<pre>

$ masmx forjoy -ln
MASMX 7r3
3/forjoy.msm
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*
  :                            1:         $include        8051.def
  :                            2 
00:0000 0203EB                +3         ljmp    for.joy
  :                            4         $res    1000
  :                            5 
00:03EB 1203EF                +6 for.joy lcall    for.more
00:03EE 32                    +7          reti
  :                            8 
  :                            9 for.more 
00:03EF 00                    +10         nop
00:03F0 22                    +11         ret
*EOF*
:$(00):0000:03F1 :$(01):0400:0400 


</pre>
<p>
The two $proc macros which generate these five instructions are shown
in a more expanded assembly below

<p>
Both $proc macros shown are called p. The macros reference actual
parameters as p(x, y), but are called by their exported $name
labels <a style="color:blue">ljmp lcall reti nop ret</a>

<p>
Line 166 is the bit layout template or $form for long jump instructions.

<p>
Line 416 advertises the $name label lcall* with a latent value
of 18. This value may be retrieved as parameter p(0, 0)
or the masmx internal function <b>$n</b>

<p>
Line 417 advertises the $name label ljmp* with a latent value 2,
which can be retrieved as parameter p(0, 0) or <b>$n</b>

<p>
Line 418 generates a 24-bit instruction with the callname latent
<b>$n</b> or p(0, 0) in the first 8 bits

<p>
The second field of the i$long_jump form is given the value of the
first actual argument subfield,  p(1, 1)

<p>
Line 419 ends the $proc macro

<p>
Line 523 starts another $proc macro called p

<p>
Line 524: callname nop has a latent value 0

<p>
Line 525: callname ret has a latent value 34

<p>
Line 526: callname reti has a latent value 50.

<p>
Line 527 generates one 8-bit data word with latent callname value
$n or p(0, 0)

<p>
Line 528 ends of the macro.

<p>
The line numbers step down because they are line numbers
of the main file, not the include file which is longer

<p>
Line 3 is a long jump to location for.joy

<p>
Line 4 is a buffer of 1000*address quantum, = 1000 bytes.

<p>
Line 6 is for.joy which is 1000+3 bytes beyond the start
of the assembly. for.joy calls for.more

<p>
Line 10 is a 8051 hardware nop instruction (not a $nop directive)

<p>
Line 11 is a return instruction

<p>
Line 7 is an interrupt return instruction
<pre>


MASMX/24592 1r1X
forjoy.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        165:         $list   2
  :                        166: i$long_jump     $form   8,16
  :                        167:         
  :                        414:         $list   2
  :                        415: p       $proc
  :                        416: lcall*  $name   012
  :                        417: ljmp*   $name   002
  :                        418:         i$long_jump     $n, p(1,1)
  :                        419:         $end
  :                        420:         
  :                        522:         $list   2
  :                        523: p       $proc
  :                        524: nop*    $name   0        
  :                        525: ret*    $name   022
  :                        526: reti*   $name   032
  :                        527:         +       $n:s
  :                        528:         $end
  :                        529:         
  :                        2: 
00:0000 0203EB        +3         ljmp    for.joy
  :                        4:         $res    1000
  :                        5: 
00:03EB 1203EF        +6 for.joy lcall    for.more
00:03EE 32            +7          reti
  :                        8: 
  :                        9: for.more 
00:03EF 00            +10         nop
00:03F0 22            +11         ret
*EOF*:$(00):0000:03F1 :$(01):0400:0400 
Object Code 89 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
A new layer or frame of the label table is constructed in
subassembly, and removed at the end of subassembly.<br>Labels
declared in the macro expansion are not visible to more 
inclusive assembly layers except by design.<br>Labels are 
unique within their subassembly layer (macro depth). 

<p>
Where more than one assembly layer has declared a label
with the same name,<br>references resolve to the synonym
at the most deeply nested macro level

<p>
The subassembly has in scope all the labels that currently exist,
and can set labels at less deep macro depth than itself,<br>
but on reference only sees the synonym closest in depth to itself

<p>
To make a label more permanent than the macro expansion 
which declares it, asterisk(s) are suffixed to the label,<br>
one for each subassembly layer to which the label is promoted:
<pre>

mymacro*   $proc
	.
	.
"label1:mymacro(1,1)"*
"labelx:mymacro(1,1)"**
labely  .
	.
	$end

Start_of_Assembly
	.
	.
	mymacro   athing
	.
	.

</pre>
<p>
In the above example, "label1:athing" is visible to the whole
assembly, because it has one asterisk. 

<p>
Actual parameters can be included in labels names in quotes.

<p>
"labelx:athing" is visible to the whole assembly and to external linkage. 
It has one more asterisk than the macro depth.

<p>
"labely" is not visible outside the macro expansion.


<p>
If a $proc macro has forward references to local labels, the macro must
be scanned twice on the second assembly pass.<br>These $procs are called
two-pass $procs. They are marked by an asterisk argument of asterisk *
on the $proc line:
<pre>


PUSHACC* $proc	*
	PUSH    ACC
	MOV     stackcheck,SP
	JB      stackcheck.7, StackOk
	JMP     ColdBoot
StackOk:
	$end

</pre>
<p>
The label StackOK is not exported from the macro expansion. Therefore
it stopped existing when the macro exited on the first assembly pass.<br>
The macro needs a preliminary pass on the second main assembly pass.
See also  <a href="#u2passproc">10.2.2.6: The Two-pass $proc</a>

<p>
A $proc line can have a location counter argument in syntax $(n)
as first argument or second argument after the 2-pass flag:
<pre>

p	$proc	$(20)
nomen*	$name
	.
	.
	$end

macby*	$proc	* $(50)
	.
	.
	$end

</pre>
<p>
Then code generated in the proc is in the named segment, and
location counter at the time of calling is switched back after.

<p>
If any line in a $proc contains a label of * asterisk alone,
the label on the $proc call line is reassigned as if it
appeared where the asterisk is.

<p>
In this assembly, "buffer1" and "buffer2" are declared in 
location counter 1. There is no break between the instructions
generated in location counter 0.
<pre>


MASMX/24592 1r1X
var.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        125:         $list   2
  :                        126: var*    $proc   $(1)
  :                        127: *       $res    var(1,1)
  :                        128:         $end
  :                        677:         $list   2
  :                        678: $(1:1024)
  :                        679: $(0:0)
00:0000 020006        +2         jmp     here
00:0003 020009        +3         jmp     there
  :                        4: buffer1 var     1024
  :                        5: buffer2 var     512
00:0006 900400        +6 here    mov     dptr, #buffer1
00:0009 900800        +7 there   mov     dptr, #buffer2
  :                        8: 
*EOF*:$(00):0000:000C :$(01):0400:0A00 
Object Code 92 Bytes: 0 Errors: 0 Undefined Labels


</pre>

<a      name="pushrel">
<h2>8.39: $pushrel	Acquire a Relocation Tuple from a Superword</h2>

<p>
$pushrel directive is used in linking assemblies
<pre>

parameter_label		$pushrel	relocation_clause

</pre>
<p>
A general explanation of <a href="#map">$map</a> macro and the position
within it of <b>$pushrel</b> is give is given a few lines below

<p>
See also <a href="#map_ppc">9.2.2 masmx Linking in Principle</a>

<p>
$pushrel scans a relocation clause in Text Encoded Binary input and tables the
relocation attributes as the $equf label named on the $pushrel line

<p>
$map macro assigns each relocation clause in a superword successively
to $pushrel directive

<p>
This superword from a 64-bit PowerPC relocatable has one relocation clause
and two words of code. The relocation clause requests the segment base of
location counter 36 to be added to all 64 bits of the two code words
<pre>

	(24)40:0000000000000000

</pre>
<p>
This superword from a 32-bit PowerPC link has two relocation clauses and one word of code
<pre>

	[0001:FFFFFFB4/*02]18*/02+:(-01:FFFFFFB4/*02)18*/02+:4BFFFFB5

</pre>

The first relocation clause requests an external name to be added to the address field
of a relative jump instruction and the sum shifted right two positions into bits 25..2
of the instruction. The second clause requests the base address of the segment containing
the instruction to be subtracted from the intermediate sum and shifted right two positions
into bits 25..2 of the instruction

<p>
The line containing $pushrel has a label

<p>
$pushrel gives this label the type $equf. Macro Language can now use
it as a list containing three or five values.

<p>
The address value, subfield 1 of the $equf, is the relocation
base to be applied.

<p>
These attributes can be retrieved:
<pre>

parameter_label\1 	is the relocation value to be added to the
			superword data (i. e. to the code)

parameter_label\2	the number of bits in the target field to
			which the relocation value is added

parameter_label\3	is the left shift scale at which the relocation
			value is added to the superword data

_______________________________________________________________________
Parts \4 and \5 present if the target field is split or right-shifted
_______________________________________________________________________

parameter_label\4	is the addend value if it needed to be encoded
			separately in Text Encoded Binary.

			This offset value is normally in the superword
			data, but if assembly macro language shifted
			a relocatable value right: 

			part \4 contains the unrelocated and unshifted
			value;

			and part \5 contains the right shift count:

parameter_label\5	right shift count encoded as a negative integer:
 			to be applied to the separately delivered
			offset in part \4 after it has been relocated


</pre>
<p>
When the absolute address space is 32 bits or less, the relocation
value is the address part of the $pushrel label. This is the same
as part \1 of the pushrel label, except that \reference gets sign-extended

<p>
The expression
<pre>

	parameter_label\1

</pre>
<p>
would be sign-extended from bit 31, so it is preferable to extract the
address attribute of the $equf identifier as
<pre>

value	$set	parameter_label

</pre>


<a	name="long_absolute"/>
<p>
When the absolute address space is between 33 and 192 bits, the
large relocation value is retrieved with a second $pushrel from
the input binary superword
<pre>

value	$pushrel,$long_absolute	superword

</pre>

<blockquote>
<div	style="color:A0A0A0">

<a name="map"/>
masmx calls a developer-supplied macro <b>$map</b> with a line of text-encoded
binary as arguments. The space-separated superwords contain single or multiple
words of code and may be prefixed with colon-separated relocation clauses


<p>
A <b>$map</b> macro consists of an outer loop which successively submits superwords
from the line of Text Encoded Binary to an inner macro, and of an inner
macro which caches the code part of the superword, and submits each
relocation tuple attached to it to a third macro where the relocation request
is applied to the code. The innermost macro containing $pushrel is here
called <b>relocate</b>
<pre>

p	$proc
"$map"*	$name

p	$proc
superword* $name
clauses	$set	p(1,1:)	. The relocation clauses in TXO are substrings
			. The last substring is the code

data	$set,$binary	p(1,1:clauses)	. cache the code = last substring


clause	$do	clauses-1,	relocate	p(1,1:clause)

	load,$bits	data	. $bits is automatic from $set,$binary
				. write the code

	$end	. of SUPERWORD
</pre>
</div>
<pre>
p	$proc
relocate* $name

rel_params $pushrel	p(1, 1)

value	$set	rel_params\1	. relocation value to add

bits    $set    rel_params\2	. target field size in bits
scale   $set    rel_params\3	. shift distance from low-order bit of superword
offset  $set    rel_params\4	. intermediate value for shift / truncation
descant $set    label1\5	. -shift count = right shift count

limit   $set    1*/bits
mask    $set    limit-1
unmask  $set    ^(mask*/scale)

	$do	ENVIRONMENT=64,;
value	$pushrel,$long_absolute	p(1, 1)

	$if	descant<0
field	$set	value+offset
	$info,$range_check1	field
	$info,$offset		field	. save a new offset clause
					. if the target is still relocatable
field	$set	field*/descant	. this shift left is shift right algebraic. descant < 0
	$else
field	$set	value+(($data/*scale)**mask)
	$info,$range_check1	field
	$endif

"$data"* $set	((field**mask)*/scale)++($data**unmask)

.  label data* must be promoted in order to be the label "data" known
.  to the calling macro and not a new "data" only known in this macro

	$end	. of RELOCATE
</pre>
<div	style="color:A0A0A0">
<pre>
index	$do	p(),	superword	p(index, 1)
	$end	. of $map

</pre>
</div>
</blockquote>

<p>
If a relocation clause does not go absolute at $pushrel, $pushrel also tables a relocation tuple internally.

<p>
This relocation tuple may need adjusting with $info directive, because
a new in-segment displacement may have been summed.

<p>
$load outputs all relocation tuples not absolutely resolved as new
relocation clauses in the output Text Encoded Binary.

<p>
Output code generation, of which $load is an example, forwards
unresolved relocation tuples. All internally stacked  relocation
tuples have been actioned and are removed.

<p>
See <a href="#file_formats">9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools</a>


<a      name="quantum">
<h2>8.40: $quantum           Select Bit Size of Addressed Object</h2>

<p>
$quantum must be set to 8 for target machines which address bytes.

<p>
$word directive also sets $quantum and $awidth to same the value as $word.
If the address quantum is not the word size, $quantum must follow $word
<pre>

	$word   32
	$quantum 8

</pre>


<a      name="quote">
<h2>8.41: $quote            Select Character for Bounding Text Strings</h2>


<p>
Sets the quote character
<pre>

	$quote	''''

</pre>
<p>
Default is " character.

<p>
When the quote character is encountered in the instruction field,
or in a field of a  $form, it bounds a text string:
<pre>

	"Text Constant"
	.
	.
descriptor $form        16, 48
	descriptor      VALUE, "Label"


</pre>
<p>
If quote character appears in column one, or in an expression, it bounds a
label. This allows labels beginning $ to be declared.
<pre>

MASMX/24592 1r1X
dollar1.msm 5
*EOF*  :                        1:         $word           16
  :                        2: $(6:06000)
  :                        3: "$handle"
  :                        4:         $res    10
06:600A 000A          +5         +       $-$handle
  :                        6: 
*EOF*:$(06):6000:600B 
Object Code 38 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
When -M Flag (Motorola Hex) is on, labels beginning $
can still be understood in expressions if they have quotes
around them:
<pre>

MASMX/24592 1r1X
dollar.msm 5
CONT_CHAR=
LTERM=;
STERM=.
*EOF*  :                        1:         $word           16
  :                        2:         $cont_char       0       . No Continuation
  :                        3:         $lterm          ';'     . comment is ;
  :                        4:         $sterm          '.'     ; sub.string is .
  :                        5:         $set_option     "m"     ; Motorola Hex
  :                        6: $(6:06000)                      ; Locator 6, base 24K
  :                        7: "$handle"                       ;
  :                        8:         $res    10              ; Buffer 10 Words
  :                        9: .locator $equ,"$function" "$"   ; Alias Location Counter
06:600A 0010          +10         +       .locator-"$handle"+$6
  :                        11: 
*EOF*:$(06):6000:600B 
Object Code 38 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
The "legal" character set for labels is       
<pre>

		$ 
		A..Z 
		a..z 
		0..9 
		@ 
		! 
		? 
		_ (underscore)

</pre>
<p>
and the currect $sterm which is default colon but often
set to period.

<p>
Labels bounded with $quote may contain characters which are not 
otherwise included in labels: 

<pre>

$ masmx -l
MASMX 7r2
0/-INPUT>>
	$word	32
	$quantum 8
$(5:050000)
index   $do	9,	+	100-index
"unconventional \ rough { label"
	$res	12
	+	"unconventional \ rough { label"
	$end
  :                            1  $word 32
  :                            2  $quantum 8
  :                            3 $(5:050000)
05:00050000 00000063          +4 index $do 9, + 100-index
05:00050004 00000062          +4 
05:00050008 00000061          +4 
05:0005000C 00000060          +4 
05:00050010 0000005F          +4 
05:00050014 0000005E          +4 
05:00050018 0000005D          +4 
05:0005001C 0000005C          +4 
05:00050020 0000005B          +4 
  :                            5 "unconventional \ rough { label"
  :                            6  $res 12
05:00050030 00050024          +7  + "unconventional \ rough { label"
  :                            8  $end
:$(05):00050000:00050034 
-INPUT>>: object code 148 bytes: 0 errors: 0 undefined labels

</pre>
<p>
It's also possible to declare a label which begins with a decimal
digit, but it couldn't be referenced without $quote:
<pre>

MASMX/24592 1r1X
nuri.msm 5
*EOF*  :                        1: $(4:0480)
  :                        2: 123OLeary
04:000480 000481        +3         +       "123OLeary"+1       
*EOF*:$(04):000480:000481 
Object Code 48 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
If quote character is changed to apostrophe, it cannot be used to bound
labels in expressions. Apostrophe has a fixed meaning in expressions.
The expression gets the bit-pattern value of the contained characters
in the current size and character code, by default 8-bit ASCII.

<p>
In this assembly an unconventional label is declared sucessfully but
can not be referenced. Reference to 'unconventional \ rough { label'
generates a 192-bit integer containing the character values
<pre>

	'entional \ rough { label'

</pre>
Truncation is at masmx maximum integer size 192 bits
<pre>

$ masmx vr -lx
MASMX 7r2
3/vr.msm
QDELIM='
  :                            1  	$quote	''''
  :                            2 
  :                            3 	$word 32
  :                            4 	$quantum 8
  :                            5 $(5:050000)
05:00050000 00000063          +6 index	$do	9,	+	100-index
05:00050004 00000062          +6 
05:00050008 00000061          +6 
05:0005000C 00000060          +6 
05:00050010 0000005F          +6 
05:00050014 0000005E          +6 
05:00050018 0000005D          +6 
05:0005001C 0000005C          +6 
05:00050020 0000005B          +6 
  :                            7 'unconventional \ rough { label'
  :                            8 	$res 12
05:00050030 656E74696F6E616C205C20726F756768207B206C6162656C
                              +9 	+	'unconventional \ rough { label'
  :                            10 	$end

  :

  :

vr.msm=0<00000003
INDEX=00000009
UNCONVENTIONAL \ ROUGH { LABEL=$05:00050024
:$(05):00050000:00050048 
vr.msm: object code 188 bytes: 0 errors: 0 undefined labels


</pre>
<h3>8.41.1: Quoted Strings and Labels within Macro Expansions</h3>


<p>
When labels are in quotes in a macro, the quotes can
contain argument paraforms which are replaced with
actual parameters.


<p>
An expression token in quotes is a label. Macro parameters may be
joined inside quotes with extra symbols to synthesise new labels
<pre>


MASMX 7r2
3/quo.msm
*EOF*
  :                            1 p*       $proc
  :                            2 "name:p(1,1)"
  :                            3         +       "name:p(1,1)"+0c0000
  :                            4         $snap    2
  :                            5         $end
  :                            6 $(0:64)
00:000040 0C0040              +7         p       yes
NAME:YES=$00:000040
*EOF*
:$(00):000040:000041 
quo.msm: object code 44 bytes: 0 errors: 0 undefined labels

</pre>
<p>
If the value of $quote is apostrophe, a 'label' in 
column 1 can be constructed and defined, catenating 
parameters with other symbols; 

<p>
however 'characters between apostrophes' in an 
expression have  their own immediate value without 
substitution, +'label'=0000006c6162656c. 

<p>
Therefore when $quote is an apostrophe or 0x27, 
labels may only be included in expressions without 
surrounding $quote.<br>Macros can synthesise and export new labels
in apostrophes but cannot reference them
<pre>

MASMX 7r2
3/quo1.msm
QDELIM='
*EOF*
  :                            1         $quote  027
  :                            2 p*      $proc
  :                            3 'name:p(1,1)'
  :                            4         +       'name:p(1,1)'+0c0000
  :                            5         +       name:no+0a0000
  :                            6         $snap    2
  :                            7         $end
  :                            8 $(0:64)
00:000040 00006E616D65466E6F  +9         p       no
00:000043 0A0040              +9 
NAME:NO=$00:000040
*EOF*
:$(00):000040:000044 
quo1.msm: object code 63 bytes: 0 errors: 0 undefined labels


</pre>
<p>
The quote character in the command or instruction position always 
means a text string, and within a macro, parameter substition
takes place. 
<pre>

MASMX 7r2
3/quo3.msm
*EOF*
  :                            1 p*      $proc
  :                            2 "name:p(1,1)"
  :                            3         "name:p(1,1)"
  :                            4         $snap    2
  :                            5         $end
  :                            6 $(0:64)
00:000040 6E616D653A5365655F446174613F20
                              +7         p       See_Data?
NAME:SEE_DATA?=$00:000040
*EOF*
:$(00):000040:000045 
quo3.msm: object code 68 bytes: 0 errors: 0 undefined labels


</pre>

A second example shows actual parameter substitution in a string
whatever symbol is used for a quote mark, here apostrophe

<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$quote	''''

p*	$proc
QDELIM='
	'p(1, 1)'
	'"p(1, 1)"'
	$end

	p	abc
	p	xyz

	$end
  :                            1  $quote ''''
  :                            2 
  :                            3 p* $proc
  :                            4  'p(1, 1)'
  :                            5  '"p(1, 1)"'
  :                            6  $end
  :                            7 
00:000000 616263              +8  p abc
00:000001 226162632220        +8 
00:000003 78797A              +9  p xyz
00:000004 2278797A2220        +9 
  :                            10 
  :                            11  $end
:$(00):000000:000006 


</pre>

<p>
A field of a $form all in quotes also means a string, and in a 
macro expansion, parameter substitution takes place:
<pre>

MASMX 7r2
3/quo4.msm
*EOF*
  :                            1 f       $form   16, 104
  :                            2 p*      $proc
  :                            3 "name:p(1,1)"
  :                            4         f       -6, "!p(1,1)!"
  :                            5         $snap    2
  :                            6         $end
  :                            7 $(0:64)
00:000040 FFFA215365655F446174613F212020
                              +8         p       See_Data?
NAME:SEE_DATA?=$00:000040
*EOF*
:$(00):000040:000045 
quo4.msm: object code 68 bytes: 0 errors: 0 undefined labels


</pre>
<p>
If the "!p(1,1)!" is meant to be a label and not the string of its
character values, adding a unary sign will change the string to
an expression and the label will be searched:
<pre>

	f	-6, +"!p(,1 1)!"

</pre>

<a      name="record">
<h2>8.42: $record</h2>
<h3>8.42.1: $record		bit-aligned data structures</h3>


<b>$record</b> directive heads a structure of bit-aligned fields and must have a label
<pre>

record1	$record	[<i>values</i>]
field1	9
field2	11s
	$root

</pre>
Where <b>$record</b> structures are nested, a new <b>$record</b> structure
starts at the bit position which the immediately preceding <b>$record</b>
srtucture reached.<br>

See also <a href="#bstradata">5.2.3: Bit-Aligned Structures</a>

<a      name="record_b">
<h3>8.42.1: $record,$branch	bit-aligned structure overlay</h3>

<b>$record,$branch</b> heads an overlaid or redefined structure of bit-aligned
fields. All successive <b>$record,$branch</b> structures start at the same
bit position
<pre>

recordA	$record,$branch	[<i>values</i>]
?	$do	4,triplet(?)	3u
	$root
recordB	$record,$branch	[<i>values</i>]
?	$do	3,quartet(?)	4s
	$root

</pre>
See <a href="#record_overlay">5.2.3.3: Overlaid Structures $record,$branch</a>


<a      name="res">
<h2>8.43: $res               Declare a Storage Buffer</h2>             

<p>
$res declares a buffer, i.e. it advances the current location
counter.

<p>
By default no code is loaded in $res storage

<p>
<b>-Z</b> option causes the buffer to be zero-filled instead

<p>
$res intervals in $proc structures generated as literals
are always zero-filled


<pre>

$(1:1024)
buffer_name     $res    100
buffer_2        $res    40

</pre>
<p>
has the effect that "buffer_name" has a value of 1024,
and represents a location 0400 in counter 1.

<p>
"buffer_2" has a value of 1124 and represents location 0464 in counter 1. 

<p>
If address quantum is less than word size, it's sometimes necessary
to align after $res.
<pre>

MASMX 7r2
3/linitup.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3 
  :                            4 line_up* $proc
  :                            5 granule $set    line_up(1,1)    
  :                            6         $res    ($+granule-1**-granule)-$
  :                            7         $end
  :                            8 
  :                            9 $(12:0780000)
  :                            10 first_buffer    $res    17
  :                            11         line_up 4
  :                            12 second_buffer   $res    19
  :                            13         line_up 4
  :                            14 end_buffers
0C:00780028 00780000          +15         +       first_buffer
0C:0078002C 00780014          +16         +       second_buffer
0C:00780030 00780028          +17         +       end_buffers
*EOF*
:$(0C):00780000:00780034 
linitup.msm: object code 72 bytes: 0 errors: 0 undefined labels

</pre>

<a	name="return"/>
<h2>8.44: $return            Return a Value from $func..$end</h2>

<p>
$return may be used to jump out of any macro <b>$proc..$end</b>
or <b>$func..$end</b>

<h3>8.44.1: Return a value from a $func Macro</h3>
Directive $return delivers the value of its argument

<p>
The return value is used in an expression which invokes a <b>$func</b> macro

<p>
The function HIGH in the following example returns the upper
8 bits of a 16-bit value:
<pre>

MASMX/24592 1r1X
high.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        628:         $list   2
  :                        629: high*   $func
  :                        630: v       $set    high(1,1)        
  :                        631:         $return v/*8
  :                        632:         $end
  :                        2: 
  :                        3: 
  :                        4: 
00:0000 00AA          +5         +       high(170*256)
*EOF*:$(00):0000:0002 :$(01):0400:0400 
Object Code 59 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Functional results are 192 bits.
 
<a      name="preturn"/>
<h3>8.44.2: Return from a $proc Macro</h3>

<b>$return</b> directive leaves a $proc macro before the <b>$end</b> image

<a	name="root"/>
<h2>8.45: $root              Foot of Structured Name Space</h2>

<p>
$root is the end of a structured name space.
See <a href="#wstradata">5.2.2: Word-Aligned Structures $tree / $branch..$root</a>,
<a href="#tree">8.54: $tree</a>, <a href="#record">8.42: $record</a>, <a href="#branch">8.4: $branch</a>,
<a href="#bstradata">5.2.3: Bit-Aligned Structures</a>



<a      name="set"/>
<h2>8.46: $set               Assign Reassignable Value to Label</h2>


<p>
$set is a temporary equate. A label may be set many times, and
$set is actioned on both first and second assembly passes.

<p>
The label may be set to any value which can be expressed
in 192 bits.
<pre>

label   $set    262144*/160
label2	$set	262.144e+3*/160

</pre>
<p>
Subcommand values up to 192 decide the size of a floating value cached
in a label with $set directive. This decides in turn the exponent and
mantissa sizes of the value and therefore the rounding position
<pre>

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
float48 $set,48 0.9  
float24	$set,24	0.9
float	$set	0.9
	$end
  :                            1 float48 $set,48 0.9
  :                            2 float24 $set,24 0.9
  :                            3 float $set 0.9
  :                            4  $end
float48=400E66666667
float24=40E667
float=400000E66666666666666667
-INPUT>>=0<000000

</pre>
Exponent field size is assigned to each floating number size in words
with directive <a href="#characteristic">8.6: $characteristic</a><br>
See also <a href="#fdemens2">11.2.2: Exponent Field Size</a>

<p>
Subcommand <b>$binary</b> is used with $set directive.
See <a href="#map_ppc">9.2.2: masmx Linking in Principle</a>
and <a href="#pushrel">8.39: $pushrel</a> directive



<a      name="set_option"/>
<h2>8.47: $set_option</h2>

<h3>8.47.1: Set Option Flags</h3>

<pre>



	$set_option     "a..zA..Z"

</pre>
<p>
sets the option flags which can otherwise be set on the command line.<br>

<p>
Flags <b>-ksy</b> are only actioned on the command line,
not via <b>$set_option</b> directive

<pre>

       > masmx [input] [output] -a..zA..Z

</pre>
<p>
If the command line is
<pre>

       > masmx source1 -klm

</pre>
<p>
and source1.msm contains 
<pre>

	$set_option     "pno"

</pre>
<p>
The total effect is the same as
<pre>

       > masmx source1 -klmnop

</pre>
<p>
The option letters are case significant.
<b>-QZ</b> are different options from <b>-qz</b>


<a	name="set_interact"/>
<h3>8.47.2: Interaction of Run Options and $list / $plist Directives</h3>


<p>
<b>$list</b> and <b>$plist</b> directives interact with options
<b>-lpqr</b> in these ways:
<pre>

	$list   0

</pre>
<p>
prevents source or generated code from printing at all. Labels declared
or imported while <b>$list</b> is zero are also not listed or exported.
see Section 8.28: <b>$list 0</b>, masking names from list/export
<pre>

	$list   1

</pre>
<p>
prints the main file and generated code if option <b>-l</b> is on.
The default value is 1.

<p>
The larger the <b>$list</b> value, the deeper nested includes are listed.
If flag <b>-l</b> is off, only summary information is listed.

<p>
If flag <b>-w</b> is on, assembly is silent and summary information
is not listed.

<p>
<b>$plist</b> directive interacts with <b>-pqr</b> options:        
<pre>
	
	$plist  0

</pre>
<p>
prevents all macro expansion from printing.
<pre>

	$plist  2

</pre>
<p>
displays <b>$proc</b> macro language one macro deep if <b>-p</b> is on, and
<p>
displays <b>$func</b> macro language one macro deep if	<b>-q</b> is on.

<p>
The larger the value of <b>$plist</b>, the deeper nested macro language
is displayed.

<p>
<b>-r</b> flag allows macro language up to <b>$plist</b> depth to be displayed
on the first assembly pass. This is for investigating serious problems
in macro language which prevent a second assembly pass. Otherwise
nothing is listed until the second assembly pass.

<p>
The option values are listed in Section 3.1: The Command Line



<a      name="snap"/>
<h2>8.48: $snap              List Label Table</h2>


<h3>8.48.1: Load Order or -y Sorted</h3>
$snap lists labels. Default behaviour is to list the fixed part 
of the label table in load order,<br>
or sorted if <b>-y</b> flag has been opted. $snap may take an argument
<pre>

	$snap	[<i>expression</i>]

</pre>

<h3>8.48.2: Dynamic Labels Table</h3> 
$snap lists the fixed part of the label table unless the argument
has the value 2.<br>$snap 2 is placed inside macro text to list dynamic labels
<pre>

macroname$* [$proc|$func]
	.
	.
	$snap   2
	.
	.
	$end

</pre>

<h3>8.48.3: List Labels [and Macro Text></h3>
By default, $snap lists only labels. With the argument 3, $snap lists labels in the<br>
fixed table in load order and if any of flags -pqr is opted, $snap 3 lists macro text
<pre>

	$snap	3

</pre>

<h3>8.48.4: 1st Pass</h3>
$snap is actioned during the second assembly pass, unless it has a subcommand of 1<pr>
$snap,1 is actioned on the first assembly pass
<pre>

	$snap,1		[<i>argument</i>]

</pre>


<a      name="sterm"/>
<h2>8.49: $sterm             Change the Substring Sentinel Character</h2>

See also <a href="#argument_ref">4.2.2.5 Macro Parameters</a>

<pre>

	$sterm	<i>expression</i>

</pre>
<p>
The substring character is changed to the value of <i>expression</i>
The substring character works as

	<blockquote>
	a character in a label, for example <b>move.w</b>. See <a href="#labels">4.1: Labels</a><br><br>

	the divider between sub:strings in macro actual parameters.
	See <a href="#dotted">4.2.2.5: Macro Parameter Reference</a><br><br>

	a join in a structured:label. See <a href="#structure">5: Iterated Code and Structured Data</a> <br><br>

	a join in a text string, for example "text":LF:"string"
	See <a href="#strings">4.3.5: Text Strings</a>
	</blockquote>

<p>
The default value of $sterm is colon :

<p>
Macro language for many target syntaxes changes $sterm to .

<p>
Paraform language in macros for retrieving subfields always has the separator :

<pre>

  :                            1  $word 16
  :                            2  $quantum 8
  :                            3
  :                            4 f       $func
  :                            5 "$net_ipv4"* $name
  :                            6
  :                            7 net     $set    0
  :                            8         $sterm  '.'
  :                            9
  :                            10 ?       $do     f(1, 1:),net     $set    net*/8++f(1, 1:?)
  :                            11
  :                            12         $sterm  ':'
  :                            13
  :                            14         $return net
  :                            15         $end
  :                            16
  :                            17
  :                            18 "$netp" $form   32, 16
  :                            19
  :                            20 p       $proc
  :                            21 "$net_socket"* $name
  :                            22         $netp   $net_ipv4(p(1, 1:1)), p(1, 1:2)
  :                            23         $end
  :                            24
00:0000 AC1D07091F90          +25 address_A $net_socket 172.29.7.9:8080
00:0006 AC1D06080017          +26 address_B $net_socket 172.29.6.8:23
  :                            27  $end
:$(00):0000:000C

</pre>

<a	name="store"/>
<h2>8.50: $store	Set Default Output Filename</h2>
<p>
Directive <b>$store</b> sets a default name for the file where the output
text encoded binary is stored. A second filename on the command line
overrides the <b>$store</b> name
<pre>

	$store	<i>filename</i>

</pre>
<p>
The default filename extension is txo
<pre>

	$store	reloca1

</pre>
<p>
is the same as
<pre>

	$store	"reloca1.txo"

</pre>

<a      name="suffix_directive"/>
<h2>8.51: $suffix    Use Suffix for Number String Interpretation</h2> 


<p>
Suffix flags on number strings are supported for Intel-style source code

<p>
$suffix setting can be set to 0, 1 or 2, and the default is 0.
<pre>


	$suffix 0       ; number string notation is not
			; determined by a suffix letter

	$suffix 1       ; suffix letters ..D ..d	= DECIMAL
			;                ..H ..h 	= HEX
			;                ..B ..b	= BIT PATTERN
			;                ..Q ..q ..O ..o =OCTAL
			

			; default is decimal except leading zero = hex

	$suffix 2       ; as "$suffix 1", except default is always decimal.

</pre>
<p>
When $suffix is 1, then a string beginning 0 is interpreted as
hex (or octal if $octal is set ), when there is no actual suffix.

<p>
Default with first digit 1..9 is decimal

<p>
When $suffix is 2, any number string without a suffix is decimal

<p>
Any words suffix [<a style="color:blue">s d l t q p h o</a>]
is after any notation suffix [<a style="color:red">d o q h b</a>] 

<p>
Words suffix [<a style="color:blue">d q h o</a>] needs separation
from a number string with suffix-determined notation

<pre>

$ masmx suffix -lnk
MASMX 7r3
3/suffix.msm
CONT_CHAR=
LTERM=;
*EOF*
  :                            1        $suffix 2
  :                            2        $cont_char 0
  :                            3        $lterm ';'
  :                            4        $word   16
  :                            5        $quantum 8
  :                            6        $floating_point 80
  :                            7        $characteristic 16
  :                            8        $characteristic,64 12
  :                            9
00:0000 007B                  +10       123             ; decimal notation, self-sizing
00:0002 00000000000000000000007B
                              +11       +(123d)h        ; decimal notation, hexaword
00:000E 123D                  +12       123dh           ; hex notation, self-sized
00:0010 00EA                  +13       234             ; decimal notation, self-sized
00:0012 009C                  +14       234o            ; octal
00:0014 009C                  +15       234os           ; single word octal
00:0016 0000009C              +16       234ol           ; octal double word
00:001A 0000001D              +17       01dh:d          ; hex double word
  :                            18
00:001E 401C000000000000      +19       1.5q            ; fraction string, no notation suffix, quad
00:0026 40259502F90000000000  +20       010q*+0ah       ; octal mantissa, hex exponent, default 80 bits
00:0030 40259502F90000000000  +21       8*+10           ; same thing, just testing
00:003A 400007C80000000000000000
                              +22       1.0h*+10b       ; fraction string always decimal, hexaword
  :                            23                       ; but bit-pattern exponent, result = 100
  :                            24
*EOF*
:$(00):0000:0046


</pre>

<p>
See also <a href="#nconstant">4.3.3: Number Constants</a>

<a      name="text"/>
<h2>8.52: $text              Translate Input Text Patterns</h2>

<p>
$text directive is used for syntax translations which cannot
be reached any other way, for example operators which are not the masmx operators:
<pre>

	$text   \ div \/\
	$text   | shl |*/|
	$text   / and /**/

</pre>
A subfunction of value [ 1..8 ] translates search value to corresponding command line value
<pre>

	$text,3	|_COMPASS_POINT|


	+	_COMPASS_POINT		. value assembly command line argument 3

</pre>
Argument list does not include command line strings starting -

<p>
All the <b>$text</b> lines must be placed together in the assembly
with no other directives or code between. Any separated are not  used.

<p>
See also <a href="#describe1">10.1: Establishing your Syntax</a>

<a      name="trace"/>
<h2>8.53: $trace             Display Value</h2>
        
<p>
Directive
<pre>

	$trace	argument

</pre>
<p>
Displays the value of its argument

<p>
To produce $trace on the first assembly pass, a subcommand
of value 1 is added:
<pre>

	$trace,1        ...


</pre>
<p>
When a macro actual argument is an automatic literal, $trace
obtains the literal value and not the literal address


<a      name="tree"/>
<h2>8.54: $tree              Head of Structured Name Space</h2>


<p>
$tree is used to structure a name space containing data or code.
See also <a href="#stradata">5.2: Structured Data and Structured Code Name Spaces</a>

<p>
The structure is ended with $root. The tree must 
have a label:
<pre>

name    $tree
	.
	.
	$root

</pre>
<p>
$tree may be nested to a depth of 8 for a hierarchy of structures.
$tree may be inside a $proc macro or not. If a $tree is inside a
$proc, the label of the $tree may be the inherited label from
the macro call line, for example
<pre>

p       $proc
species $name
*       $tree
many    $do     p(),branch(many)   $res    4
	$root
	$end

</pre>
<p>
In the following assembly, an 8051 controller drives four UARTs
with register files in four address ranges

<p>
30 bytes of code is generated to scan each UART
for input. The unrolled routine controls four structures
without varying a pointer or a counter
<pre>


$ masmx uart -lnx
MASMX 7r3
3/uart.msm
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*
  :                            3 	$list
  :                            4 
  :                            5 LSR_RDR EQU     0       ; Data In Receive FIFO
  :                            6 
  :                            7 serial*  $proc  	$(2)
  :                            8         $res    (($+15)**-16)-$
  :                            9 *       $tree          
  :                            10 rhr
  :                            11 thr     $res    1
  :                            12 ier     $res    1
  :                            13 isr     $res    1
  :                            14 lcr     $res    1
  :                            15 mcr     $res    1
  :                            16 lsr     $res    1
  :                            17 msr     $res    1
  :                            18 spr     $res    1
  :                            19         $root
  :                            20         $end
  :                            21 
  :                            22 '$bit'*	$func
  :                            23 	$do	$bit(1,1:1)<128,	$return (($bit(1,1:1)**31)*/3)++$bit(1,1:2)
  :                            24 	$return	$bit(1,1:1)++$bit(1,1:2)
  :                            25 	$end
  :                            26 
  :                            27 generate* $proc *
  :                            28 Sample:
  :                            29         jb      $bit(FULL.device),leave ; Is there any buffer space?
  :                            30         mov     dptr,#uart(device).lsr  ; Is there data on COM1 input FIFO?
  :                            31         movx    a,@dptr
  :                            32         jnb     $bit(acc.LSR_RDR), Leave; No more so Next UART
  :                            33         mov     dptr,#uart(device).rhr  ; Yes
  :                            34         movx    a,@dptr                 ; Read
  :                            35         mov     dptr,#buffer(device)    ; Find Place in Circular Input Buffer
  :                            36         mov     dpl,write_cursor(device); By Means of the Running Cursor
  :                            37         movx    @dptr,a                 ; Write the Data to XRAM
  :                            38         inc     write_cursor(device)    ; Advance the Input Cursor
  :                            39         mov     a,read_cursor(device)   ; If write starts to equal read
  :                            40         cjne    a,write_cursor(device),Sample ; Is there any more? 
  :                            41         setB    $bit(FULL.device)       ; Stop reading from FIFO to XRAM
  :                            42 leave:       
  :                            43         $end
  :                            44 
  :                            45 
  :                            46 DEVICES equ     128
  :                            47 DATA    equ     1024
  :                            48 TOTAL   equ     4
  :                            49 RTVARS  equ     64
  :                            50 FULL    equ     32
  :                            51 
  :                            52 $(3:RTVARS)
  :                            53 device  $do     TOTAL,write_cursor(device)      $res    1
  :                            54 device  $do     TOTAL,read_cursor(device)       $res    1
  :                            55 $(2:DEVICES)
  :                            56 device  $do     TOTAL,uart(device)              serial
  :                            57 $(1:DATA)
  :                            58 device  $do     TOTAL,buffer(device)            VAR    256
  :                            59 
  :                            60 
  :                            61 $(0:64)
00:0040 20011B                +62 device	$do	TOTAL,	generate
00:0043 900085                +62 
00:0046 E0                    +62 
00:0047 30E014                +62 
00:004A 900080                +62 
00:004D E0                    +62 
00:004E 900400                +62 
00:0051 854082                +62 
00:0054 F0                    +62 
00:0055 0540                  +62 
00:0057 E544                  +62 
00:0059 B540E4                +62 
00:005C D201                  +62 
00:005E 20021B                +62 
00:0061 900095                +62 
00:0064 E0                    +62 
00:0065 30E014                +62 
00:0068 900090                +62 
00:006B E0                    +62 
00:006C 900500                +62 
00:006F 854182                +62 
00:0072 F0                    +62 
00:0073 0541                  +62 
00:0075 E545                  +62 
00:0077 B541E4                +62 
00:007A D202                  +62 
00:007C 20031B                +62 
00:007F 9000A5                +62 
00:0082 E0                    +62 
00:0083 30E014                +62 
00:0086 9000A0                +62 
00:0089 E0                    +62 
00:008A 900600                +62 
00:008D 854282                +62 
00:0090 F0                    +62 
00:0091 0542                  +62 
00:0093 E546                  +62 
00:0095 B542E4                +62 
00:0098 D203                  +62 
00:009A 20041B                +62 
00:009D 9000B5                +62 
00:00A0 E0                    +62 
00:00A1 30E014                +62 
00:00A4 9000B0                +62 
00:00A7 E0                    +62 
00:00A8 900700                +62 
00:00AB 854382                +62 
00:00AE F0                    +62 
00:00AF 0543                  +62 
00:00B1 E547                  +62 
00:00B3 B543E4                +62 
00:00B6 D204                  +62 
  :                            63 
*EOF*
LSR_RDR=00
SERIAL=:P1:(2)0:22
$BIT=:F1:23
GENERATE=:P3:0:24
DEVICES=0080
DATA=0400
TOTAL=04
RTVARS=40
FULL=20
DEVICE=04
WRITE_CURSOR(1)=$03:40
WRITE_CURSOR(2)=$03:41
WRITE_CURSOR(3)=$03:42
WRITE_CURSOR(4)=$03:43
READ_CURSOR(1)=$03:44
READ_CURSOR(2)=$03:45
READ_CURSOR(3)=$03:46
READ_CURSOR(4)=$03:47
UART(1)=$02:0080
UART(1):RHR=$02:0080
UART(1):THR=$02:0080
UART(1):IER=$02:0081
UART(1):ISR=$02:0082
UART(1):LCR=$02:0083
UART(1):MCR=$02:0084
UART(1):LSR=$02:0085
UART(1):MSR=$02:0086
UART(1):SPR=$02:0087
UART(2)=$02:0090
UART(2):RHR=$02:0090
UART(2):THR=$02:0090
UART(2):IER=$02:0091
UART(2):ISR=$02:0092
UART(2):LCR=$02:0093
UART(2):MCR=$02:0094
UART(2):LSR=$02:0095
UART(2):MSR=$02:0096
UART(2):SPR=$02:0097
UART(3)=$02:00A0
UART(3):RHR=$02:00A0
UART(3):THR=$02:00A0
UART(3):IER=$02:00A1
UART(3):ISR=$02:00A2
UART(3):LCR=$02:00A3
UART(3):MCR=$02:00A4
UART(3):LSR=$02:00A5
UART(3):MSR=$02:00A6
UART(3):SPR=$02:00A7
UART(4)=$02:00B0
UART(4):RHR=$02:00B0
UART(4):THR=$02:00B0
UART(4):IER=$02:00B1
UART(4):ISR=$02:00B2
UART(4):LCR=$02:00B3
UART(4):MCR=$02:00B4
UART(4):LSR=$02:00B5
UART(4):MSR=$02:00B6
UART(4):SPR=$02:00B7
BUFFER(1)=$01:0400
BUFFER(2)=$01:0500
BUFFER(3)=$01:0600
BUFFER(4)=$01:0700
8051.def=1<0005
uart.msm=0<0003
:$(00):0000:00B8 :$(01):0400:0800 :$(02):0080:00B8 :$(03):0040:0048 


</pre>
<p>
In the following assembly, a structure is 
constructed at address 0x00037300 in PowerPC system memory. 

<p>
PowerPC definition header has <b>$sterm '.'</b>, so the structure
joins are period on reference

<p>
Some of the components are repeated and subscripted. The
repeat directive is $do, and the $do tag value is used
to generate a numeric label subscript (see Section 7:
Iterated Code and Structured Data, Section 7.1: $do and macros
and Section 7.2: Subscripted Labels).

<p>
Because all the addresses are 0x00037300 or more, PowerPC
load/store instructions can't access them directly, so the
location counter declaration on line 22 instructs the assembler
to answer label references as base-displacement tuples which 
assume R12 is pointing to 0x00037300.
<pre>

MASMX 7r2
3/ppcsinga.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1 record* $proc        
  :                            2 *       $tree
  :                            3 h       +       record(1,1)
  :                            4 times   $do     record(1,1),t(times)       $res  4
  :                            5         $root
  :                            6         $end
  :                            7 
  :                            8:         $include        "ppc1.def"
  :                            9 tree*   $proc
  :                            10 *       $tree
  :                            11 times   $do     3,dibber(times) record    tree(1,1)
  :                            12         $root
  :                            13         $end
  :                            14 
  :                            15 inline*       $proc
  :                            16         lwz   r8, raddle1(1).dibber(3).t(index)
  :                            17         add   r0,0,r8
  :                            18       $end
  :                            19 
  :                            20 SEGMENT $set    55*4096+768
  :                            21 
  :                            22 $(49::SEGMENT,r12)
  :                            23 this_segment    $equ    .
31:00037300 00000012          +24 times   $do     2,raddle1(times) tree    18
31:0003734C 00000012          +24 
31:00037398 00000012          +24 
31:000373E4 00000012          +24 
31:00037430 00000012          +24 
31:0003747C 00000012          +24 
31:000374C8 0000001E          +25 raddle2 tree    30
31:00037544 0000001E          +25 
31:000375C0 0000001E          +25 
  :                            26 
  :                            27 $(0:980*1024)
00:000F5000 640C0003          +28         oris    r12,,SEGMENT/*16
00:000F5004 618C7300          +29         ori     r12,r12,SEGMENT
00:000F5008 806C004C          +30         lwz     r3, raddle1(1).dibber(2)
00:000F500C 808C017C          +31         lwz     r4, raddle1(2).dibber(3).h
00:000F5010 80AC01AC          +32         lwz     r5, raddle1(2).dibber(3).t(12)
00:000F5014 80CC01C8          +33         lwz     r6, raddle2
00:000F5018 616C0000          +34         mr      r11, r12
  :                            35 
  :                            36       $if     0
  :                            37       lwz     r7, raddle2.dibber(1).t(9), r11
  :                            38       $else
00:000F501C 80EB01EC          +39         lwz     r7, raddle2.dibber(1).t(9)(r11)
  :                            40       $endif
  :                            41 
00:000F5020 810C009C          +42 index   $do     raddle1(1).dibber(3).t(),    inline
00:000F5024 7C004214          +42 
00:000F5028 810C00A0          +42 
00:000F502C 7C004214          +42 
00:000F5030 810C00A4          +42 
00:000F5034 7C004214          +42 
00:000F5038 810C00A8          +42 
00:000F503C 7C004214          +42 
00:000F5040 810C00AC          +42 
00:000F5044 7C004214          +42 
00:000F5048 810C00B0          +42 
00:000F504C 7C004214          +42 
00:000F5050 810C00B4          +42 
00:000F5054 7C004214          +42 
00:000F5058 810C00B8          +42 
00:000F505C 7C004214          +42 
00:000F5060 810C00BC          +42 
00:000F5064 7C004214          +42 
00:000F5068 810C00C0          +42 
00:000F506C 7C004214          +42 
00:000F5070 810C00C4          +42 
00:000F5074 7C004214          +42 
00:000F5078 810C00C8          +42 
00:000F507C 7C004214          +42 
00:000F5080 810C00CC          +42 
00:000F5084 7C004214          +42 
00:000F5088 810C00D0          +42 
00:000F508C 7C004214          +42 
00:000F5090 810C00D4          +42 
00:000F5094 7C004214          +42 
00:000F5098 810C00D8          +42 
00:000F509C 7C004214          +42 
00:000F50A0 810C00DC          +42 
00:000F50A4 7C004214          +42 
00:000F50A8 810C00E0          +42 
00:000F50AC 7C004214          +42 
  :                            43 
  :                            44 SEGMENT       $set    .(49)+SEGMENT
  :                            45 $(49::SEGMENT,r11)
  :                            46 new_segment $equ .
31:0003763C 00000006          +47 jessalabel tree 6
31:00037658 00000006          +47 
31:00037674 00000006          +47 
31:00037690 00000004          +48 jumbly  tree    4
31:000376A4 00000004          +48 
31:000376B8 00000004          +48 
  :                            49 $(0)
00:000F50B0 640B0003          +50         oris    r11,,SEGMENT/*16
00:000F50B4 616B763C          +51         ori     r11,r11,SEGMENT
00:000F50B8 806B0054          +52         lwz     r3, jumbly
00:000F50BC 808B0058          +53         lwz     r4, jumbly+4
00:000F50C0 906B0038          +54         stw     r3, jessalabel.dibber(3).h
00:000F50C4 90800006          +55         stw     r4, jessalabel.dibber(3).t()
00:000F50C8 80A34000          +56         lwz     r5, 0x4000(r3)
00:000F50CC 658402C0          +57         li      r4, raddle2.dibber(3)
00:000F50D0 658500E4          +58         li      r5, raddle1(2)
  :                            59 down
00:000F50D4 4800000C          +60       b       up
00:000F50D8 4BFFFFFC          +61       b       down
00:000F50DC 48000004          +62       b       up
  :                            63 up
*EOF*
:$(00):000F5000:000F50E0 :$(31):00000000:00000090 
ppcsinga.msm: object code 924 bytes: 0 errors: 0 undefined labels


</pre>
<a      name="twoscomp"/>
<h2>8.55: $twos_complement   Change Negative Integer Representation</h2>


<p>
$twos_complement defaults to 1 and should never be set to
anything except 1 or 0.
<pre>

	$twos_complement        1

</pre>
<p>
is the default, and causes integers to generate with twos 
complement representation via twos complement calculation.
<pre>

	$twos_complement        0

</pre>
<p>
causes integers to generate with ones complement representation.
Computation of ones complement expressions uses end-around-carry.
Negative values are reached by simple bit inversion (instead
of inversion + 1 as twos complement).

<p>
$twos_complement only affects assembler output (constants and
instructions), not anything which directs the assembler's
actions, such as $do counts. For example,
<pre>

	$word   32
	.
	.
	$do     2+0FFFFFFFF

</pre>
<p>
will always cause one iteration. $if and $elseif use twos
complement arithmetic if it has been selected, but expressions
containing comparisons = # < > will find negative zero
less than zero nevertheless.
<pre>

MASMX/24592 1r1X
compo.msm 5
*EOF*  :                        1:         $word   32
  :                        2: all1s   $equ    0ffffffffffffffffffffffffffffffffffffffffffffffff        
  :                        3:         $twos_complement        0
00:00000000 00000010      +4         -8*(-2)
00:00000001 FFFFFFFF      +5         -0
00:00000002 FFFFFFEF      +6         -8*2
00:00000003 FFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
			 +7         -16*/168
  :                        8:         $if     all1s<0
00:00000009 00000001      +9         +       1+all1s:s
  :                        10:         $endif
  :                        11:         $twos_complement        1
00:0000000A 00000010      +12         -8*(-2)
00:0000000B 00000000      +13         -0
00:0000000C FFFFFFF0      +14         -8*2
00:0000000D FFFFF0000000000000000000000000000000000000000000
			 +15         -16*/168
  :                        16:         $if     all1s<0
00:00000013 00000000      +17         +       1+all1s:s
  :                        18:         $endif
*EOF*:$(00):00000000:00000014 
Object Code 221 Bytes: 0 Errors: 0 Undefined Labels


</pre>

<a      name="word"/>
<h2>8.56: $word              Set the Size of a Target Computer Word</h2>

<p>
Directive
<pre>

	$word	size

</pre>
<p>
sets bit multiple in which code is generated and default size of integer

<p>
A source line which generates any code at all generates an integral 
number of words. 

<p>
The word size may not be less than the size of the 
smallest instruction in the target instruction set.
 
<p>
A machine may have 32- or 64-bit addressing and computation.

<p>
If nevertheless the machine can fetch instructions from an
odd octet address, or has single-byte instructions, 
then word size has to be 8. A machine like that would have
parameters like
<pre>

	$word   8
	$byte   8
	$quantum 8
	$awidth 32

</pre>
<p>
It does not follow that integers need to be 8 bits.

<p>
Code for byte-addressing machines often uses command names like
dw, dl or .long for generating numbers, and these commands
are reproduced as masmx macros, which also handle non-canonical
endianness
<pre>


$ masmx -lnky dl
MASMX 7r3
3/dl.msm
*EOF*
  :                            1         $word   8
  :                            2         $awidth 32
  :                            3         
  :                            4 dl*	$proc
  :                            5 x       $do     dl(1),	+	dl(1,x), dl(1,x)/*8, dl(1,x)/*16, dl(1,x)/*24:q
  :                            6         $end
  :                            7 
00:00000000 010000AA          +8         dl      0AA000001, 0BB000002, 0CC000003 
00:00000004 020000BB          +8 
00:00000008 030000CC          +8 
*EOF*
:$(00):00000000:0000000C 


</pre>
<p>
$awidth and $quantum must be set after $word unless they are the same
value as $word. Suitable parameters for ColdFire are
<pre>

	$word   16
	$awidth 32
	$quantum 8

</pre>
<p>
because ColdFire instructions are one or more  16-bits words
fetched from a word boundary

<p>
Suitable parameters for PowerPC are
<pre>

	$word   32
	$quantum 8

</pre>
<p>
Suitable parameters for 8-bit microcontrollers are
<pre>

	$word   8
	$awidth 16

</pre>

<a      name="xqt_i"/>
<h2>8.57: $xqt_i		run-time integer algorithm plotter</h2>

<b>$xqt_i</b> directive generates a runtime integer algorithm instruction stream
<pre>

	$xqt_i	<i>expression</i>
	
</pre>
See section <a href="#ialgors">6.1: Run-Time Integer Algorithm Plotter $xqt_i</a>

<a      name="xqt_fp"/>
<h2>8.58: $xqt_fp		run-time floating algorithm plotter</h2>

<b>$xqt_fp</b> directive generates a runtime floating algorithm instruction stream

<pre>

	$xqt_i	<i>expression</i>
	
</pre>
See section <a href="#fpalgors">6.2: Run-Time Floating Algorithm Plotter $xqt_fp</a>

<a      name="zcp"/>
<h2>8.59: $zero_code_point  character string escaped zero value</h2>

<b>$zero_code_point</b> directive sets the value which represents embedded zero in a quoted string
to distinguish data byte value zero from end of string or line

<pre>

	$zero_code_point	<i>expression</i>

</pre>
The default value of zero code point is 2700 hex.
Zero code point may be changed from its current value if that clashes with a data value required in the string 
<pre>

$ masmx -lnky zcp
MASMX 7r3
3/zcp.msm
*EOF*
  :                            1 	$set_option	"c"
  :                            2 	$word	32
  :                            3 	$byte	16
  :                            4 
Note: zcp.msm Line 5: \escaped expression equals $zero_code_point
00:00000000 00000000          +5 	"\x2700\x0000"
  :                            6 	$zero_code_point	0x40000000
00:00000001 27000000          +7 	"\x2700\x0000"
  :                            8 
*EOF*
:$(00):00000000:00000002 

</pre>

<a	name="file_formats"/>
<h1>9: Output File Formats, Relocation, Linking, Giant Address Spaces
   Interfacing with GNU Tools</h1>


<a      name="txo"/>
<h2>9.1: Text Encoded Binary Format, S-Records and Intel Hex Records</h2>

<p>
<i>See also <b>8.28: $list 0, masking names from list and export</b></i>

<p>
masmx output is in Text Encoded Binary Output format.

<p>
This assembly produces absolute .txo code:
<pre>


  :                            27 generate* $proc *
  :                            28 Sample:
  :                            29         jb      $bit(FULL.device),leave ; Is there any buffer space?
  :                            30         mov     dptr,#uart(device).lsr  ; Is there data on COM1 input FIFO?
  :                            31         movx    a,@dptr
  :                            32         jnb     $bit(acc.LSR_RDR), Leave; No more so Next UART
  :                            33         mov     dptr,#uart(device).rhr  ; Yes
  :                            34         movx    a,@dptr                 ; Read
  :                            35         mov     dptr,#buffer(device)    ; Find Place in Circular Input Buffer
  :                            36         mov     dpl,write_cursor(device); By Means of the Running Cursor
  :                            37         movx    @dptr,a                 ; Write the Data to XRAM
  :                            38         inc     write_cursor(device)    ; Advance the Input Cursor
  :                            39         mov     a,read_cursor(device)   ; If write starts to equal read
  :                            40         cjne    a,write_cursor(device),Sample ; Is there any more? 
  :                            41         setB    $bit(FULL.device)       ; Stop reading from FIFO to XRAM
  :                            42 leave:       
  :                            43         $end
  :                            44 
  :                            45 
  :                            46 DEVICES equ     128
  :                            47 DATA    equ     1024
  :                            48 TOTAL   equ     4
  :                            49 RTVARS  equ     64
  :                            50 Full    equ     32
  :                            51 
  :                            52 $(3:RTVARS)
  :                            53 device  $do     TOTAL,write_cursor(device)      $res    1
  :                            54 device  $do     TOTAL,read_cursor(device)       $res    1
  :                            55 $(2:DEVICES)
  :                            56 device  $do     TOTAL,uart(device)              serial
  :                            57 $(1:DATA)
  :                            58 device  $do     TOTAL,buffer(device)            VAR    256
  :                            59 
  :                            60 
  :                            61 $(0:64)
00:0040 20011B                +62 device        $do     TOTAL,  generate
00:0043 900085                +62 
00:0046 E0                    +62 
00:0047 30E014                +62 
00:004A 900080                +62 
00:004D E0                    +62 
00:004E 900400                +62 
00:0051 854082                +62 
00:0054 F0                    +62 
00:0055 0540                  +62 
00:0057 E544                  +62 
00:0059 B540E4                +62 
00:005C D201                  +62 
00:005E 20021B                +62 
00:0061 900095                +62 
00:0064 E0                    +62 
00:0065 30E014                +62 
00:0068 900090                +62 
00:006B E0                    +62 
00:006C 900500                +62 
00:006F 854182                +62 
00:0072 F0                    +62 
00:0073 0541                  +62 
00:0075 E545                  +62 
00:0077 B541E4                +62 
00:007A D202                  +62 
00:007C 20031B                +62 
00:007F 9000A5                +62 
00:0082 E0                    +62 
00:0083 30E014                +62 
00:0086 9000A0                +62 
00:0089 E0                    +62 
00:008A 900600                +62 
00:008D 854282                +62 
00:0090 F0                    +62 
00:0091 0542                  +62 
00:0093 E546                  +62 
00:0095 B542E4                +62 
00:0098 D203                  +62 
00:009A 20041B                +62 
00:009D 9000B5                +62 
00:00A0 E0                    +62 
00:00A1 30E014                +62 
00:00A4 9000B0                +62 
00:00A7 E0                    +62 
00:00A8 900700                +62 
00:00AB 854382                +62 
00:00AE F0                    +62 
00:00AF 0543                  +62 
00:00B1 E547                  +62 
00:00B3 B543E4                +62 
00:00B6 D204                  +62 
  :                            63 
*EOF*
:$(00):0000:00B8 :$(01):0400:0800 :$(02):0080:00B8 :$(03):0040:0048 
uart.msm: object code 381 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The output code is represented in text.
It can be viewed in a text editor or a shell.

<p>
This is the output of
<pre>


PROMPT\>masmx uart uart -l

</pre>
<p>
Text Encoded Binary format represents code with hexadecimal symbols.
<pre>

$00:0040
20011B 900085 E0 30E014 900080 E0 900400 854082 F0 0540 E544
B540E4 D201 20021B 900095 E0 30E014 900090 E0 900500 854182
F0 0541 E545 B541E4 D202 20031B 9000A5 E0 30E014 9000A0 E0
900600 854282 F0 0542 E546 B542E4 D203 20041B 9000B5 E0
30E014 9000B0 E0 900700 854382 F0 0543 E547 B543E4 D204
:$00*0000:0000:00B8
:$01*0000:0400:0800
:$02*0000:0080:00B8
:$03*0000:0040:0048

</pre>
<p>
The first line shows the tag of locator zero and a 16 bit load address
equal to 64.

<p>
The following fields are superwords.

<p>
Superwords are fields representing one or more words of code.

<p>
If there is any address jump or change of location counter,
another location line like the first intervenes.

<p>
Finally there are four lines of summary information.


<p>
Converter utility <b>imx</b> generates Intel load strings from
Text Encoded Binary
<pre>

PROMPT\>imx uart.txo uart.hex

</pre>

<p>
That produces
<pre>


:2000400020011B900085E030E014900080E0900400854082F00540E544B540E4D201200254
:200060001B900095E030E014900090E0900500854182F00541E545B541E4D20220031B9083
:2000800000A5E030E0149000A0E0900600854282F00542E546B542E4D20320041B9000B532
:1800A000E030E0149000B0E0900700854382F00543E547B543E4D2042D
:00FFFF0101


</pre>
<p>
Code for converting to Motorola S-Records is also assembled to .txo format
first:
<pre>

MASMX 7r3
3/qplain.msm
LTERM=#
CONT_CHAR=|
STERM=.
  :                            1:         $include        "ppc_603.def"
  :                            2 
  :                            3 SEGMENT .equ    511*1024
  :                            4 $(48:SEGMENT,r15)
30:0007FC00 0000000000400000  +5 part1   2048*2048d
30:0007FC08 0000000000000064  +6 part2   100d
  :                            7 part3   $res    2048*2048-16
  :                            8 
30:0047FC00 0007FC10          +9 	+	.absolute(part3)
  :                            10 
  :                            11 $(0:3*65536)
00:00030000 640F0008          +12 start   oris    r15,, SEGMENT@ha     
00:00030004 39E0FC00          +13         addi    r15, SEGMENT@l 
00:00030008 806F0000          +14         lwz     r3, part1
00:0003000C 808F0008          +15         lwz     r4, part2
00:00030010 80AF0010          +16         lwz     r5, part3
00:00030014 4E800020          +17         blr
  :                            18         $end    start
:$(00):00030000:00030018 :$(30):0007FC00:0047FC04 
qplain.msm: object code 214 bytes: 0 errors: 0 undefined labels


</pre>
PROMPT\>masmx -ld qplain qplain

<p>
Produces qplain.txo

<p>
The <b>-d</b> flag displayed the real addresses in SEGMENT instead of the
displacements.

<p>
This is the text-encoded binary of qplain

<pre>
$ cat qplain.txo

$30:0007FC00
0000000000400000 0000000000000064
$30:0047FC00
0007FC10
$00:00030000
640F0008 39E0FC00 806F0000 808F0008 80AF0010 4E800020
>00:00030000

:$00*00000000:00030000:00030018
:$30*00000000:0007FC00:0047FC04

</pre>

These lines of generated code and controls are

	<blockquote>
	start location counter 48 at address 0007FC00<br><br>

	two 64-bit integers<br><br>

	start location counter 48 at address 0047FC00<br><br>

	an address constant pointing to the byte 16 of program section 48<br><br>

	start location counter 0 at address 00030000<br><br>

	two instructions which load the address SEGMENT to r15<br><br>

	three instructions which reference SEGMENT with base register R15<br><br>

	a return instruction<br><br>

	a transfer address symbol >00:00030000 pointing to the label start<br><br>

	summary information for two absolute addressed segments
	</blockquote>

</ul>
There is no relocation information in qplain.txo. It goes
to the S-records converter, mmx:
<pre>

PROMPT\>mmx qplain.txo qplain.hex

</pre>
<p>
mmx utility writes S-records in qplain.hex:
<pre>

S00600004844521B
S3150007FC000000000000400000000000000000006443
S3090047FC000007FC10A0
S31900030000640F000839E0FC00806F0000808F000880AF00100E
S309000300144E800020F1
S70500030000F7

</pre>
<p>
A transfer address has to be present if GNU tools objcopy is used
to copy the S-records to binary. objcopy otherwise refuses. Transfer
address is the S7 record.


<a      name="linking"/>
<h2>9.2: Relocation, Linking, Giant Addresses and Interfacing with GNU Tools</h2>


<a      name="relinfo"/>
<h3>9.2.1: Relocation Information in Text Encoded Binary</h3>

<p>
To list the relocation information in a relocatable assembly,
assemble with <b>-nl</b> flags.

<p>
<b>-l</b> is for list, <b>-n</b> for list outstanding relocation information:
<pre>

	>masmx -ln zactor

MASMX 7r2
3/zactor.msm
LTERM=#
CONT_CHAR=|
STERM=.
*EOF*
  :                            1 __relocatable $set	1
  :                            2: 	$include	"ppc_603.def"
  :                            3 
  :                            4 	$if	1
  :                            5 $(.data)
03:00000000 00000063          +6 myword	.long		99
  :                            7 	$endif
  :                            8 
  :                            9 $(.text)
  :                            10 zactor*
[+0000:00008000/*10]10
01:00000000 3D200000          +11         lis 9,factor@ha
[+0000]10-
01:00000004 80090000          +12         lwz 0,factor@l(9)
  :                            13 
  :                            14 	$if	1
(+03:00008000/*10)10
01:00000008 3D400000          +15 	lis 10,myword@ha
(+03)10-
01:0000000C 816A0000          +16 	lwz 11,myword@l(10)
  :                            17 	$endif
  :                            18 
[+0001:fffffff0/*02]18*/02+
(-01:fffffff0/*02)18*/02+
01:00000010 4BFFFFF1          +19 	bl	soso
01:00000014 4E800020          +20 	blr
*EOF*
:$(01):00000000:00000018 :$(03):00000000:00000004 
zactor.msm: object code 343 bytes: 0 errors: 2 undefined labels

</pre>
<p>
And the relocation information displayed maps to the relocation
information in the Text Encoded Binary
<pre>

$03:*00000004
$03:00000000
00000063
$01:*00000004
$01:00000000
[0000:00008000/*10]10:3D200000 [0000]10-:80090000 (03:00008000/*10)10:3D400000
(03)10-:816A0000 [0001:FFFFFFF0/*02]18*/02+:(-01:FFFFFFF0/*02)18*/02+:4BFFFFF1
4E800020
+ZACTOR:$01:00000000
-FACTOR:[0000]
-SOSO:[0001]
:$01*00000004:00000000:00000018
:$03*00000004:00000000:00000004

</pre>
<ul>

	counter 3 has a relocation alignment factor 4.
	Definition "ppc_603.def" maps counter 3 to
	ELF section .data

<pre></pre>
	relocatable counter 3 starts with zero offset

<pre></pre>
	a data word contains 99

<pre></pre>
	counter 1 has a relocation alignment factor 4.
	Definition "ppc_603.def" maps counter 1 to
	ELF section .text

<pre></pre>
	relocatable counter 1 starts with zero offset

<pre></pre>
	There is one relocation clause on the first superword:
<ul>
	    [0000:00008000/*10]10:

<pre></pre>
	    [0000:xxxxxxxxxxxx]10: means add the value of the
	    unknown name FACTOR, which is encoded as the index
	    number [0000], to 16 bits of the instruction code 3D200000

<pre></pre>
	    Macro code at assembly adjusted the unrelocated value
	    00000000 with the formula +32768/*16 (macro @ha).

<pre></pre>
	    That is reflected in this linker information: 00008000/*10<br>
	    The rounding addition is because of sign extension on
	    base-displacement references

<pre></pre>
	    This is the operand factor@ha
</ul>
<pre></pre>
	There is one relocation clause on the second superword:
<ul>
	    [0000]10-: means add the value of unknown name FACTOR
	    to 16 bits of instruction code 80090000.<br>The trailing
	    minus means: range checking not required, truncation
	    is expected.

<pre></pre>
	    The addend offset is read out of the instruction
	    code itself. This is operand factor@l
</ul>
<pre></pre>
	There is one relocation clause on the third superword:
<ul>
	    (03:00008000/*10)10:
<pre></pre>
	    (03:xxxxxxxxxxxx)10: means add the segment base of
	    section 3 (.data) to sixteen bits of instruction code 3D400000

<pre></pre>
	    Macro code at assembly adjusted the unrelocated value
	    00000000 (first location in .data) with the formula
	    +32768/*16 (macro @ha).

<pre></pre>
	    That is reflected in this linker information: 00008000/*10<br>
	    The rounding addition is because of sign extension on
	    base-displacement references

<pre></pre>
	    This is the operand myword@ha
</ul>
<pre></pre>
	There is one relocation clause on the fourth superword:
<ul>
	    (03)10-: means add the segment base of section 3 (.data)
	    to 16 bits of instruction code 816A0000. The trailing
	    minus means, do not check range: truncation is expected.
	   
<pre></pre>
	    The addend offset is read out of the instruction
	    code itself. This is operand myword@l
</ul>
<pre></pre>
	There are two relocation clauses on the fifth superword:
<ul>
	    [0001:FFFFFFF0/*02]18*/02+:
<pre></pre>
	    [0001:xxxxxxxxxxxx]18*/02+: means add the value of the
	    unknown name SOSO, encoded as the index number [0001],
	    to the operand address, to be encoded in 24 bits of
	    the instruction 4BFFFFF1 starting 2 bits up.
	     + means range check as signed.

<pre></pre>
	    The additional linker information FFFFFFF0/*02 means
	    take the unrelocated address information from here,
	    not from the instruction, and shift it after relocation.

<pre></pre>
	    This is a relative jump instruction. Macro code at
	    assembly applied the formula TARGET-HERE*/-2

</ul>
<pre></pre>
	    This is the jump to soso. There is a second relocation
	    tuple on this instruction, becauses the jump-from address
	    is also relocatable.
<ul>
	The second relocation tuple is
<pre></pre>
	    (-01:FFFFFFF0/*02)18*/02+
<pre></pre>
	    (-01:xxxxxxxxxxxx)18*/02+ means subtract the segment base
	    of locator 1 (.text) from the operand address 

<pre></pre>
	    the unrelocated part of HERE is known = 00000010

<pre></pre>
	    the unrelocated part of target SOSO is known = 00000000
	    because all the value of SOSO is in its relocated part

<pre></pre>
	    assembly was able to encode 00000000-00000010=FFFFFFF0

<pre></pre>
	    the link must add the relocated part of SOSO and subtract
	    the relocated part of HERE

<pre></pre>
	    the part about shift right and then store in a left
	    shifted field is because the low two address bits
	    are zero and not encoded in the instruction.
<pre></pre>
	    When there is a right shift in a relocatable operand,
	    the additional linker information here shown as
	    FFFFFFF0/*02 is output from assembly, so that the
	    whole address is relocated before shifting.
<pre></pre>
	    All relocation tuples for one field of code are
	    effectively accumulated.

</ul>
<p>
	The return instruction in the sixth superword has no
	relocation clauses.

<pre></pre>
	The label list shows ZACTOR exported, FACTOR and SOSO imported,
	relocatable counter 1 (.text) with aligment factor 4 and
	24 bytes long, relocatable counter 3 (.data) with alignment
	factor 4 and 4 bytes long.

</ul>

<a      name="linkbasic"/>
<h3>9.2.2:  masmx Linking in Principle</h3>


<p>
Link is a set of masmx features, and a link is an assembly

<p>
Linking begins when a Text Encoded Binary is included
<pre>

	$include,$binary	file[.txo]	$(locator, locator...

</pre>
<p>
The second argument for picking and ordering segments is optional.

<p>
macro <b>$map</b> must be declared before any binary includes.
<pre>

	$include		"map_macro.def"

	$include,$binary	file1
	$include,$binary	file2

</pre>
<p>
Files of code for inclusion are Text Encoded Binary. They may be with
or without relocation information.

<p>
The link combines files, and some of the binary includes would contain
relocatable code although not all must:
<pre>

	$include		"map_macro.def"

	$include,$binary	absolute
	$include,$binary	relocatable1
	$include,$binary	relocatable2

</pre>
<p>
$include,$binary sends all the superwords in the Text Encoded Binary files
to the <b>$map</b> macro, one line of superwords at a time.

<p>
The <b>$map</b> macro is not part of the assembler. Definitions for PowerPC
linking, <b>map_ppc.def</b> and <b>ppc64map.def</b>, are in this package
and have a <b>$map</b> macro for PowerPC.

<p>
masmx itself uses the location lines and summary tables. Only the
superwords of code go to <b>$map</b> macro.

<p>
<b>$map</b> macro uses some or all of these masmx linking features:
<ul>	
	directive	$set,$binary
<pre>
</pre>

	directive	$load,$bits
<pre>
</pre>

	directive	$pushrel
<pre>
</pre>

	directive	$pushrel,$long_absolute
<pre>
</pre>

	directive	$info,$offset
<pre>
</pre>

 	directive	$info,$range_check
<pre>
</pre>

 	directive	$info,$range_check1


</ul>
<p>
The outline use of the directives is
<pre>

code_label	$set,$binary	superword_code_part
		$load,$bits	code_label

</pre>
<p>
code_label is a user-supplied name. $set,$binary loads the value
of a code superword to code_label and sets the automatic label
$bits to the number of bits read.

<p>
<b>$load,$bits</b> writes the new superword in the output
Text Encoded Binary, prefixed with any oustanding relocation clauses.
<pre>

parameter_label $pushrel	relocation_clause

</pre>
<p>
parameter_label is a user supplied name. $pushrel types it as $equf
and it contains three or five values for adjusting the code part
of the superword.

<p>
The first of these five values is the relocation value, and is normally
retrieved
<pre>

value	$set	parameter_label

</pre>
<p>
Absolute addresses wider than 32 bits are instead retrieved with different
use of $pushrel
<pre>

value	$pushrel,$long_absolute	relocation_clause

</pre>
<p>
$info directive
<pre>

	$info,$offset	value

</pre>
<p>
adjusts an addend encoding. This is done when the segment root of some
addresses is changed but not yet absolute (cumulative link).

<p>
The affected addresses are exclusively addresses which assembly must encode
separately alongside the instruction code, because they will be manipulated
with a rightward shift after relocation. This allows any overflow from the
truncated part to be included correctly.

<p>
Macro language need not be aware whether the output is relocatable, because
if is safe to order <b>$info,$offset</b> whether relocation information
will be output or not. When no relocation information will be output,
no action takes place.
<pre>

	$info,$range_check	value
	$info,$range_check1	value

</pre>
<p>
These calls request masmx linker section to range check <b>value</b>
according to the size and signed-or-not character of the relocatable
field represented at the top the of the relocation stack.

<p>
<b>value</b> is the relocated value which macro language will write
to "this" field.

<p>
<b>$range_check1</b> is of higher stringency than <b>$range_check</b>. See
Section 8.26.2, and Section 9.2.3: Link Examples. A <b>$map</b> macro using
<b>$range_check</b> maintains (where multiple relocation tuples may drive
a field out of range and then again into range) intermediate results
at 192-bit precision.
<p>
<a	name="map_ppc"/>
$map is the name of a macro from outside the assembler. It is
"user written". There is a working $map macro for PowerPC in this
package

<p>
$map macro in the supplied definition "map_ppc.def" has this structure:
<pre>


<div	style="color:blue">
p	$proc
"$map"*	$name

<div	style="color:green">
p	$proc
superword*	$name
clauses	$set	p(1,1:)
"$data"	$set,$binary	p(1,1:clauses)	# cache the code part of the superword
					# then process each relocation clause

clause	$do	clauses-1,	relocate	p(1, 1:clause)
	$load,$bits	$data		# output updated code and any outstanding relocation requests
	$end	. of SUPERWORD
</div>

<div	style="color:red">
p	$proc
relocate* $name

rel_params $pushrel	p(1,1)	# cache relocation attributes in a $equf label

value	$set	rel_params\1	# segment base or external label value

bits    $set    rel_params\2	# size of target field
scale   $set    rel_params\3	# shift leftwards of target field from superword bit 0
offset  $set    rel_params\4	# separately encoded relocatable value, only if manipulated after relocation
descant $set    rel_params\5	# negative left shift = right shift, only if manipulated after relocation

limit   $set    1*/bits
mask    $set    limit-1
unmask  $set    ^(mask*/scale)

	$if	descant<0		# shall there be a manipulation after relocation?
field	$set	value+offset		# add relocating value to offset from relocation clause
	$info,$range_check1	field	# write a new relocation tuple if the field remains relocatable
	$info,$offset		field	# write a new offset part of the tuple if the field remains relocatable
field	$set	field*/descant		# position the updated field for reinsertion in code
	$else
field	$set	value+(($data/*scale)**mask)	# otherwise just update field shifted right 
	$info,$range_check1	field		# check no outflow
	$endif

"$data"* $set	((field**mask)*/scale)++($data**unmask) # insert the new value shifted to position into code

	$end	. of RELOCATE
</div>

index	$do	p(),	superword	p(index, 1)	# send each superword to procedure superword
	$end	. of $map
</div>


</pre>
<p>
<b>$map</b> macro is called for each line of Text Encoded Binary which
contains any code superwords.

<p>
The second last line of macro language calls embedded macro
superword once for each superword.

<p>
macro superword
<ul>
	caches the code from the last clause of the superword:
<pre>

	data	$set,$binary	p(1,1:clauses)

</pre>

	calls embedded macro relocate once for each relocation clause:
<pre>

	clause	$do	clauses-1,	relocate	p(1,1:clause)

</pre>

	writes out the code adjusted by relocate macro:
</ul>
<pre>

		$load,$bits	data

</pre>
<p>
macro relocate
<ul>
	updates the code according to the relocation clause,
	with update information tabled by <b>$pushrel</b>
<pre>
</pre>

	in some cases adjusts forwarded information for
	further relocation.

</ul>

<a      name="linkdems"/>
<h3>9.2.3: Demonstration Links</h3>


<p>
These examples are different kinds of link and their output

<p>
First two small c files, soso.c and factor.c are compiled with
gcc -S
<pre>

$ gcc -S soso.c

	extern int       factor;
	extern int       adjustment(int *where);

	int              clanjamfrie = 55;

	static int       yasimi = 99;
	static int       startfromhere;
	static int      *cu = &startfromhere;

	int soso()
	{
	   static int    separate_static_item = 0xa5a5a5a5;
	   static long long clearly_so;

	   int           x = startfromhere++;

	   x *= factor;
	   x += adjustment(cu);
	   x -= yasimi;
	   return x;
	}

$ gcc -S factor.c

	extern int soso(int *there);

	extern int       clanjamfrie;

	int              factor = 88;

	static int      *acu = &factor;

	int     adjustment()
	{
	   return 33;
	}

	int overcoat()
	{
	   soso(acu);
	}

</pre>
<p>
Then wrapper files are constructed
<pre>

$ cat soso.msm

__relocatable $set	1
	$include	"ppc_603.def"
	$store		soso
	$list		2
	$include	soso.s

$ cat factor.msm

	$list		1
__relocatable $set	1
	$include	"ppc_603.def"
	$list		2
	$store		factor
	$include	factor.s

</pre>
<p>
and the wrapper files are assembled
<pre>

$ masmx soso -ln

MASMX 7r2
3/soso.msm
LTERM=#
CONT_CHAR=|
STERM=.
*EOF*
  :                            1 __relocatable $set	1
  :                            2: 	$include	"ppc_603.def"
  :                            3 	$store		soso
  :                            4 	$list		2
  :                            5: 	$include	soso.s
  :                            1 	.file	"soso.c"
  :                            2 	.globl clanjamfrie
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	clanjamfrie, @object
  :                            6 	.size	clanjamfrie, 4
  :                            7 clanjamfrie:
06:00000000 00000037          +8 	.long	55
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	yasimi, @object
  :                            12 	.size	yasimi, 4
  :                            13 yasimi:
03:00000000 00000063          +14 	.long	99
  :                            15 	.align 2
  :                            16 	.type	cu, @object
  :                            17 	.size	cu, 4
  :                            18 cu:
(+05)20
03:00000004 00000008          +19 	.long	startfromhere
  :                            20 	.lcomm	clearly_so.1543,8,8
  :                            21 	.type	clearly_so.1543, @object
  :                            22 	.align 2
  :                            23 	.type	separate_static_item.1542, @object
  :                            24 	.size	separate_static_item.1542, 4
  :                            25 separate_static_item.1542:
03:00000008 A5A5A5A5          +26 	.long	-1515870811
  :                            27 	.section	".text"
  :                            28 	.align 2
  :                            29 	.globl soso
  :                            30 	.type	soso, @function
  :                            31 soso:
01:00000000 9421FFE0          +32 	stwu 1,-32(1)
01:00000004 7C0802A6          +33 	mflr 0
01:00000008 93E1001C          +34 	stw 31,28(1)
01:0000000C 90010024          +35 	stw 0,36(1)
01:00000010 63E10000          +36 	mr 31,1
(+05:00008008/*10)10
01:00000014 3D200000          +37 	lis 9,startfromhere@ha
(+05)10-
01:00000018 81290008          +38 	lwz 9,startfromhere@l(9)
01:0000001C 913F0008          +39 	stw 9,8(31)
01:00000020 38010009          +40 	addi 0,9,1
(+05:00008008/*10)10
01:00000024 3D200000          +41 	lis 9,startfromhere@ha
(+05)10-
01:00000028 90090008          +42 	stw 0,startfromhere@l(9)
[+0000:00008000/*10]10
01:0000002C 3D200000          +43 	lis 9,factor@ha
[+0000]10-
01:00000030 81290000          +44 	lwz 9,factor@l(9)
01:00000034 801F0008          +45 	lwz 0,8(31)
01:00000038 7C0049D6          +46 	mullw 0,0,9
01:0000003C 901F0008          +47 	stw 0,8(31)
(+03:00008004/*10)10
01:00000040 3D200000          +48 	lis 9,cu@ha
(+03)10-
01:00000044 80090004          +49 	lwz 0,cu@l(9)
01:00000048 60600000          +50 	mr 3,0
[+0001:ffffffb4/*02]18*/02+
(-01:ffffffb4/*02)18*/02+
01:0000004C 4BFFFFB5          +51 	bl adjustment
01:00000050 61230000          +52 	mr 9,3
01:00000054 801F0008          +53 	lwz 0,8(31)
01:00000058 7C004A14          +54 	add 0,0,9
01:0000005C 901F0008          +55 	stw 0,8(31)
(+03:00008000/*10)10
01:00000060 3D200000          +56 	lis 9,yasimi@ha
(+03)10-
01:00000064 81290000          +57 	lwz 9,yasimi@l(9)
01:00000068 801F0008          +58 	lwz 0,8(31)
01:0000006C 7C090050          +59 	subf 0,9,0
01:00000070 901F0008          +60 	stw 0,8(31)
01:00000074 801F0008          +61 	lwz 0,8(31)
01:00000078 60600000          +62 	mr 3,0
01:0000007C 81610000          +63 	lwz 11,0(1)
01:00000080 800B0004          +64 	lwz 0,4(11)
01:00000084 7C0803A6          +65 	mtlr 0
01:00000088 83EBFFFC          +66 	lwz 31,-4(11)
01:0000008C 602B0000          +67 	mr 1,11
01:00000090 4E800020          +68 	blr
  :                            69 	.size	soso, .-soso
  :                            70 	.lcomm	startfromhere,4,4
  :                            71 	.type	startfromhere, @object
  :                            72 	.ident	"GCC: (GNU) 4.2.1"
*EOF*
:$(01):00000000:00000094 :$(03):00000000:0000000C :$(05):00000000:0000000C :$(06):00000000:00000004 
soso.msm: object code 887 bytes: 0 errors: 2 undefined labels

$ cat soso.txo

$06:*00000004
$06:00000000
00000037
$03:*00000004
$03:00000000
00000063
$03:00000004
(05)20:00000008
$03:00000008
A5A5A5A5
$01:*00000004
$01:00000000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
(05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
(05)10-:90090008 [0000:00008000/*10]10:3D200000 [0000]10-:81290000
801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
(03)10-:80090004 60600000 [0001:FFFFFFB4/*02]18*/02+:(-01:FFFFFFB4/*02)18*/02+:4BFFFFB5
61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
(03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+CLANJAMFRIE:$06:00000000
+SOSO:$01:00000000
-ADJUSTMENT:[0001]
-FACTOR:[0000]
:$01*00000004:00000000:00000094
:$03*00000004:00000000:0000000C
:$05*FFFFFFFC:00000000:0000000C
:$06*00000004:00000000:00000004

</pre>
<p>
A number of superwords in the Text Encoded Binary soso.txo have
relocation tuples, some to request fixed addresses for the segments
of soso itself, others to locate external names ADJUSTMENT and FACTOR
<pre>

$ masmx -ln factor

MASMX 7r2
3/factor.msm
LTERM=#
CONT_CHAR=|
STERM=.
*EOF*
  :                            1 	$list		1
  :                            2 __relocatable $set	1
  :                            3: 	$include	"ppc_603.def"
  :                            4 	$list		2
  :                            5 	$store		factor
  :                            6: 	$include	factor.s
  :                            1 	.file	"factor.c"
  :                            2 	.globl factor
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	factor, @object
  :                            6 	.size	factor, 4
  :                            7 factor:
06:00000000 00000058          +8 	.long	88
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	acu, @object
  :                            12 	.size	acu, 4
  :                            13 acu:
(+06)20
03:00000000 00000000          +14 	.long	factor
  :                            15 	.section	".text"
  :                            16 	.align 2
  :                            17 	.globl adjustment
  :                            18 	.type	adjustment, @function
  :                            19 adjustment:
01:00000000 9421FFF0          +20 	stwu 1,-16(1)
01:00000004 93E1000C          +21 	stw 31,12(1)
01:00000008 63E10000          +22 	mr 31,1
01:0000000C 64000021          +23 	li 0,33
01:00000010 60600000          +24 	mr 3,0
01:00000014 81610000          +25 	lwz 11,0(1)
01:00000018 83EBFFFC          +26 	lwz 31,-4(11)
01:0000001C 602B0000          +27 	mr 1,11
01:00000020 4E800020          +28 	blr
  :                            29 	.size	adjustment, .-adjustment
  :                            30 	.align 2
  :                            31 	.globl overcoat
  :                            32 	.type	overcoat, @function
  :                            33 overcoat:
01:00000024 9421FFF0          +34 	stwu 1,-16(1)
01:00000028 7C0802A6          +35 	mflr 0
01:0000002C 93E1000C          +36 	stw 31,12(1)
01:00000030 90010014          +37 	stw 0,20(1)
01:00000034 63E10000          +38 	mr 31,1
(+03:00008000/*10)10
01:00000038 3D200000          +39 	lis 9,acu@ha
(+03)10-
01:0000003C 80090000          +40 	lwz 0,acu@l(9)
01:00000040 60600000          +41 	mr 3,0
[+0000:ffffffbc/*02]18*/02+
(-01:ffffffbc/*02)18*/02+
01:00000044 4BFFFFBD          +42 	bl soso
01:00000048 81610000          +43 	lwz 11,0(1)
01:0000004C 800B0004          +44 	lwz 0,4(11)
01:00000050 7C0803A6          +45 	mtlr 0
01:00000054 83EBFFFC          +46 	lwz 31,-4(11)
01:00000058 602B0000          +47 	mr 1,11
01:0000005C 4E800020          +48 	blr
  :                            49 	.size	overcoat, .-overcoat
  :                            50 	.ident	"GCC: (GNU) 4.2.1"
*EOF*
:$(01):00000000:00000060 :$(03):00000000:00000004 :$(06):00000000:00000004 
factor.msm: object code 594 bytes: 0 errors: 1 undefined labels

$ cat factor.txo

$06:*00000004
$06:00000000
00000058
$03:*00000004
$03:00000000
(06)20:00000000
$01:*00000004
$01:00000000
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:00000024
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:00008000/*10)10:3D200000
(03)10-:80090000 60600000 [0000:FFFFFFBC/*02]18*/02+:(-01:FFFFFFBC/*02)18*/02+:4BFFFFBD
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:00000000
+FACTOR:$06:00000000
+OVERCOAT:$01:00000024
-SOSO:[0000]
:$01*00000004:00000000:00000060
:$03*00000004:00000000:00000004
:$06*00000004:00000000:00000004

</pre>
<p>
The call to soso is relative, so the unrelocated address is
"unknown" minus hex 00000044 = FFFFFFBC


<a      name="link1"/>
<h4>9.2.3.1: The Simplest Link</h4>


<p>
The first link is the simplest kind. An absolute start address is
given, and all segments are placed in the order they were found.

<p>
The first link pass arranges the placement of segments
<pre>

$ masmx map1 -l

MASMX 7r2
3/map1.msm
soso.txo:$(1) 148 bytes decimal from hexadecimal 000A0000 to 000A0094
soso.txo:$(3) 12 bytes decimal from hexadecimal 000A0094 to 000A00A0
soso.txo:$(5) 12 bytes decimal from hexadecimal 000A00A0 to 000A00AC
soso.txo:$(6) 4 bytes decimal from hexadecimal 000A00AC to 000A00B0
factor.txo:$(1) 96 bytes decimal from hexadecimal 000A00B0 to 000A0110
factor.txo:$(3) 4 bytes decimal from hexadecimal 000A0110 to 000A0114
factor.txo:$(6) 4 bytes decimal from hexadecimal 000A0114 to 000A0118
*EOF*
  :                            1: 	$include	"map_ppc.def"
  :                            2 $(0:000A0000)
  :                            3 	$plist			7
  :                            4: 	$include,$binary	soso
  :                            5: 	$include,$binary	factor
  :                            6 
  :                            7 	$store			image1
*EOF*
:$(00):000A0000:000A0000 :$(01):000A0000:000A0110 :$(03):000A0094:000A0114 :$(05):000A00A0:000A00AC :$(06):000A00AC:000A0118 
map1.msm: object code 994 bytes: 0 errors: 0 undefined labels

$ cat image1.txo

$06:000A00AC
00000037
$03:000A0094
00000063
$03:000A0098
000A00A8
$03:000A009C
A5A5A5A5
$01:000A0000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 3D20000A
812900A8 913F0008 38010009 3D20000A 900900A8 3D20000A
81290114 801F0008 7C0049D6 901F0008 3D20000A 80090098
60600000 48000065 61230000 801F0008 7C004A14 901F0008
3D20000A 81290094 801F0008 7C090050 901F0008 801F0008
60600000 81610000 800B0004 7C0803A6 83EBFFFC 602B0000
4E800020
$06:000A0114
00000058
$03:000A0110
000A0114
$01:000A00B0
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:000A00D4
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 3D20000A
80090110 60600000 4BFFFF0D 81610000 800B0004 7C0803A6
83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:000A00B0
+CLANJAMFRIE:$06:000A00AC
+FACTOR:$06:000A0114
+OVERCOAT:$01:000A00D4
+SOSO:$01:000A0000
:$00*00000000:000A0000:000A0000
:$01*00000000:000A0000:000A0110
:$03*00000000:000A0094:000A0114
:$05*00000000:000A00A0:000A00AC
:$06*00000000:000A00AC:000A0118


</pre>

<a      name="link2"/>
<h4>9.2.3.2: Link Collected by Section</h4>


<p>
The second link uses <a href="#option_b">option -b</a>, which collects the segments by section.

<p>
A start address has to be given for each section.

<p>
Definition "ppc_603.def" maps these counters to ELF sections:
<pre>

	$(1)	.text
	$(3)	.data
	$(5)	.bss
	$(6)	.sdata
	$(11)	.rodata

$ masmx map2 -l

MASMX 7r2
3/map2.msm
soso.txo:$(1) 148 bytes decimal from hexadecimal 000A0000 to 000A0094
soso.txo:$(3) 12 bytes decimal from hexadecimal 000B0000 to 000B000C
soso.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
soso.txo:$(6) 4 bytes decimal from hexadecimal 000C0000 to 000C0004
factor.txo:$(1) 96 bytes decimal from hexadecimal 000A0094 to 000A00F4
factor.txo:$(3) 4 bytes decimal from hexadecimal 000B000C to 000B0010
factor.txo:$(6) 4 bytes decimal from hexadecimal 000C0004 to 000C0008
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2        $set_option     "b"
  :                            3 $(1:000A0000)
  :                            4 $(3:000B0000)
  :                            5 $(5:000B8000)
  :                            6 $(6:000C0000)
  :                            7:       $include,$binary        soso
  :                            8:       $include,$binary        factor
  :                            9 
  :                            10       $store                  image2
*EOF*
:$(01):000A0000:000A00F4 :$(03):000B0000:000B0010 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map2.msm: object code 962 bytes: 0 errors: 0 undefined labels


</pre>

<a      name="link3"/>
<h4>9.2.3.3: Link Specific Segments</h4>


<p>
The third link picks the segments individually, in case none of the
automatic order methods is adequate:
<pre>

$ masmx map3 -l

MASMX 7r2
3/map3.msm
soso.txo:$(1) 148 bytes decimal from hexadecimal 000A0000 to 000A0094
factor.txo:$(1) 96 bytes decimal from hexadecimal 000A0094 to 000A00F4
soso.txo:$(3) 12 bytes decimal from hexadecimal 000A00F4 to 000A0100
factor.txo:$(3) 4 bytes decimal from hexadecimal 000A0100 to 000A0104
soso.txo:$(5) 12 bytes decimal from hexadecimal 000C0000 to 000C000C
soso.txo:$(6) 4 bytes decimal from hexadecimal 000C000C to 000C0010
factor.txo:$(6) 4 bytes decimal from hexadecimal 000C0010 to 000C0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2 
  :                            3 text   $equ    1
  :                            4 data   $equ    3
  :                            5 bss    $equ    5
  :                            6 sdata  $equ    6
  :                            7 
  :                            8 $(1:000A0000)
  :                            9:       $include,$binary   soso    $(text)
  :                            10:      $include,$binary   factor  $(text)
  :                            11:      $include,$binary   soso    $(data)
  :                            12:      $include,$binary   factor  $(data)
  :                            13 
  :                            14 $(0:000C0000)
  :                            15:     $include,$binary soso  $(bss, sdata)
  :                            16:     $include,$binary factor $(bss,sdata)
  :                            17 
  :                            18       $store                  image3
*EOF*
:$(00):000C0000:000C0000 :$(01):000A0000:000A00F4 :$(03):000A00F4:000A0104 :$(05):000C0000:000C000C :$(06):000C000C:000C0014 
map3.msm: object code 994 bytes: 0 errors: 0 undefined labels


</pre>



<a      name="link4"/>
<h4>9.2.3.4: Link an Output Relocatable</h4>


<p>
The fourth link is cumulative. The output is relocatable. The input
segments combine by section. Relocatable output is switched with the
relocatable location counter control <b>$(0:*4)</b>. The segment alignment
value <b>*4</b> indicates relocatable code.
<pre>

$ masmx map4 -ln

MASMX 7r2
3/map4.msm
soso.txo:$(1) 148 bytes decimal [*4] from hexadecimal 00000000 to 00000094
soso.txo:$(3) 12 bytes decimal [*4] from hexadecimal 00000000 to 0000000C
soso.txo:$(5) 12 bytes decimal [*-4] from hexadecimal 00000000 to 0000000C
soso.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000000 to 00000004
factor.txo:$(1) 96 bytes decimal [*4] from hexadecimal 00000094 to 000000F4
factor.txo:$(3) 4 bytes decimal [*4] from hexadecimal 0000000C to 00000010
factor.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000004 to 00000008
*EOF*
  :                            1: 	$include	"map_ppc.def"
  :                            2 $(0:*4)
  :                            3 	$list			2
  :                            4: 	$include,$binary	soso
06:00000000 00000037          +4 00000037
03:00000000 00000063          +7 00000063
(+05)20
03:00000004 00000008          +9 (05)20:00000008
03:00000008 A5A5A5A5          +11 A5A5A5A5
01:00000000 9421FFE0          +14 9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
01:00000004 7C0802A6          +14 
01:00000008 93E1001C          +14 
01:0000000C 90010024          +14 
01:00000010 63E10000          +14 
(+05:00008008/*10)10
01:00000014 3D200000          +14 
(+05)10-
01:00000018 81290008          +15 (05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
01:0000001C 913F0008          +15 
01:00000020 38010009          +15 
(+05:00008008/*10)10
01:00000024 3D200000          +15 
(+05)10-
01:00000028 90090008          +16 (05)10-:90090008 [0000:00008000/*10]10:3D200000 [0000]10-:81290000
(+06:00008004/*10)10
01:0000002C 3D200000          +16 
(+06)10-
01:00000030 81290004          +16 
01:00000034 801F0008          +17 801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
01:00000038 7C0049D6          +17 
01:0000003C 901F0008          +17 
(+03:00008004/*10)10
01:00000040 3D200000          +17 
(+03)10-
01:00000044 80090004          +18 (03)10-:80090004 60600000 [0001:FFFFFFB4/*02]18*/02+:(-01:FFFFFFB4/*02)18*/02+:4BFFFFB5
01:00000048 60600000          +18 
(-01:00000048/*02)18*/02+
(+01:00000048/*02)18*/02+
01:0000004C 48000049          +18 
01:00000050 61230000          +19 61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
01:00000054 801F0008          +19 
01:00000058 7C004A14          +19 
01:0000005C 901F0008          +19 
(+03:00008000/*10)10
01:00000060 3D200000          +19 
(+03)10-
01:00000064 81290000          +20 (03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
01:00000068 801F0008          +20 
01:0000006C 7C090050          +20 
01:00000070 901F0008          +20 
01:00000074 801F0008          +20 
01:00000078 60600000          +20 
01:0000007C 81610000          +21 81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
01:00000080 800B0004          +21 
01:00000084 7C0803A6          +21 
01:00000088 83EBFFFC          +21 
01:0000008C 602B0000          +21 
01:00000090 4E800020          +21 
  :                            5: 	$include,$binary	factor
06:00000004 00000058          +4 00000058
(+06)20
03:0000000C 00000004          +7 (06)20:00000000
01:00000094 9421FFF0          +10 9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
01:00000098 93E1000C          +10 
01:0000009C 63E10000          +10 
01:000000A0 64000021          +10 
01:000000A4 60600000          +10 
01:000000A8 81610000          +10 
01:000000AC 83EBFFFC          +11 83EBFFFC 602B0000 4E800020
01:000000B0 602B0000          +11 
01:000000B4 4E800020          +11 
01:000000B8 9421FFF0          +13 9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:00008000/*10)10:3D200000
01:000000BC 7C0802A6          +13 
01:000000C0 93E1000C          +13 
01:000000C4 90010014          +13 
01:000000C8 63E10000          +13 
(+03:0000800c/*10)10
01:000000CC 3D200000          +13 
(+03)10-
01:000000D0 8009000C          +14 (03)10-:80090000 60600000 [0000:FFFFFFBC/*02]18*/02+:(-01:FFFFFFBC/*02)18*/02+:4BFFFFBD
01:000000D4 60600000          +14 
(-01:ffffff28/*02)18*/02+
(+01:ffffff28/*02)18*/02+
01:000000D8 4BFFFF29          +14 
01:000000DC 81610000          +15 81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
01:000000E0 800B0004          +15 
01:000000E4 7C0803A6          +15 
01:000000E8 83EBFFFC          +15 
01:000000EC 602B0000          +15 
01:000000F0 4E800020          +15 
  :                            6 
  :                            7 	$store			rel4
*EOF*
:$(01):00000000:000000F4 :$(03):00000000:00000010 :$(05):00000000:0000000C :$(06):00000000:00000008 
map4.msm: object code 1246 bytes: 0 errors: 0 undefined labels

$ cat rel4.txo

$06:00000000
00000037
$03:00000000
00000063
$03:00000004
(05)20:00000008
$03:00000008
A5A5A5A5
$01:00000000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
(05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
(05)10-:90090008 (06:00008004/*10)10:3D200000 (06)10-:81290004
801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
(03)10-:80090004 60600000 (-01:00000048/*02)18*/02+:(01:00000048/*02)18*/02+:48000049
61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
(03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
$06:00000004
00000058
$03:0000000C
(06)20:00000004
$01:00000094
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:000000B8
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:0000800C/*10)10:3D200000
(03)10-:8009000C 60600000 (-01:FFFFFF28/*02)18*/02+:(01:FFFFFF28/*02)18*/02+:4BFFFF29
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:00000094
+CLANJAMFRIE:$06:00000000
+FACTOR:$06:00000004
+OVERCOAT:$01:000000B8
+SOSO:$01:00000000
:$01*00000004:00000000:000000F4
:$03*00000004:00000000:00000010
:$05*FFFFFFFC:00000000:0000000C
:$06*00000004:00000000:00000008

</pre>
<p>
If this link is repeated with <b>-j</b> flag, the treatment of external
references is different but the final effect the same:
<pre>

$ ../masmx map4 -lj

MASMX 7r2
3/map4.msm
soso.txo:$(1) 148 bytes decimal [*4] from hexadecimal 00000000 to 00000094
soso.txo:$(3) 12 bytes decimal [*4] from hexadecimal 00000000 to 0000000C
soso.txo:$(5) 12 bytes decimal [*-4] from hexadecimal 00000000 to 0000000C
soso.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000000 to 00000004
factor.txo:$(1) 96 bytes decimal [*4] from hexadecimal 00000094 to 000000F4
factor.txo:$(3) 4 bytes decimal [*4] from hexadecimal 0000000C to 00000010
factor.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000004 to 00000008
*EOF*
  :                            1: 	$include	"map_ppc.def"
  :                            2 $(0:*4)
  :                            3 	$list			1
  :                            4: 	$include,$binary	soso
  :                            5: 	$include,$binary	factor
  :                            6 
  :                            7 	$store			rel4
*EOF*
SOSO awaiting absolute part
ADJUSTMENT awaiting absolute part
FACTOR awaiting absolute part
:$(01):00000000:000000F4 :$(03):00000000:00000010 :$(05):00000000:0000000C :$(06):00000000:00000008 
map4.msm: object code 1301 bytes: 0 errors: 0 undefined labels

$ cat rel4.txo

$06:00000000
00000037
$03:00000000
00000063
$03:00000004
(05)20:00000008
$03:00000008
A5A5A5A5
$01:00000000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
(05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
(05)10-:90090008 [03FF:00008000/*10]10:3D200000 [03FF]10-:81290000
801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
(03)10-:80090004 60600000 (-01:FFFFFFB4/*02)18*/02+:[03FE:FFFFFFB4/*02]18*/02+:4BFFFFB5
61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
(03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
$06:00000004
00000058
$03:0000000C
(06)20:00000004
$01:00000094
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:000000B8
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:0000800C/*10)10:3D200000
(03)10-:8009000C 60600000 (-01:FFFFFF28/*02)18*/02+:[03FD:FFFFFF28/*02]18*/02+:4BFFFF29
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:00000094
+CLANJAMFRIE:$06:00000000
+FACTOR:$06:00000004
+OVERCOAT:$01:000000B8
+SOSO:$01:00000000
-SOSO:[03FD]
-ADJUSTMENT:[03FE]
-FACTOR:[03FF]
:$01*00000004:00000000:000000F4
:$03*00000004:00000000:00000010
:$05*FFFFFFFC:00000000:0000000C
:$06*00000004:00000000:00000008

</pre>
<p>
With <b>-j</b> option, external names which are found but are still
relocatable are requested again later.

<p>
Without <b>-j</b> option the request for an external name is changed into
a request relating to a location counter if the imported name is still
relocatable.

<p>
Because the cumulative link has moved the .text (counter 1) segment of
factor.txo from relocatable 00000000 to relocatable 00000094 hex,
the relative jump from function overcoat in factor.c to 
function soso in soso.c has changed from "unknown" minus 00000044 to
"unknown" minus 000000D8, or FFFFFF28

<p>
The adjusted offset addend in FFFFFF28 is placed in the relocation
stack by macro language in <b>$map</b> macro with the $info,$offset directive.

<p>
This step is necessary when three circumstances combine:
<ul>

	the offset is extracted and marked up for shift
	right after relocation, as <b>(rel:offset/*shift)</b>
	or <b>[name:offset/*shift]</b>
<pre>
</pre>

	A segment base address used in the field value
	has moved as a result of relocation
<pre>
</pre>
	target is not yet absolute and the relocation clause will
	be forwarded in the output Text Encoded Binary

</ul>
<p>
Without the <b>-j</b> option, the "unknown" is instead relocatable 00000000,
which is arithmetically identical, because function soso is at the start.

<p>
So without the <b>-j</b> option, jump root and target are on output in the
same segment. The same segment base will be added and subtracted at the next
link.

<p>
Relative jumps within one segment at source time don't cause any
relocation. masmx suppresses relocation information in
<b>location_X-location_Y</b>

if <b>location_X</b> and <b>location_Y</b> are in the same segment.


<a      name="link5"/>
<h4>9.2.3.5: Link an Accumulated Relocatable plus a New Relocatable</h4>


<p>
The fifth link adds relocatable zactor.txo to the relocatable link
output of the fourth link. The output is absolute.

<p>
<b>-b</b> option and section start addresses cause the segments to be
collected by section:
<pre>

$ masmx map5 -l

MASMX 7r2
3/map5.msm
rel4.txo:$(1) 244 bytes decimal from hexadecimal 000A0000 to 000A00F4
rel4.txo:$(3) 16 bytes decimal from hexadecimal 000B0000 to 000B0010
rel4.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
rel4.txo:$(6) 8 bytes decimal from hexadecimal 000C0000 to 000C0008
zactor.txo:$(1) 24 bytes decimal from hexadecimal 000A00F4 to 000A010C
zactor.txo:$(3) 4 bytes decimal from hexadecimal 000B0010 to 000B0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2        $set_option     "b"
  :                            3 $(1:000A0000)
  :                            4 $(3:000B0000)
  :                            5 $(5:000B8000)
  :                            6 $(6:000C0000)
  :                            7:       $include,$binary        rel4
  :                            8:       $include,$binary        zactor
  :                            9 
  :                            10       $store                  image5
*EOF*
:$(01):000A0000:000A010C :$(03):000B0000:000B0014 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map5.msm: object code 1072 bytes: 0 errors: 0 undefined labels


</pre>


<a      name="link6"/>
<h4>9.2.3.6: Incremental Link</h4>


<p>
The sixth link adds relocatable zactor.txo as an increment to an absolute.
The absolute is the earlier (2nd) -b option link of soso.txo and factor.txo

<p>
The output is identical with the link just above.
<pre>

$ ../masmx map6 -l

MASMX 7r2
3/map6.msm
image2.txo:$(1) 244 bytes decimal from hexadecimal 000A0000 to 000A00F4
image2.txo:$(3) 16 bytes decimal from hexadecimal 000B0000 to 000B0010
image2.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
image2.txo:$(6) 8 bytes decimal from hexadecimal 000C0000 to 000C0008
zactor.txo:$(1) 24 bytes decimal from hexadecimal 000A00F4 to 000A010C
zactor.txo:$(3) 4 bytes decimal from hexadecimal 000B0010 to 000B0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2 
  :                            3        $set_option     "b"
  :                            4 
  :                            5:       $include,$binary        image2
  :                            6:       $include,$binary        zactor
  :                            7 
  :                            8        $store                  image6
*EOF*
:$(01):000A0000:000A010C :$(03):000B0000:000B0014 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map6.msm: object code 1072 bytes: 0 errors: 0 undefined labels

$ diff -w image5.txo image6.txo

$ 

</pre>
<a      name="link7"/>
<h4>9.2.3.7: Link into Giant Address Space</h4>


<p>
In order to have control over code architecture in the 64-bit environment,
the next illustrations are a departure from compiler output.

<p>
In order to see all over the large address space, the entry sequence
to external-visible routines bases a literal pool, which contains
64-bit pointers to 64K parts of storage.

<pre>

MASMX 7r2
3/gsoso.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1 __giant		$set	1
  :                            2 __relocatable	$set	1
  :                            3: 	$include	"ppc_64.def"
  :                            4 	$list		2
  :                            5 __litseg $set		36
  :                            6 $(__litseg:*8,r30/__literal)
  :                            7 __base36
  :                            8: 	$include	gsoso.s
  :                            1 	.file	"soso.c"
  :                            2 	.globl clanjamfrie
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	clanjamfrie, @object
  :                            6 	.size	clanjamfrie, 4
  :                            7 clanjamfrie:
06:00000000 00000037          +8 	.int	55
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	yasimi, @object
  :                            12 	.size	yasimi, 4
  :                            13 yasimi:
03:00000000 00000063          +14 	.int	99
  :                            15 	.align 2
  :                            16 	.type	cu, @object
  :                            17 	.size	cu, 8
  :                            18 cu:
(+05)40
03:00000004 0000000000000008  +19 	.quad	startfromhere
  :                            20 	.lcomm	clearly_so.1543,8,8
  :                            21 	.type	clearly_so.1543, @object
  :                            22 	.align 2
  :                            23 	.type	separate_static_item.1542, @object
  :                            24 	.size	separate_static_item.1542, 4
  :                            25 separate_static_item.1542:
03:0000000C A5A5A5A5          +26 	.int	-1515870811
  :                            27 	.section	".text"
  :                            28 	.align 2
  :                            29 	.globl soso
  :                            30 	.type	soso, @function
  :                            31 
  :                            32 x	$equf	16, 31	# dynamic integer in the stack frame
  :                            33 
  :                            34 soso:
01:00000000 F821FFC1          +35 	stdu	1, -64(1)
01:00000004 7C0802A6          +36 	mflr	0
01:00000008 FBE10038          +37 	std   31, 56(1)	# save r31 just below the previous stack frame 
01:0000000C F8010048          +38 	std   0, 72(1)	# save LR value inside the previous stack frame
01:00000010 63E10000          +39 	mr    31, 1	# use a frame pointer in case the stack is pushed
01:00000014 FBDF0030          +40 	std	30, 48(31)	# save the literals base register
  :                            41 
01:00000018 4800000D          +42 	bl	__haulup
(+24)40
01:0000001C 0000000000000000  +43 	+	.absolute(__base36):d
  :                            44 __haulup
01:00000024 7FC802A6          +45 	mflr	30	# .literal segment 36 holds __literal table
  :                            46 			# which is accessed base_displacement with r30
  :                            47 	
01:00000028 EBDE0000          +48 	ld	30, 0(30) # LR was pointing to the pointer
  :                            49 
01:0000002C E93E0000          +50 	ld	9, __literal(	__upper48	startfromhere@ha)
(+05:00000008/*02)0e*/02-
01:00000030 E929000A          +51 	lwa	9, startfromhere@l(9)
01:00000034 913F0010          +52 	stw	9, x
  :                            53 
01:00000038 38010009          +54 	addi	0, 9, 1
  :                            55 
01:0000003C E93E0000          +56 	ld	9, __literal(	__upper48	startfromhere@ha)
(+05)10-
01:00000040 90090008          +57 	stw	0, startfromhere@l(9)
  :                            58 
01:00000044 E93E0008          +59 	ld	9, __literal(	__upper48	factor@ha)
[+0000:00000000/*02]0e*/02-
01:00000048 E9290002          +60 	lwa	9, factor@l(9)
01:0000004C E81F0012          +61 	lwa	0, x
  :                            62 
01:00000050 7C0049D6          +63 	mullw	0, 0, 9
01:00000054 901F0010          +64 	stw	0, x
  :                            65 
01:00000058 E93E0010          +66 	ld	9, __literal(	__upper48	cu@ha)
(+03:00000004/*02)0e*/02-
01:0000005C E8090004          +67 	ld	0, cu@l(9)
01:00000060 60600000          +68 	mr	3, 0
  :                            69 
[+0001:ffffff9c/*02]18*/02+
(-01:ffffff9c/*02)18*/02+
01:00000064 4BFFFF9D          +70 	bl	adjustment
01:00000068 61230000          +71 	mr	9, 3
01:0000006C 801F0010          +72 	lwz	0, x
  :                            73 
01:00000070 7C004A14          +74 	add	0, 0, 9
01:00000074 901F0010          +75 	stw	0, x
  :                            76 
01:00000078 E93E0018          +77 	ld	9, __literal(	__upper48	yasimi@ha)
(+03:00000000/*02)0e*/02-
01:0000007C E9290002          +78 	lwa	9, yasimi@l(9)
  :                            79 
01:00000080 E81F0012          +80 	lwa	0, x
01:00000084 7C090050          +81 	subf	0, 9, 0
  :                            82 
  :                            83 #	stw	0, x
  :                            84 #	lwz	0, x	# the compiler had these lines in
  :                            85 
01:00000088 60600000          +86 	mr	3, 0	# this ABI has r3 for results
  :                            87 
  :                            88 #	the geography of the stack frame is
  :                            89 #	LOW ADDRESS REPRESENTED HERE    ______________________________
  :                            90 #	STACK TOP R31 points to ------> |   saved SP (r1) 8 bytes    |
  :                            91 #					|............................|
  :                            92 #				+ 8	| next LR save area 8 bytes  |
  :                            93 #					|............................|
  :                            94 #				+ 16	| var x 4 bytes|/////////////|
  :                            95 #					|..............|.............|
  :                            96 
  :                            97 
  :                            98 
  :                            99 #				+ 48	|     saved r30 8 bytes      |
  :                            100 #					|............................|
  :                            101 #				+ 56	|     saved r31 8 bytes      |
  :                            102 #					|____________________________|
  :                            103 #	PREVIOUS STACK FRAME ---------> | previous saved r1 8 bytes  |
  :                            104 #					|............................|
  :                            105 #				+ 72	|  actual saved LR 8 bytes   |
  :                            106 
  :                            107 
  :                            108 
01:0000008C E9610000          +109 	ld	11, 0(1)	# there is complete confidence r1 unchanged
01:00000090 E80B0008          +110 	ld	0, 8(11)	# pick up LR
01:00000094 7C0803A6          +111 	mtlr	0
01:00000098 EBDF0030          +112 	ld	30, 48(31)
01:0000009C EBEBFFF8          +113 	ld	31, -8(11)
  :                            114 
01:000000A0 602B0000          +115 	mr	1,11
  :                            116 
01:000000A4 4E800020          +117 	blr
  :                            118 
  :                            119 	.size	soso, .-soso
  :                            120 	.lcomm	startfromhere,4,4
  :                            121 	.type	startfromhere, @object
  :                            122 	.ident	"GCC: (GNU) 4.2.1"
  :                            9 	$store		gsoso
  :                            10 	.align		3	# align for 64-bit literal pointer constants
*EOF*
24:00000000+(05:00008008/*10)30*/10:0000000000000000
24:00000008+[0000:00008000/*10]30*/10:0000000000000000
24:00000010+(03:00008004/*10)30*/10:0000000000000000
24:00000018+(03:00008000/*10)30*/10:0000000000000000
:$(01):00000000:000000A8 :$(03):00000000:00000010 :$(05):00000000:0000000C :$(06):00000000:00000004 :$(24):00000000:00000020 
gsoso.msm: object code 1138 bytes: 0 errors: 2 undefined labels
 
</pre>

<p>
Here the principle of basing a literal table for long base address
pointers has been collected in a header file.

<pre>

#*************************************************************
#
#		enter64.def
#
#		This file is enter64.def for source generating
#		RELOCATABLES which will be INCLUDED in 64-BIT LINKS
#		and for ABSOLUTE 64-BIT SOURCE
#
#		enter and leave macros:
#
#			enter64			frame_size_32_or_more
#
#               	return64,64		something_64_bits
#               	return64,__immediate	something
#               	return64		something_32_bits
#               	leave64
#
#		enter64 frame size gets rounded up to 32-byte blocks
#		exactly 32 bytes is enough without local variables
#
#		for variables, frame size is 32+variables_size
#
#		The frame is based on r31
#		and the variables start at frame+16, so for example
#
#		mylocal64	$equf	16, r31
#		mylocal32	$equf	24, r31
#		myother32	$equf	32, r31
#
#		enter64 bases the __literal pool on register 30
#		so that 64-bit pointers to anywhere in memory
#		can be picked up with
#
#			ld	rX, __literal(address)
#
#		Because literals are not duplicated in any one assembly
#		a very good density of literal use can be had with
#		literals which fix the upper 48 bits of the address
#
#			ld	rX, __literal(	__upper48	operand@ha)
#			lwa	rY, operand@l(rX)
#
#		And the good density of literal use minimises
#		the work of cache and tlb.
#
#		An assembly mostly generates only a handful of literals
#
#		The four return macros
#
#                       return64,64             something_64_bits
#                       return64,__immediate    something
#                       return64                something_32_bits
#                       leave64
#
#		all restore r30 and r31
#
#		The operands and jump targets named in literals
#		may be external or relocatable:
#
#			ld	r0, __literal(far_function:d)
#			mtlr	r0
#			blrl
#
#
#*************************************************************

.literal	$equ	36
__immediate	$equ	-16

p	$proc	*

enter64* $name

__FRAME	$set	(p(1, 1)+31)**-32

	$do	__FRAME<32,	$flag	frame size param 1 must be > 0

#**************************************************************
#
#		$(36) is a base_displacement segment
#		so that address constant literals are in reach
#
#		base_displacement references are never relocatable
#
#		a 64-bit constant of __base36 plus all its
#		relocation information must be generated just below here.
#
#		masmx internal function $a, called .absolute in ppc_*.def
#		stops __base36 from being a base_displacement name
#		and instead associates all its relocation information
#
#		in 64-bit absolute source the $a function obtains
#		the long absolute address immediately
#
#			+	.absolute(__base36):d
#
#		After linking,  that constant will contain the true
#		address of the segment $(36) containing literals
#
#**************************************************************

	stdu	1, -__FRAME(1)
	mflr	0
	std	31, __FRAME-8(1)	# save r31 just below
				# the previous stack frame

	std	0, __FRAME+8(1) 	# save LR in the second 64-bit word
				# of the previous stack frame

	mr	31, 1		# have a frame pointer in case
				# the stack is pushed

	std	30, __FRAME-16(31) # save the literals base register

	bl	__haulup
	+	.absolute(__base36):d
__haulup
	mflr	30		# .text segment holds literal table
				# which is accessed base_displacement

	ld	30,,30		# LR was pointing to the pointer
	$end

#*********************************************************************
#
#	the geography of the MINIMUM stack frame is
#	LOW ADDRESS REPRESENTED HERE    ______________________________
#	STACK TOP R31 points to ------> |   saved SP (r1) 8 bytes    |
#					|............................|
#				+ 8	| next LR save area 8 bytes  |
#					|............................|
#				+ 16	|     saved r30 8 bytes      |
#					|............................|
#				+ 24	|     saved r31 8 bytes      |
#					|____________________________|
#	PREVIOUS STACK FRAME ---------> | previous saved r1 8 bytes  |
#					|............................|
#				+ 40	|  actual saved LR 8 bytes   |
#
#*********************************************************************



#********************************************************************
#
#	the geography of A SAMPLE stack frame WITH LOCAL VARIABLES is
#	LOW ADDRESS REPRESENTED HERE    ______________________________
#	STACK TOP R31 points to ------> |   saved SP (r1) 8 bytes    |
#					|............................|
#				+ 8	| next LR save area 8 bytes  |
#					|............................|
#	FOR EXAMPLE		+ 16	| var y 8 bytes              |
#					|............................|
#	FOR EXAMPLE		+ 24	| var x 4 bytes|/////////////|
#					|..............|.............|
#					|			     |
#	per these examples
#				y	$equf	16, r31
#				x	$equf	24, r31



#	PREVIOUS STACK FRAME - 16	|     saved r30 8 bytes      |
#					|............................|
#	PREVIOUS STACK FRAME - 8	|     saved r31 8 bytes      |
#					|____________________________|
#	PREVIOUS STACK FRAME ---------> | previous saved r1 8 bytes  |
#					|............................|
#	PREVIOUS STACK FRAME + 8	|  actual saved LR 8 bytes   |
#
#
#*********************************************************************


p	$proc

return64* $name

	$if	p(0, 2)=64	#	return64,64	something_64_bits
	ld	3, p(1, 1)	# or
	$elseif	p(0, 2)=__immediate #	return64,__immediate	something
	li	3, p(1, 1)	# or
	$else			#	return64	something_32_bits
	lwa	3, p(1, 1)	# or
	$endif			#	leave64

leave64* $name
	ld	1,,31		# old SP is 1st word of this frame
	ld	0, 8, 1		# old LR is 2nd word of this other frame
	mtlr	0
	ld	30, -16, 1	# old base register is 2nd last word/frame
	ld	31,  -8, 1	# old frame pointer is last word in frame
	blr

	$end


MASMX 7r2
3/gfactor.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1 __giant		$set	1
  :                            2 __relocatable	$set	1
  :                            3: 	$include	"ppc_64.def"
  :                            4: 	$include	enter64.def
  :                            5 	$list		2
  :                            6 __litseg $set           36
  :                            7 $(__litseg:*8,r30/__literal)
  :                            8 __base36
  :                            9: 	$include	gfactor.s
  :                            1 	.file	"factor.c"
  :                            2 	.globl factor
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	factor, @object
  :                            6 	.size	factor, 4
  :                            7 factor:
06:00000000 00000058          +8 	.int	88
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	acu, @object
  :                            12 	.size	acu, 4
  :                            13 acu:
(+06)40
03:00000000 0000000000000000  +14 	.long	factor
  :                            15 	.section	".text"
  :                            16 	.align 2
  :                            17 	.globl adjustment
  :                            18 	.type	adjustment, @function
  :                            19 adjustment:
01:00000000 F821FFE1          +20 	enter64	32
01:00000004 7C0802A6          +20 
01:00000008 FBE10018          +20 
01:0000000C F8010028          +20 
01:00000010 63E10000          +20 
01:00000014 FBDF0010          +20 
01:00000018 4800000D          +20 
(+24)40
01:0000001C 0000000000000000  +20 
01:00000024 7FC802A6          +20 
01:00000028 EBDE0000          +20 
01:0000002C 64030021          +21 	return64,__immediate	33
01:00000030 E83F0000          +21 
01:00000034 E8010008          +21 
01:00000038 7C0803A6          +21 
01:0000003C EBC1FFF0          +21 
01:00000040 EBE1FFF8          +21 
01:00000044 4E800020          +21 
  :                            22 	.size	adjustment, .-adjustment
  :                            23 	.align 2
  :                            24 	.globl overcoat
  :                            25 	.type	overcoat, @function
  :                            26 overcoat:
01:00000048 F821FFE1          +27 	enter64	32
01:0000004C 7C0802A6          +27 
01:00000050 FBE10018          +27 
01:00000054 F8010028          +27 
01:00000058 63E10000          +27 
01:0000005C FBDF0010          +27 
01:00000060 4800000D          +27 
(+24)40
01:00000064 0000000000000000  +27 
01:0000006C 7FC802A6          +27 
01:00000070 EBDE0000          +27 
01:00000074 E93E0000          +28 	ld	9, __literal(	__upper48	acu@ha)
(+03:00000000/*02)0e*/02-
01:00000078 E8090000          +29 	ld	0, acu@l(9)
01:0000007C 60600000          +30 	mr	3,0
[+0000:ffffff80/*02]18*/02+
(-01:ffffff80/*02)18*/02+
01:00000080 4BFFFF81          +31 	bl	soso
01:00000084 E83F0000          +32 	leave64
01:00000088 E8010008          +32 
01:0000008C 7C0803A6          +32 
01:00000090 EBC1FFF0          +32 
01:00000094 EBE1FFF8          +32 
01:00000098 4E800020          +32 
  :                            33 	.size	overcoat, .-overcoat
  :                            34 	.ident	"GCC: (GNU) 4.2.1"
  :                            10 	$store		gfactor
  :                            11 	.align		3
*EOF*
24:00000000+(03:00008000/*10)30*/10:0000000000000000
:$(01):00000000:000000A0 :$(03):00000000:00000008 :$(06):00000000:00000004 :$(24):00000000:00000008 
gfactor.msm: object code 847 bytes: 0 errors: 1 undefined labels


</pre>


<p>
The seventh link places relocatables in giant absolute address space

<p>
<a href="#option_d">Option -d</a> adds the giant step component to address summary information

<pre>


$ masmx -ld map7
MASMX 7r3
3/map7.msm
gsoso.txo:$(1) 168 bytes decimal from hexadecimal 00000000 to 000000A8 +000A000000000000
gsoso.txo:$(3) 16 bytes decimal from hexadecimal 00000000 to 00000010 +000B000000000000
gsoso.txo:$(5) 12 bytes decimal from hexadecimal 00000000 to 0000000C +000B800000000000
gsoso.txo:$(6) 4 bytes decimal from hexadecimal 00000000 to 00000004 +000C000000000000
gsoso.txo:$(36) 32 bytes decimal from hexadecimal 00000000 to 00000020 +000A800000000000
gfactor.txo:$(1) 160 bytes decimal from hexadecimal 000000A8 to 00000148 +000A000000000000
gfactor.txo:$(3) 8 bytes decimal from hexadecimal 00000010 to 00000018 +000B000000000000
gfactor.txo:$(6) 4 bytes decimal from hexadecimal 00000004 to 00000008 +000C000000000000
gfactor.txo:$(36) 8 bytes decimal from hexadecimal 00000020 to 00000028 +000A800000000000
*EOF*
  :                            1 __giant	$set		1
  :                            2 
  :                            3: 	$include	"ppc64map.def"
  :                            4 
  :                            5 $(1::*000A000000000000)
  :                            6 $(36::*000A800000000000)
  :                            7 $(3::*000B000000000000)
  :                            8 $(5::*000B800000000000)
  :                            9 $(6::*000C000000000000)
  :                            10 	$list			2
  :                            11: 	$include,$binary	gsoso
06:000C000000000000:00000037  +4 00000037
03:000B000000000000:00000063  +7 00000063
03:000B000000000004:000B800000000008
                              +9 (05)40:0000000000000008
03:000B00000000000C:A5A5A5A5  +11 A5A5A5A5
01:000A000000000000:F821FFC1  +14 F821FFC1 7C0802A6 FBE10038 F8010048 63E10000 FBDF0030
01:000A000000000004:7C0802A6  +14 
01:000A000000000008:FBE10038  +14 
01:000A00000000000C:F8010048  +14 
01:000A000000000010:63E10000  +14 
01:000A000000000014:FBDF0030  +14 
01:000A000000000018:4800000D  +15 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 E93E0000
01:000A00000000001C:000A800000000000
                              +15 
01:000A000000000024:7FC802A6  +15 
01:000A000000000028:EBDE0000  +15 
01:000A00000000002C:E93E0000  +15 
01:000A000000000030:E929000A  +16 (05:00000008/*02)0E*/02-:E929000A 913F0010 38010009 E93E0000
01:000A000000000034:913F0010  +16 
01:000A000000000038:38010009  +16 
01:000A00000000003C:E93E0000  +16 
01:000A000000000040:90090008  +17 (05)10-:90090008 E93E0008 [0000:00000000/*02]0E*/02-:E9290002
01:000A000000000044:E93E0008  +17 
01:000A000000000048:E9290006  +17 
01:000A00000000004C:E81F0012  +18 E81F0012 7C0049D6 901F0010 E93E0010 (03:00000004/*02)0E*/02-:E8090004
01:000A000000000050:7C0049D6  +18 
01:000A000000000054:901F0010  +18 
01:000A000000000058:E93E0010  +18 
01:000A00000000005C:E8090004  +18 
01:000A000000000060:60600000  +19 60600000 [0001:FFFFFF9C/*02]18*/02+:(-01:FFFFFF9C/*02)18*/02+:4BFFFF9D
01:000A000000000064:48000045  +19 
01:000A000000000068:61230000  +20 61230000 801F0010 7C004A14 901F0010 E93E0018 (03:00000000/*02)0E*/02-:E9290002
01:000A00000000006C:801F0010  +20 
01:000A000000000070:7C004A14  +20 
01:000A000000000074:901F0010  +20 
01:000A000000000078:E93E0018  +20 
01:000A00000000007C:E9290002  +20 
01:000A000000000080:E81F0012  +21 E81F0012 7C090050 60600000 E9610000 E80B0008 7C0803A6
01:000A000000000084:7C090050  +21 
01:000A000000000088:60600000  +21 
01:000A00000000008C:E9610000  +21 
01:000A000000000090:E80B0008  +21 
01:000A000000000094:7C0803A6  +21 
01:000A000000000098:EBDF0030  +22 EBDF0030 EBEBFFF8 602B0000 4E800020
01:000A00000000009C:EBEBFFF8  +22 
01:000A0000000000A0:602B0000  +22 
01:000A0000000000A4:4E800020  +22 
24:000A800000000000:000B800000000000
                              +25 (05:00008008/*10)30*/10:0000000000000000
24:000A800000000008:000C000000000000
                              +26 [0000:00008000/*10]30*/10:0000000000000000
24:000A800000000010:000B000000000000
                              +27 (03:00008004/*10)30*/10:0000000000000000
24:000A800000000018:000B000000000000
                              +28 (03:00008000/*10)30*/10:0000000000000000
  :                            12: 	$include,$binary	gfactor
06:000C000000000004:00000058  +4 00000058
03:000B000000000010:000C000000000004
                              +7 (06)40:0000000000000000
01:000A0000000000A8:F821FFE1  +10 F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
01:000A0000000000AC:7C0802A6  +10 
01:000A0000000000B0:FBE10018  +10 
01:000A0000000000B4:F8010028  +10 
01:000A0000000000B8:63E10000  +10 
01:000A0000000000BC:FBDF0010  +10 
01:000A0000000000C0:4800000D  +11 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 64030021
01:000A0000000000C4:000A800000000020
                              +11 
01:000A0000000000CC:7FC802A6  +11 
01:000A0000000000D0:EBDE0000  +11 
01:000A0000000000D4:64030021  +11 
01:000A0000000000D8:E83F0000  +12 E83F0000 E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
01:000A0000000000DC:E8010008  +12 
01:000A0000000000E0:7C0803A6  +12 
01:000A0000000000E4:EBC1FFF0  +12 
01:000A0000000000E8:EBE1FFF8  +12 
01:000A0000000000EC:4E800020  +12 
01:000A0000000000F0:F821FFE1  +14 F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
01:000A0000000000F4:7C0802A6  +14 
01:000A0000000000F8:FBE10018  +14 
01:000A0000000000FC:F8010028  +14 
01:000A000000000100:63E10000  +14 
01:000A000000000104:FBDF0010  +14 
01:000A000000000108:4800000D  +15 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 E93E0000
01:000A00000000010C:000A800000000020
                              +15 
01:000A000000000114:7FC802A6  +15 
01:000A000000000118:EBDE0000  +15 
01:000A00000000011C:E93E0000  +15 
01:000A000000000120:E8090010  +16 (03:00000000/*02)0E*/02-:E8090000 60600000 [0000:FFFFFF80/*02]18*/02+:(-01:FFFFFF80/*02)18*/02+:4BFFFF81
01:000A000000000124:60600000  +16 
01:000A000000000128:4BFFFED9  +16 
01:000A00000000012C:E83F0000  +17 E83F0000 E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
01:000A000000000130:E8010008  +17 
01:000A000000000134:7C0803A6  +17 
01:000A000000000138:EBC1FFF0  +17 
01:000A00000000013C:EBE1FFF8  +17 
01:000A000000000140:4E800020  +17 
24:000A800000000020:000B000000000000
                              +20 (03:00008000/*10)30*/10:0000000000000000
  :                            13 
  :                            14 	$store			image7
*EOF*

@:000A000000000000:$(01):00000000:00000148 
@:000B000000000000:$(03):00000000:00000018 
@:000B800000000000:$(05):00000000:0000000C 
@:000C000000000000:$(06):00000000:00000008 
@:000A800000000000:$(24):00000000:00000028 
map7.msm: object code 1448 bytes: 0 errors: 0 undefined labels

$ cat image7.txo

@:06:000C000000000000
$06:00000000
00000037
@:03:000B000000000000
$03:00000000
00000063
$03:00000004
000B800000000008
$03:0000000C
A5A5A5A5
@:01:000A000000000000
$01:00000000
F821FFC1 7C0802A6 FBE10038 F8010048 63E10000 FBDF0030
4800000D 000A800000000000 7FC802A6 EBDE0000 E93E0000 E929000A
913F0010 38010009 E93E0000 90090008 E93E0008 E9290006
E81F0012 7C0049D6 901F0010 E93E0010 E8090004 60600000
48000045 61230000 801F0010 7C004A14 901F0010 E93E0018
E9290002 E81F0012 7C090050 60600000 E9610000 E80B0008
7C0803A6 EBDF0030 EBEBFFF8 602B0000 4E800020
@:24:000A800000000000
$24:00000000
000B800000000000 000C000000000000 000B000000000000
000B000000000000
$06:00000004
00000058
$03:00000010
000C000000000004
$01:000000A8
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 64030021 E83F0000
E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
$01:000000F0
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 E93E0000 E8090010
60600000 4BFFFED9 E83F0000 E8010008 7C0803A6 EBC1FFF0
EBE1FFF8 4E800020
$24:00000020
000B000000000000
+ADJUSTMENT:$01:000A0000000000A8
+CLANJAMFRIE:$06:000C000000000000
+FACTOR:$06:000C000000000004
+OVERCOAT:$01:000A0000000000F0
+SOSO:$01:000A000000000000
:$01*00000000:00000000:00000148
:$03*00000000:00000000:00000018
@:05:000B800000000000
:$05*00000000:00000000:0000000C
:$06*00000000:00000000:00000008
:$24*00000000:00000000:00000028


</pre>
<p>
Segments are always gathered by section with giant addresses. The
giant addresses are retrieved from the link control source or the
text encoded binary input

<p>
The <b>$map</b> macro used in giant space has the structure illustrated
below

<p>
Where operand fields may relocate out of their target field range
and then relocate back into range again as multiple relocation
clauses are applied, a value <b>sum</b> is maintained at 192-bits precision.

<p>
The <a href="#info_range">$info</a> subcommand <a href="#info_range">$range_check</a>
requires only the final value to be in field range

<p>
The <a href="#pushrel">$pushrel</a> subcommand <a href="#long_absolute">$long_absolute</a>
allows a segment base value or external label value 192 bits in size to be retrieved
<pre>

p	$proc
"$map"*	$name

<div	style="color:blue">
p	$proc
superword* $name
parts	$set	p(1,1:)
"$data"	$set,$binary	p(1,1:parts)

column	$set	$bits

part	$do	parts-1,	<a style="color:red">relocate	p(1, 1:part)</a>
	$load,$bits	$data
	$end	. SUPERWORD
</div>

<a	style="color:red">
p	$proc
relocate* $name


rel_params $pushrel	p(1,1)

value	$pushrel,$long_absolute	p(1,1)

bits    $set    rel_params\2
scale   $set    rel_params\3
offset  $set    rel_params\4
descant $set    rel_params\5

limit   $set    1*/bits
mask    $set    limit-1
unmask  $set    ^(mask*/scale)

	$if	scale^=column
sum*	$set	0
column*	$set	scale
	$endif

sum*	$set	value+sum

	$if	descant<0

field	$set	sum+offset
	$info,$range_check	field
field	$set	(field*/descant)**mask

	$else

field	$set	sum+(($data/*scale)**mask)

	$info,$range_check	field

	$endif


"$data"* $set	(field*/scale)++($data**unmask)

	$end	. RELOCATE
</a>


index	$do	p(),	<a style="color:blue">superword	p(index, 1)</a>
	$end	. $map

</pre>


<a      name="link8"/>
<h4>9.2.3.8: Incremental Link in Giant Address Space</h4>


<p>
The eighth link increments relocatable gzactor.txo on the end of the giant
address absolute from the seventh link.

<p>
<a href="#option_d">Option -d</a> at the linking assembly adds the giant step component to address summary information


 
<pre>

$ ../cat gzactor.msm
__relocatable	$set	1
__giant		$set	1

	$include	"ppc_64.def"
	$include	 enter64.def

__litseg $set           36
$(__litseg:*8,r30/__literal)
__base36

	$if	1
$(.data)
myword	.int		99
	$endif

$(.text)
zactor*
	enter64	32
        ld	9, __literal(	__upper48	factor@ha)
        lwz	0, factor@l(9)

	ld	10, __literal(	__upper48	myword@ha)
	lwz	11, myword@l(10)

	bl	soso

	leave64

	$store	gzactor

$ masmx -ld map8
MASMX 7r3
3/map8.msm
image7.txo:$(1) 328 bytes decimal from hexadecimal 00000000 to 00000148 +000A000000000000
image7.txo:$(3) 24 bytes decimal from hexadecimal 00000000 to 00000018 +000B000000000000
image7.txo:$(5) 12 bytes decimal from hexadecimal 00000000 to 0000000C +000B800000000000
image7.txo:$(6) 8 bytes decimal from hexadecimal 00000000 to 00000008 +000C000000000000
image7.txo:$(36) 40 bytes decimal from hexadecimal 00000000 to 00000028 +000A800000000000
gzactor.txo:$(1) 88 bytes decimal from hexadecimal 00000148 to 000001A0 +000A000000000000
gzactor.txo:$(3) 4 bytes decimal from hexadecimal 00000018 to 0000001C +000B000000000000
gzactor.txo:$(36) 16 bytes decimal from hexadecimal 00000028 to 00000038 +000A800000000000
*EOF*
  :                            1 __giant	$set		1
  :                            2: 	$include	"ppc64map.def"
  :                            3 	$list		 1
  :                            4 
  :                            5 .	$set_option	"b"
  :                            6 
  :                            7: 	$include,$binary	image7
  :                            8: 	$include,$binary	gzactor
  :                            9 
  :                            10 	$store			image8
*EOF*

@:000A000000000000:$(01):00000000:000001A0 
@:000B000000000000:$(03):00000000:0000001C 
@:000B800000000000:$(05):00000000:0000000C 
@:000C000000000000:$(06):00000000:00000008 
@:000A800000000000:$(24):00000000:00000038 
map8.msm: object code 1756 bytes: 0 errors: 0 undefined labels

$ cat image8.txo

@:06:000C000000000000
$06:00000000
00000037
@:03:000B000000000000
$03:00000000
00000063
$03:00000004
000B800000000008
$03:0000000C
A5A5A5A5
@:01:000A000000000000
$01:00000000
F821FFC1 7C0802A6 FBE10038 F8010048 63E10000 FBDF0030
4800000D 000A800000000000 7FC802A6 EBDE0000 E93E0000 E929000A
913F0010 38010009 E93E0000 90090008 E93E0008 E9290006
E81F0012 7C0049D6 901F0010 E93E0010 E8090004 60600000
48000045 61230000 801F0010 7C004A14 901F0010 E93E0018
E9290002 E81F0012 7C090050 60600000 E9610000 E80B0008
7C0803A6 EBDF0030 EBEBFFF8 602B0000 4E800020
@:24:000A800000000000
$24:00000000
000B800000000000 000C000000000000 000B000000000000
000B000000000000
$06:00000004
00000058
$03:00000010
000C000000000004
$01:000000A8
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 64030021 E83F0000
E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
$01:000000F0
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 E93E0000 E8090010
60600000 4BFFFED9 E83F0000 E8010008 7C0803A6 EBC1FFF0
EBE1FFF8 4E800020
$24:00000020
000B000000000000
$03:00000018
00000063
$01:00000148
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000028 7FC802A6 EBDE0000 E93E0000 80090004
E95E0008 816A0018 4BFFFE7D E83F0000 E8010008 7C0803A6
EBC1FFF0 EBE1FFF8 4E800020
$24:00000028
000C000000000000 000B000000000000
+ADJUSTMENT:$01:000A0000000000A8
+CLANJAMFRIE:$06:000C000000000000
+FACTOR:$06:000C000000000004
+OVERCOAT:$01:000A0000000000F0
+SOSO:$01:000A000000000000
+ZACTOR:$01:000A000000000148
:$01*00000000:00000000:000001A0
:$03*00000000:00000000:0000001C
@:05:000B800000000000
:$05*00000000:00000000:0000000C
:$06*00000000:00000000:00000008
:$24*00000000:00000000:00000038

</pre>

<a      name="link9"/>
<h4>9.2.3.9: Linking with Void Inclusion</h4>

<p>
The ninth and tenth links have void inclusions

<p>
A void inclusion retrieves addresses from another binary without
including its code. The new text-encoded binary is a separate load


<p>
relocatable zactor.txo is incremented onto the storage map of absolute
image2 = soso + factor and imports its export labels, but does not include
image2

<p>
A link with void inclusions may import labels but have an otherwise 
independent storage map

<pre>

$ ../masmx map9 -l

MASMX 7r2
3/map9.msm
image2.txo:$(1) 244 bytes decimal from hexadecimal 000A0000 to 000A00F4
image2.txo:$(3) 16 bytes decimal from hexadecimal 000B0000 to 000B0010
image2.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
image2.txo:$(6) 8 bytes decimal from hexadecimal 000C0000 to 000C0008
zactor.txo:$(1) 24 bytes decimal from hexadecimal 000A00F4 to 000A010C
zactor.txo:$(3) 4 bytes decimal from hexadecimal 000B0010 to 000B0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2 
  :                            3        $set_option     "b"
  :                            4 
  :                            5        $include,$void          image2
  :                            6:       $include,$binary        zactor
  :                            7 
  :                            8        $store                  image9
*EOF*
:$(01):000A0000:000A010C :$(03):000B0000:000B0014 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map9.msm: object code 352 bytes: 0 errors: 0 undefined labels

$ cat image9.txo

$03:000B0010
00000063
$01:000A00F4
3D20000C 80090004 3D40000B 816A0010 4BFFFEFD 4E800020
+ADJUSTMENT:$01:000A0094
+CLANJAMFRIE:$06:000C0000
+FACTOR:$06:000C0004
+OVERCOAT:$01:000A00B8
+SOSO:$01:000A0000
+ZACTOR:$01:000A00F4
:$01*00000000:000A0000:000A010C
:$03*00000000:000B0000:000B0014
:$05*00000000:000B8000:000B800C
:$06*00000000:000C0000:000C0008


</pre>


<a      name="link10"/>
<h4>9.2.3.10: Linking With Void Inclusion in Giant Address Space</h4>


<p>
The tenth link does a void include with giant addresses.
<a href="#option_d">Option -d</a> adds the giant step component to address summary information

<pre>

$ masmx -ld map10
MASMX 7r3
3/map10.msm
image7.txo:$(1) 328 bytes decimal from hexadecimal 00000000 to 00000148 +000A000000000000
image7.txo:$(3) 24 bytes decimal from hexadecimal 00000000 to 00000018 +000B000000000000
image7.txo:$(5) 12 bytes decimal from hexadecimal 00000000 to 0000000C +000B800000000000
image7.txo:$(6) 8 bytes decimal from hexadecimal 00000000 to 00000008 +000C000000000000
image7.txo:$(36) 40 bytes decimal from hexadecimal 00000000 to 00000028 +000A800000000000
gzactor.txo:$(1) 88 bytes decimal from hexadecimal 00000148 to 000001A0 +000A000000000000
gzactor.txo:$(3) 4 bytes decimal from hexadecimal 00000018 to 0000001C +000B000000000000
gzactor.txo:$(36) 16 bytes decimal from hexadecimal 00000028 to 00000038 +000A800000000000
*EOF*
  :                            1 __giant	$set		1
  :                            2: 	$include	"ppc64map.def"
  :                            3 	$list		 2
  :                            4 
  :                            5 	$include,$void		image7
  :                            6: 	$include,$binary	gzactor
03:000B000000000018:00000063  +4 00000063
01:000A000000000148:F821FFE1  +7 F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
01:000A00000000014C:7C0802A6  +7 
01:000A000000000150:FBE10018  +7 
01:000A000000000154:F8010028  +7 
01:000A000000000158:63E10000  +7 
01:000A00000000015C:FBDF0010  +7 
01:000A000000000160:4800000D  +8 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 E93E0000
01:000A000000000164:000A800000000028
                              +8 
01:000A00000000016C:7FC802A6  +8 
01:000A000000000170:EBDE0000  +8 
01:000A000000000174:E93E0000  +8 
01:000A000000000178:80090004  +9 [0000]10-:80090000 E95E0008 (03)10-:816A0000 [0001:FFFFFFC4/*02]18*/02+:(-01:FFFFFFC4/*02)18*/02+:4BFFFFC5
01:000A00000000017C:E95E0008  +9 
01:000A000000000180:816A0018  +9 
01:000A000000000184:4BFFFE7D  +9 
01:000A000000000188:E83F0000  +10 E83F0000 E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
01:000A00000000018C:E8010008  +10 
01:000A000000000190:7C0803A6  +10 
01:000A000000000194:EBC1FFF0  +10 
01:000A000000000198:EBE1FFF8  +10 
01:000A00000000019C:4E800020  +10 
24:000A800000000028:000C000000000000
                              +13 [0000:00008000/*10]30*/10:0000000000000000
24:000A800000000030:000B000000000000
                              +14 (03:00008000/*10)30*/10:0000000000000000
  :                            7 
  :                            8 	$store			image10
*EOF*

@:000A000000000000:$(01):00000000:000001A0 
@:000B000000000000:$(03):00000000:0000001C 
@:000B800000000000:$(05):00000000:0000000C 
@:000C000000000000:$(06):00000000:00000008 
@:000A800000000000:$(24):00000000:00000038 
map10.msm: object code 732 bytes: 0 errors: 0 undefined labels

$ cat image10.txo

@:03:000B000000000000
$03:00000018
00000063
@:01:000A000000000000
$01:00000148
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000028 7FC802A6 EBDE0000 E93E0000 80090004
E95E0008 816A0018 4BFFFE7D E83F0000 E8010008 7C0803A6
EBC1FFF0 EBE1FFF8 4E800020
@:24:000A800000000000
$24:00000028
000C000000000000 000B000000000000
+ADJUSTMENT:$01:000A0000000000A8
+CLANJAMFRIE:$06:000C000000000000
+FACTOR:$06:000C000000000004
+OVERCOAT:$01:000A0000000000F0
+SOSO:$01:000A000000000000
+ZACTOR:$01:000A000000000148
:$01*00000000:00000000:000001A0
:$03*00000000:00000000:0000001C
@:05:000B800000000000
:$05*00000000:00000000:0000000C
@:06:000C000000000000
:$06*00000000:00000000:00000008
:$24*00000000:00000000:00000038

</pre>

<a      name="describe"/>
<h1>10:  Describing Target Architecture in Text</h1>

<a      name="describe1"/>
<h2>10.1: Establishing your Syntax</h2>


<p>
When masmx starts running,
<ul>
	semicolon is line continuation
<pre></pre>

	period is line termination (comment)
<pre></pre>

	period does not terminate the line if it is
	followed immediately with a nonspace symbol
        <pre>

		$include	file.name
		+		1.8	. floating value

        </pre>
	Any other comment character terminates the
	line unconditionally:
        <pre>

		$lterm		'#'

		+		1.75	#floating value

	</pre>
	No symbol inside single or double quotes terminates the line
<pre></pre>

	text string delimiter is "
<pre></pre>

	substring delimiter is colon
<pre></pre>

	leading zero on a number is hex
<pre></pre>
	numbers beginning 1..9 are decimal
<pre></pre>
	numbers beginning \ are bit-pattern binary

</ul>
<p>

If semicolon shall not be line continuation
<a href="#cont_char">$cont_char</a> should be changed first

<p>
For no line continuation at all
<pre>

	$cont_char       0

</pre>
<p>
Continuation character is not recognised if if is followed immediately
by a nonspace symbol
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	$cont_char       '\'
CONT_CHAR=\
	$word		32
	+		\10101010\	bit pattern 0xAA and line continue
			*/16\		shift left 16 and line continue
			++3     	. OR 3
	$end
  :                            1  $cont_char '\'
  :                            2  $word  32
00:00000000 00AA0003          +3  +  \10101010*/16++3  . OR 3
  :                            4  $end
:$(00):00000000:00000001 
-INPUT>>: object code 54 bytes: 0 errors: 0 undefined labels

</pre>
<p>
For semiciolon as comment character
<pre>

	$lterm  ';'

</pre>
<p>
For strings to be bounded by apostrophe
<pre>

	$quote  027

</pre>
<p>
or
<pre>

	$quote  ''''

</pre>
<p>
See <a href="#text_string">4.3.5: Text Strings</a>
<a href="#notate2">4.2.2.1: Number Strings</a>
<a href="#quote">8.42: $quote directive</a>

<p>
For substring delimiter to be period
<pre>

	<a href="#sterm">$sterm</a>  '.'

</pre>
<p>
<a href="#octal">$octal</a> directive switches
number strings with leading zero to octal.
Listing shows addresses and generated code in octal
<pre>

	$octal

</pre>
<p>
<a href="#hex">$hex</a> directive switches to default binary
notation.<br> Number strings with leading zero are hexadecimal.
Listing shows addresses and generated code in hexadecimal
<pre>

	$hex

</pre>
<p>
See also option<a href="#option_c">-c</a> C language notation
and option <a href="#option_m">-m</a> Motorola old notation

<p>
For leading 0... to be octal and leading 0x... to be hex
<pre>

	<a href="#set_option">$set_option</a>     <a href="#option_c">"c"</a>

</pre>
For leading $... to be hex
<pre>

	<a href="#set_option">$set_option</a>     <a href="#option_m">"m"</a>

</pre>

<p>
If source code contains number strings with notation
suffix like 123q or 0abaH
<pre>

        <a href="#suffix">$suffix</a> 2

</pre>


<a href="#option_m">Option -m</a> masks labels which start with $
unless they are referenced in quotes

<p>
masmx internal function names start with $

<p>
Source code may already use different names for internal macros
which in masmx are for example
<a href="#location_c">$</a> location counter and
<a href="#labeltyp">$t</a> label type

<pre>

            $lterm		';'
            $sterm		'.'	; period can be in labels
					; and structure joins

.           $equ,"$function"    "$"	; . is location counter
.locator_id $equ,"$function"    "$r"	;
.class      $equ,"$function"    "$t"	; .class is label type

</pre>
Referenced Without the quotes, $ $r $t return their functional value instead
of their identity. See also <a href="#option_q">option -Q</a>

<p>
Quotes are necessary to give "$" "$r" "$t" new names

<p>
Directives and other names beginning with $ are always recognised in the command
field and no command name may be typed in quotes.<br>When Motorola old notation
<a href="#option_m">flag -m</a> is opted, labels starting with $ are only
recognised within quotes in the subcommand and argument fields

<p>
Code may already invoke directives with different names.
Masmx directives may be assigned alias names
<pre>

.equ    $equ,"$directive"       "$equ"
.if     .equ,"$directive"       "$if"
.elseif .equ,"$directive"       "$elseif"
.else   .equ,"$directive"       "$else"
.endif  .equ,"$directive"       "$endif"
.macro  .equ,"$directive"       "$proc"
.macend .equ,"$directive"       "$end"

</pre>
<p>
If code issues directives with no masmx equivalent, they may
be implemented as macros.
<pre>

.org*   .macro
$(0:.org(1,1))
	.macend

.align* .macro
granule $set   1*/.align(1,1)
	$res    (.+granule-1**-granule)-.
	.macend

.globl*	.macro
".globl(1,1)"**	$blank
	.macend

</pre>

<p>
<a href="#text">$text</a> directive searches and translates text sequences
in source code

<p>
If code contains operators which are not
<pre>

= ^= > < -- ++ /* */ ** + - /// // / * *+ *- ^ ()

</pre>
<p>
them the operators need text translation on source code read, for example
<pre>

	$text   /!=/^=/
	$text	\<=\-1<\
	$text	/>=/+1>/
	$text   \%\///\
	$text   /|/++/
	$text   \<<\*/\
	$text   \>>\/*/
	$text   /&/**/
	$text   /^/--/
	$text   /~/^/

</pre>
<p>
or
<pre>

	$text   / EQ /=/
	$text   / NE /^=/
	$text   \ LT \<\
	$text   / GT />/
	$text	\ LE \-1<\
	$text	/ GE /+1>/
	$text   \ MOD \///\
	$text   / OR /++/
	$text   \ SHL \*/\
	$text   \ SHR \/*\
	$text   \ ASHR \*/-\
	$text   / AND /**/
	$text   / XOR /--/
	$text   / NOT /^/

</pre>
<p>
All $text directive lines must be adjacent. For efficiency 
masmx will only search one sequence of $text directives in
the label table

<a      name="describe2"/>
<h2>10.2: Describing the Target Architecture</h2>


<p>
The directives which are central to masmx are described here
in related groups and described in alphabetical order in
<a href="#directives">8: Directives</a>

<p>
All directives appear in the instruction field of the assembly 
language line.



<a      name="architecture"/>
<h3>10.2.1: $word, $byte, $quantum, $awidth</h3>

	       
<p>
No assumption is made that the machine has a word size like
8, 16, 32 or 64, or that its address quantum is an 8-bit byte.<br>
That information is retrieved from macro text in header files

<p>
These four directives describe the basics of the machine
to masmx.
<pre>


	<a href="#word">$word</a>   bits_in_computer_word

</pre>
<p>
$word defines the smallest amount of code that can be generated 
from one source line. See also <a hef="#quantum">$quantum</a>. One guide to selecting 
word is the size of the smallest instruction in the instruction
set. If the machine has single-octet instructions, or can fetch
instructons from any octet address, $word must be 8

<p>
$word 32 is for example suitable for PowerPC, $word 16 for m68k or ColdFire.
<pre>

	<a href="#byte">$byte</a>   bits_per_character

</pre>
<p>
$byte defaults to 8. It can be set to anything and character 
strings are packed accordingly.
<pre>

	<a href="#quantum">$quantum</a>  bits_in_addressable_location

</pre>
<p>
$quantum is the same as $word for very few computer 
architectures. Nevertheless $word automatically sets 
$quantum and $awidth. For PowerPC and Alpha:
<pre>

	$word      32
	$quantum   8

</pre>
<p>
are suitable settings.
<pre>

	<a href="#awidth">$awidth</a>         bits_in_address

</pre>
<p>
$awidth describes how many bits are used to express 
a load address in the the assembly output file. 8-bit 
microprocessors and microcontrollers have a word size 
of 8 but usually an address width of 16, so it is 
necessary to override the default address width set 
by $word:
<pre>

	$word           8
	$awidth         16

</pre>
<p>
$awidth has a second part for the giant part of
address space, for example:
<pre>

	$awidth         32:64

</pre>
<p>
This allows the 32-bit location counters to be stepped
through astronomic space when constructing giant code
and data. One instruction stream or array scalar may only
be constructed to a size of 4 gigaquanta, but an array
of either may be constructed up to 2 power 192 in size

<p>
See also <a href="#file_formats">9: Output File Formats, Relocation and Linking,
			Giant Address Spaces, Interfacing with GNU Tools</a>


<a      name="macro"/>
<h3>10.2.2: $form, $proc, $name, $end</h3>


<p>
These four directives are the building blocks of machine
instructions and architectural descriptors.

<a      name="uform"/>
<h4>10.2.2.1: The $form Template</h4>
<pre>

label   <a href="#form">$form</a>   bit_field_width, ...,bit_field_width

</pre>
<p>
$form describes a microstructure, especially an instruction 
layout, of any size up to 192 bits. For example, load/store
instructions for PowerPC have the layout
<pre>

"$load_store_instruction" $form   6, 5, 5, 16    


</pre>
<a      name="uproc"/>
<h4>10.2.2.2: The $proc Header</h4>
<pre>      

label   <a href="#proc">$proc</a>

</pre>
<p>
$proc begins an inline macro which may be used in the command field
(a $func is a value-generating macro used in expressions).

<p>
The label on a $proc or a $func can only be used as a macro
call if it has an asterisk* to make it visible outside the macro.

<p>
In the following example, "p" is not visible outside the macro,
and could be used as the header label of other macros without problems.

<p>
Because "p" is not visible outside the macro, the macro can only be
called with the names "lwz" and "stw"

<p>
The label of a $proc is used functionally to 
reference actual arguments, for example 
<pre>

p       $proc
	.
lwz*	$name	OPCODE_LWZ
stw*	$name	OPCODE_STW
	.
	$instruction_form   p(0, 0), p(1, 1) .index\p(1, 2), p(1, 2)
	$end

</pre>
<p>
p(0, 0) references the command on the call line,
p(1, 1) the first argument subfield. See Section 
4.2.3.2.2.3: Macro Parameter Reference


<a      name="uname"/>
<h4>10.2.2.3: The $name Entry Point</h4>
 <pre> 

label*   <a href="#name">$name</a>   value

</pre>
<p>
$name lines are entry points in $procs and $funcs.

<p>
$name assigns a value to the call name which can be
referenced as any of p(0, 1) or p(0, 0) or <b>$n</b>

<p>
The label* on a $name directive can only be used to call the
macro if it is made visible outside the macro by being promoted
with an asterisk*

<p>
One $proc macro may generate several instructions
with similar layout. Such a macro has several
$name entry points.

<a      name="uend"/>
<h4>10.2.2.4: The $end Macro Footer</h4>

<p>
<a href="#end">$end</a> ends a subassembly (the macro or the main assembly).


<a      name="usample"/>
<h4>6.2.2.5: Minimal Instruction Macro Example</h4>

<p>
$form, $proc and $name and $end describe an imaginary computer
architecture to the assembler:
<pre>

standard_format $form   8, 16

instruction     $proc

load*           $name   0
store*          $name   1
add*            $name   2
subtract*       $name   3

		standard_format     $n, instruction(1, 1)

		$end

</pre>
<p>
The label on a $proc, a $func or a $name can only be used as a macro
call if it has an asterisk* to make it visible outside the macro.

<p>
"instruction" is not visible outside the macro, and can be used as the
header label of other macros.

<p>
These lines of code
<pre>

	load    4094
	add     4097
	subtract 100
	store   2047

</pre>
<p>
will generate
<pre>

	000ffe
	021001
	030064
	0107ff

</pre>


<a      name="u2passproc"/>
<h4>10.2.2.6: The Two-pass $proc</h4>


label   $proc	*

<p>
If the first argument on a $proc line is * then the $proc is two-pass
in the second pass of the main assembly.

<p>
This allows forward references to local labels within the $proc.

<p>
Labels defined in a $proc are dropped when the $end image is encountered, unless they  are flagged*** for visibility to one or more higher assembly 
levels.

<p>
Labels should only be promoted if other parts of the assembly need them,
but they may be forward-referenced within the macro.

<p>
The forward reference need not be resolved on the first assembly pass.

<p>
On the second pass, a preliminary pass within the macro expansion is
necessary for any labels which are forward-referenced and not global.



<a      name="uprocaside"/>
<h4>10.2.2.7 The Out of Line $proc</h4>


<p>
A location counter $(<i>counter</i>) may be coded
as the first or second argument on a $proc directive
<pre>

p	$proc	* $(4)
enter*	$name
	.
	.
	$end

aside*	$proc	$(6)
	.
	.
	$end

</pre>
<p>
If the two-pass flag * is present it is the first argument
and $(<i>counter</i>) is the second argument



<a      name="unested"/>
<h4>10.2.2.8: Nested Macro Descriptions</h4>

<p>
Macros are mostly defined one at a time.  They can call each other to
a large nesting depth:
<pre>

p*	$proc
	+	$l
	q
	$end

q*	$proc
	+	$l
	r
	$end

r*	$proc
	+	$l
	$end

</pre>
<p>
A command "p" also causes "q" and "r" to assemble.

<p>
Macro descriptions may also be written in a nested way:
<pre>

one*	$proc
two*	$proc
three*	$proc
	$end
	three
	$end
	two
	$end

</pre>
<p>
This is rarely necessary but may be an advantage.

<p>
"one" causes "two" to exist and to be called, and the call "two"
causes "three" to exist and to be called.

<p>
"one" exists during the whole of the main assembly. "two" exists when
"one" is subassembling. "three" exists when "two" is subassembling.

<p>
The macros "p" "q" and "r" are now described in a nested way, which
makes "q" and "r" invisible most of the time:
<pre>

p*      $proc
        +       $l
q*      $proc
        +       $l
r*      $proc
        +       $l
        $end
        r
        $end
        q
        $end

</pre>
<p>
So command "p" causes "q" to exist and to be called, and that causes
"r" to exist and to be called.

<p>
The names of inner macros are not visible to the main assembly. 

<p>
It's possible to declare one macro within another in order to
repeat-call the inner macro at the point where it's declared
($do only repeats one line, but that line can be a macro call):
<pre>

macro1*	$proc

	.
	.

p	$proc
copyright* $name
	load	start+A_LOT-index
	store	start+A_LOT-index+1
	$end

index	$do	A_LOT,	copyright

	.
	.

	$end

</pre>

<a	name="legacyx"/>
<h2>10.3: Synthesising Legacy Automatic Macros</h2>

<a      name="legacyfun"/>
<h3>10.3.1: Synthesising Legacy Functional Macros</h3>

<p>
The developer using masmx can implement function macros to replace
fixed functions of other assemblers. For example:

<p>
A legacy assembler may have a fixed macro <b>@</b>, meaning
"location counter of variables".

<p>
The developer using masmx can implement this function with these lines:
<pre>

@*	$func
	$return	$(1)
	$end

</pre>
<p>
To explain these lines in detail:
<ul>

	<pre></pre><b>@</b> is a label like any other label.
	It's the label of the macro.

	<pre></pre>there is an asterisk on <b>@*</b> to make it visible
	to the calling assembly

	<pre></pre><b>$func</b> is the directive at the head
	of a function macro

	<pre></pre>a function macro is a macro which returns a value
	at assembly time. Other kinds of macros generate code

	<pre></pre>the returned value is accessed in this case with the 	label <b>@</b>

	<pre></pre>functional values are tokens in expressions:
	<b>44/@+1*2++018</b>

	<pre></pre><b>$return</b> is a directive which returns
	the value to its right

	<pre></pre>the value in this case is the current state
	of a location counter

	<pre></pre>here, the returned value is location counter one.
	In the supplied definition 8051.def, <b>$(1)</b> counts
	the locations filled by variables. <b>$</b> is a masmx internal
	function name, meaning "location counter."

	<pre></pre><b>$end</b> ends any macro started with
	<b>$func</b> or <b>$proc</b>. 

	<pre></pre><b>$end</b> outside a macro ends the assembly.

	<pre></pre>the result size of a user-written function macro
	is 192 bits


</ul>

<p>
Here are a couple of assemblies which use function macro "@"
<pre>

MASMX/24592 1r1X
@.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        620:         $list   2
  :                        621: @*      $func
  :                        622:         $note   You Said @ so I think you mean the
  :                        623:         $note   location counter for variables
  :                        624:         $return $(1)
  :                        625:         $end
  :                        692:         $list   2   
  :                        693: $(1:1024)
  :                        2: 
  :                        3: first_buffer VAR        2048
Note: @.msm Line 4: You Said @ so I think you mean the
Note: @.msm Line 4: location counter for variables
00:0000 0C63          +4         +       @+99
*EOF*:$(00):0000:0002 :$(01):0400:0C00 
Object Code 58 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
The target may need little-endian integers or some other
non-canonical number format  

<a      name="legacycom"/>
<h3>10.3.2: Synthesising Legacy Command Macros</h3>

<p>
masmx generates big-endian number values. Commands like DW, DD
which other assemblers have for generating constants are macros
in masmx

<p>
8051 developers use for example an integer-generating command <b>DW</b>

<p>
A command <b>DW</b> is implemented in masmx macro text to generate
16-bit little-endian integer constants
<pre>


MASMX/24592 1r1X
@.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        72:         $list   2
  :                        73: dw*     $proc
  :			   74: ?       $do dw(1), +  dw(1,?), dw(1,?)/*8:d  
  :                        75:         $note   You like to be in Little End Land?
  :                        76:         $note   Here you am!
  :                        77:         $end
  
  :                        624:         $list   2
  :                        625: @*      $func
  :                        626:         $note   You Said @ so I think you mean the
  :                        627:         $note   location counter for variables
  :                        628:         $return $(1)
  :                        629:         $end
  
  :                        696:         $list   2   
  :                        697: $(1:1024)
  :                        2: 
  :                        3: first_buffer VAR        2048

Note: @.msm Line 4: You Said @ so I think you mean the
Note: @.msm Line 4: location counter for variables
Note: @.msm Line 4: You like to be in Little End Land?
Note: @.msm Line 4: Here you am!
00:0000 630C          +4         dw      @+99
*EOF*:$(00):0000:0002 :$(01):0400:0C00 
Object Code 58 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
That is an example of a user written function ("@") used as
an token in an expression. Plus an example of a user-written
procedural macro, "DW".

<p>
A procedural macro generates code and runs from the
directive $proc to the directive $end

<p>
A function macro returns a value to an expression and runs from
the directive $func to the directive $end

<p>
The "DW" macro contains (apart from $note directives) these lines:
<pre>

dw*     $proc  
?       $do     dw(1),  +       dw(1, ?), dw(1, ?)/*8:d
        $end 

</pre>
<p>
To explain the <b>DW</b> macro
<ul>

	<b>dw</b> is a label like other labels. It's the label of the macro
<pre></pre>
	<b>dw*</b> has an asterisk to make it visible to the calling
	assembly
<pre></pre>
	<b>$proc</b> is the directive at the start of a
	code-producing macro
<pre></pre>
	the application writer may string <b>dw</b> values on a
	line, with a syntax:
<pre>

		dw	144, labelname, 15*90

</pre>
	therefore the the macro uses a <b>$do</b> directive, and
	uses a tag <b>?</b> on the <b>$do</b> to index into
	the actual arguments
<pre></pre>
	<b>?</b> is a label like any other. Its choice is arbitrary.
	<b>?</b> has no asterisk, so it only exists while the macro
	<b>dw</b> is subassembling.

<pre></pre>
	The label of a <b>$do</b>, here <b>?</b>, is an incrementing tag.
	It starts from 1 and goes up.
<pre></pre>
	<b>dw(1)</b> is the number of comma-separated
	subfields in the first argumentof <b>dw</b>. It's the repeat
	count. Here its value is one for the one actual parameter
	<b>@+99</b>
<pre></pre>
	the repeat count after any <b>$do</b>, here <b>dw(1)</b>,
	is followed by
	a comma. The rest of the line is a line of assembly code which
	gets repeated. This line usually contains some parameterised
	values.
<pre></pre>
	In the <b>dw</b> macro, the inner line of assembly code is
<pre>

		+       dw(1, ?), dw(1, ?)/*8:d

</pre>
        here this line is assembled once only, for the one actual
	parameter <b>@+99</b>
<pre></pre>
	The parameter paraform 
<pre>
		dw(1, ?)
</pre>
	is field 1, subfield [?] of macro <b>dw</b>. It's referenced twice
	per actual parameter.
<pre></pre>
	The command code of <b>+</b> means a number constant.
	<b>-</b> or <b>^</b> (1s complement) also work as number
	constant commands
<pre></pre>
	Where masmx source has something like
<pre>

		+	expression, expression

</pre>

	or
<pre>
		+	expression, expression, expression:q

</pre>
	That means put values in equal-size fields of a word or multiword.
<pre></pre>
	Supplied definition <b>8051.def</b> has 8 bits for word size.
<pre></pre>
	This line
<pre>

		+	dw(1, ?), dw(1, ?)/*8:d

</pre>
	Ends <b>:d</b> for double, so 16-bits total.
<pre></pre>
	And has one comma, so two 8-bit fields.
<pre></pre>
	The expression on the left, <b>dw(1, ?)</b> places the actual
	parameter value in the left eight bits. Truncation makes that
	the LSB.
<pre></pre>
	The expression on the right, <b>dw(1, ?)/*8</b> shifts the actual
	parameter value eight bits right,  and places that in the right
	eight bits. The shift makes this the MSB of the value.
<pre></pre>
	<b>$end</b> directive ends the macro
</ul>



<a      name="afloat"/>
<h1>11: Alternative Floating Formats</h1>


<a      name="masmxfloat"/>
<h2>11.1: masmx Floating Format</h2>

The default masmx floating number is the the 192-bit
value rounded to 96 bits with 23-bit midpointed exponent
and 72-bit all-fractional mantissa.

<p>
The width and exponent-width of a floating item output in masmx default
format can be adjusted with the directives
<pre>

	$floating_point

	$characteristic

</pre>
but the scheme
<pre>

	mid-point-exponent.normalised-fractional-mantissa.1s-complement

</pre>
is only changed with macro language

<a name="fdemens"/>
<h2>11.2: Floating Format Dimensions</h2>

<a name="fdemens1"/>
<h3>11.2.1: Floating Number Size</h3>

masmx rounds floating mantissa values according to field size
derived from

	<blockquote>
	the default floating number size, or<br><br>

	a words-given flag on a constant, or<br><br>

	the fields size of a split number row, or<br><br>

	a field size in bits in a $record structure, or<br><br>
	
	the subcommand 0..192 of a $set directive
	</blockquote>

These inputs are the total field size of the floating value.
Examples of each total size derivation are

<p>
<b>the default floating number size</b>
<pre>

	$floating_point	120	. the default floating number size is 120

</pre>
<b>a words-given flag on a constant</b>
<pre>

	7.2qe1245000		. this constant is four words in size

</pre>
<b>the fields size of a split number row</b>
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	60
	$awidth	24
        -0.0, 1.5, -1.6, 2.5, -2.6, 3.5, -3.6, 4.6, -4.6x:t
	. 9 * 20-bit floating constants
	$end
  :                            1  $word 60
  :                            2  $awidth 24
00:000000 FFFFF41C00BE33242A00BD59842E00BD19843934BC6CB
                              +3         -0.0, 1.5, -1.6, 2.5, -2.6, 3.5, -3.6, 4.6, -4.6x:t
  :                            4  . 9 * 20-bit floating constants
  :                            5  $end
:$(00):000000:000003 

</pre>
<b>the subfunction 0..192 of a $set directive</b>
<pre>

name	$set,65	1.6e4032	. 64-bit  value plus 1 extra bit
				. cached in label <i>name</i>

</pre>


The mantissa size is this total field minus the
characteristic field

<a name="fdemens2"/>
<h3>11.2.2: Exponent Field Size</h3>

The exponent field size is the characteristic field size
minus one sign bit

<p>
masmx caches a characteristic field width for each floating number size in words,<br>
plus one characteristic width for compressed floating values which are any size
less than one word

<p>
Directives here assign floating number dimension settings for PowerPC
<pre>
	
	$word		32
	$floating_point	64	# default is a double
	$characteristic	12	# exponent field is 11 bits
	$characteristic,32 9	# exponent field for a single is 8 bits
	$characteristic,24 8 	# exponent field for fp number < 1 word is 7 bits

</pre>
For default $characteristic assignments per floating number size see
<a href="#characteristic">8.6: $characteristic</a> directive

<a      name="ieeefloat"/>
<h2>11.3: IEEE754 Floating Values</h2>


<a      name="fpdifferences"/>
<h3>11.3.1: Differences between masmx Floating Format and IEEE754 Floating Formats</h3>

<p>
This package contains macros for assembling 128-bit,  64- and 32-bit
IEEE754 floating constants.

<p>
Macros use the directive $set to cache floating numbers as label
values for manipulation

<p>
The masmx internal format is:
<pre>

	a fraction-only 168-bit precision mantissa,
	normalising bit is represented, immediately
	to the right of the binary point

	a mid-pointed 23-bit exponent

	the entire item is 1s-complemented for negative polarity:
	sign bit = 1 indicates that all of the bits are inverted

	__________________________________________________________________
	|s|190 exponent 168|167          mantissa                       0|
	|_|________________|_____________________________________________|



</pre>
IEEE754 32-bit, 64-bit, and 128-bit floating formats have
<pre>

	an integral mantissa part one bit in size which is not
	represented. The encoded mantissa field starts with the
	first fractional bit. The normalising bit is the absent
	integral bit which has the imputed value 1.

	a biased exponent 8, 11 or 15 bits in size

	a sign bit which determines the polarity of the number.
	The remaining bits are not inverted with negative polarity.

	_____________________________________
	|s|exponent|mantissa fractional part|
	|_|________|________________________|
	          ^
	         |1| <- the unrepresented normalising integral bit


</pre>
For a given scale the IEEE754 biased exponent is 2 less than the
masmx abstract format mid-pointed exponent.

<p>
For the value 1.75 the masmx internal format places the true fraction
1110000000... at the top of the mantissa field, at the
immediate right of the binary point, and sets the exponent at one
greater than the mid-point, indicating that the integral value is
obtained by hauling the mantissa one bit position upwards through
the binary point:
<pre>

	The masmx Abstract Format
	_____________________________________________________________
	|s| 100 0000 0000 0000 0000 0001 | 1110 0000 0000 0000 ......
	|_|______________________________|___________________________


</pre>
In the IEEE754 32-bit, 64-bit and 128-bit formats, 1.75 has a biased
exponent one less than the mid point:
<pre>

	The IEEE754 64-bit Format
	___________________________________________________________
	|s| 011 1111 1111 | 1100 0000 0000 0000 0000...............
	|_|_______________|________________________________________
	                ^
	               |1| <- the unrepresented normalising integral bit

</pre>
These differences can be seen in the this assembly.
The first generated value is the masmx default, the second ieee754:
<pre>

MASMX 7r2
0/-INPUT>>
        $list   0
        $word   32
        $include        "ieee754.def"
        $list   2
        +               1.75
        ieee754_64      1.75
        $end
  :                            41         $list   2
00:00000000 400001E00000000000000000
                              +42         +               1.75
00:00000003 3FFC000000000000  +43         ieee754_64      1.75
  :                            44         $end
:$(00):00000000:00000005 
-INPUT>>: object code 87 bytes: 0 errors: 0 undefined labels

</pre>

<a      name="ieeemacro"/>
<h3>11.3.2: Macro-Language generating IEEE754 Floating Constants</h3>

The macro language for generating IEEE754 floating values is shown here.

<pre>


$ cat ieee754.def 

	$floating_point	32
	$characteristic	9
	$characteristic,64 12
	$characteristic,128 16
	

"$fieee754_32"	$form	1, 8, 23
"$fieee754_64"	$form	1, 11, 52
"$fieee754_128"	$form	1, 15, 112

p       $proc
ieee754_32* $name 0

	$nop	request a 33-bit number so masmx rounds the true 24-bit mantissa
	$nop	the normalising bit is suppressed on storage

tag     $set,33	 p(1,1)

	$nop	extend the sign and XOR the number to a magnitude

signs   $set    tag*/-32
tag     $set    tag--signs
characteristic $set (tag/*24)-2
	$do	tag=0,characteristic	$set	0

	$do	$o('V'),	$snap	2

        $nop	normalising bit truncated by copy to 23-bit field

        $fieee754_32	signs, characteristic, tag
        $end


p       $proc
ieee754_64* $name

	$nop	request a 65-bit number so masmx rounds the true 53-bit mantissa
	$nop	the normalising bit is suppressed on storage

tag     $set,65	p(1,1)

	$nop	extend the sign and XOR the number to a magnitude

signs	$set    tag*/-64
tag     $set	tag--signs
characteristic $set (tag/*53)-2
	$do	tag=0,characteristic	$set	0

	$do	$o('V'),	$snap	2

        $nop	normalising bit truncated by copy to 52-bit field

        $fieee754_64	signs, characteristic, tag
        $end

p	$proc
ieee754_128* $name

	$nop	request a 129-bit number so masmx rounds the true 113-bit mantissa
	$nop	the normalising bit is suppressed on storage

tag	$set,129	p(1, 1)

	$nop	extend the sign and XOR the number to a magnitude

signs	$set	tag*/-128
tag	$set	tag--signs
characteristic $set (tag/*113)-2
	$do	tag=0,characteristic	$set	0

	$do	$o('V'),	$snap	2

	$nop	normalising bit truncated by copy to 112-bit field

	$fieee754_128	signs, characteristic, tag
	$end

</pre>
IEEE754 format floating numbers are supported on many
architectures as well as matching XDR layout.

<p>
The $nop directive has been used to comment the macro code.
This is because the macros may be included in many different
assemblies with different comment characters, # ; .

<p>
<b>$floating_point</b> and <b>$characteristic</b> directives set the maximum range
and precision. The transient value is 192 bits in size

<p>
The directive $set,<i>number_size</i> caches the floating value
in the label <i>tag</i>. For IEE754 an extra bit is requested from masmx,
and this causes masmx to round on the true mantissa including the
normalising bit, which macro code must suppress on storage

<p>
The cached value in <i>tag</i> may be 1s-complement. If it is, XOR with
extended <i>signs</i> inverts it. IEEE754 formats only
invert the sign bit for negative polarity, not the whole number.

<p>
sign, characteristic and mantissa are output under control of the
$form template <b>$fieee754_32</b>, <b>$fieee754_64</b> or <b>$fieee754_128</b>

<p>
Three $form templates organise the bit-fields of the floating values

<p>
This form
<pre>

"$fieee754_32"	$form	1, 8, 23

</pre>
Causes the "instruction" <b>$fieee754_32</b> to construct its arguments in
this layout:
<pre>

	________________________________________________
	| x | xxxx xxxx | xxx xxxx xxxx xxxx xxxx xxxx |
	|___|___________|______________________________|
         31   30     23   22                         0



</pre>
This form
<pre>

"$fieee754_64"	$form	1, 11, 52

</pre>
Causes the "instruction" <b>$fieee754_64</b> to construct its arguments in
this layout:
<pre>

	____________________________________________________    _______
	| x | xxx xxxx xxxx | xxxx xxxx xxxx xxxx xxxx xxxx .... xxxx |
	|___|_______________|_______________________________    ______|
	 63   62         52   51                                     0


</pre>
This $form
<pre>

"$fieee754_128"	$form	1, 15, 112

</pre>
<p>
causes the "instruction" <b>$fieee754_128</b> to construct its arguments in
this layout:
<pre>

	____________________________________________________    _______
	| x | xxx xxxx xxxx xxxx | xxxx xxxx xxxx xxxx xxxx .... xxxx |
	|___|____________________|__________________________    ______|
	 127  126            112   111                               0


</pre>
The labels tag, sign, and characteristic are not promoted with
any trailing asterisk, so they only exist during the subassembly of
the macro.

<pre>


$ masmx -lnk ieeef
MASMX 7r3
3/ieeef.msm
*EOF*
  :                            1         $word   32
  :                            2:         $include "ieee754.def"
  :                            3 
00:00000000 3FE00000          +4         ieee754_32      1.75
00:00000001 BFE00000          +5         ieee754_32      -1.75
00:00000002 01B45BD15F9FB3FB  +6         ieee754_64      1.9e-300
00:00000004 3FEFFFFFFFFFFFFE  +7         ieee754_64      0.9999999999999997779553950749686919152736663818359375
  :                            8 
00:00000006 3FFFA000000000000000000000000000
                              +9 	ieee754_128	1.625
00:0000000A 4530893B3F9CA1B98E9D33873CAF6153
                              +10 	ieee754_128	1.8e400
*EOF*
:$(00):00000000:0000000E 


</pre>



<a      name="commandline"/>
<h1>Appendix A: masmx Command Line</h1>

An example assembly command may have the shape
<pre>

	% masmx [-fLAGS] [inputfile[.msm]] [-FL] [outputfile[.txo]] [-FlAgS]

</pre>
The input file extension must be supplied if it is not .msm
The output file extension must be supplied if it is not .txo

<p>
For example
<pre>

	% masmx in out -ulyke

</pre>
will read in.msm and write out.txo. The flags are case significant 
and -ulyke selects: 
<pre>

	-u       all labels must be resolved 
	
	-l       List the main file and generated code 
	
	-y       sort the label list

	-k       labels are case-significant

	-e       list the generated code word-space_word
			736f2069 74206973       "so it is"
		instead of streamed per source line
			736f206974206973        "so it is"

</pre>
in this assembly the size of word is 32 bits

<p>
The banner of flag letters is optional, is anywhere on the
command line, may be present several times, and begins - (minus)
for all developer platforms:
<pre>

prompt% masmx -flAgs source -mOrE objfilename -pq

</pre>
The one-letter case-significant flags can be -sTuCk -TogethER -o -R -nOt

<p>
The filename arguments are positional.

<p>
The input filename is the first argument that doesn't start -minus.

<p>
The output filename is the second argument that doesn't start -minus.

<p>	
The default extension for the source file name is .msm

<p>
The default extension for the output file name is .txo

<p>
These name extensions are applied where the filename contains no period.

<p>
If the second filename is not given, the output is temp.txo

<p>
If the first filename is not given, the assembler prompts for
stdin input. Source lines can be keyed including file includes.
If listing is opted, it should be suppressed around files which are
not required to be listed
<pre>

% masmx -ln

	$list		0
	$include	coldfire.def
	$list

banner	"sample"
sample	1.625

	$include	application
	$end

</pre>
$end is needed to end keyboard input

<p>
Filenames may be in quotes but need not be. When period
is the comment character, it only ends the line with a
following whitespace


The filename may be in quotes but need not be. When comment character
is the default period, it does not terminate the line if a nonspace
symbol follows immediately. This allows floating point expressions
and filenames
<pre>

	$include	file.name

	1.625
	+	1.79*-200

. comment line

</pre>
$include default filename extension is for source files .msm

<p>
Therefore
<pre>

	$include	afile

</pre>
will read afile.msm

<p>
The filename must otherwise be given exactly and in full

<p>
Input file can be stdin
<pre>

prompt% masmx -lpq
	$plist		5	. show deeply nested macro expansion
				. when option flags -pq are on
	$include	program.name
	$end

</pre>
mamsx writes a source file called temp.msm when input is stdin.
temp.msm is read on the second assembly pass

<p>
The following examples assemble an application called fastpass:
<pre>

	% masmx fastpass.asm -u

</pre>
masmx reads fastpass.asm and writes temp.txo. 

<p>
Whatever the output name, fastpass is 8051 and the 
target machine wants I-records, so you follow up:
<pre>

	% imx temp.txo florida.hex

</pre>
or for example
<pre>

	% masmx fastpass.asm today -u
	% imx today.txo fastpass.hex

</pre>
imx utility does nothing clever with filename extensions. 
They are typed exactly and in full. There are no flags or 
options

<p>
The similar utility for S-records (32-bit address) is mmx

<p>
See <a href="#file_formats">9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools</a>

<p>
This example has no link. Application called fastpass is
assembled absolute. imx is the I-Record conversion 
 
<p>
That's why -u is there. -u treats unresolved labels as 
an error. But you don't have to keep saying -u because 
the 8051 definition header says
<pre>

	$set_option     "u"

</pre>

<a	name="clopts"/>
<h2>A.a: Command Line Option Flags</h2>


The full set of masmx command line options are
<pre>


		<a	name="option_a"/>
	-a      allow automatic literals

		a literal is a storage constant which is
		generated in response to being referenced
		as an operand

		automatic literals are generated when an
		(operand) is entirely in parentheses. There may
		be a prefixed unary asterisk *(on the literal)

		unary operator +(operand) makes the operand
		an expression and not a literal. Therefore if
		-a flag is set and a non-literal expression starting
		(in parentheses) is needed, code a sign +(first)

		Default behaviour (not flag -a) only generates a
		literal when a literal pool tag is referenced outside
		the literal:
 
		<a href="#lptag">literal_pool_tag</a>(the_literal)

		-see <a href="#largument">4.4.2: Literal Arguments</a>, <a href="#literals">4.5: Literals</a>

		<a	name="option_b"/>
	-b	linker option: collate all input files by section

		<a	name="option_c"/>
	-c      C language hex and octal Notation
		C Language \escape sequences in strings
		aligned strings zero padded. See also -z option

                standard masmx behaviour so interprets number
		expressions in source code that leading zero means
		hex and any other leading digit means decimal.

		If $octal directive is issued leading zero means
		instead octal, until $hex directive is issued.

		Thus by default

		1000 and 03e8 both mean one thousand

		However with -c flag the hex expression is 0x3e8

		See also -m flag which may be asserted as well

		-c flag enables C-Language \escape sequences in
		quoted strings

		-c flag pads aligned quoted strings with zero.
		Default behaviour is space fill. See also -z option

		<a	name="option_d"/>
	-d	list load addresses or memory block index

		of meaning when a breakpoint addresses are encoded
		after start_addresses in a location counter declaration:

		$(67:base_address:breakpoint)

		-see <a href="#breakpoint">7.1.2: Breakpointed Location Counters</a>

		-see also <a href="#option_v">-v flag</a>

		in <a href="#giantspace">7.1.6: Giant Address Spaces</a>, -d option adds
		the giant step component to address summary information

		See also <a href="#link7">9.2.3.7: Giant Address Space Linking</a>, <a href="#link8">9.2.3.8</a>, <a href="#link10">9.2.3.10</a>

	-e      list generated code in one-word fields

                This makes the output readable when the target
                machine word size does not fit an exact number
                of hex or octal symbols

	-f	flag certain errors in the second assembly pass
		instead of in the first pass. This allows a listing
		to be generated

	-g	flag certain errors in the first assembly pass instead
		of in the second pass. This prevents unnecessary
		processing

	-h	stop after the first assembly pass

		-see also <a href="#option_s">option -s</a>

	-i	with -xi[p][q] display macro text in label table


	-j      has meaning when using masmx as a cumulative linker:

                When external labels are found but still relocatable,
                -j option causes references to them to remain
		outstanding, i.e. resolution of the name itself
		is requested again in subsequent links.

		Default behaviour replaces the label reference with
		a reference to offset+locator. The offset will later
		be summed with the new file segment base per this locator.

		-see <a href="#include_b">8.24.2: $include,$binary</a>

		-see <a href="#file_formats">9: Output File Formats, Relocation and Linking...</a>
	
		<a	name="option_k"/>
	-k      labels are case-significant

	-l      list source and assembly when the $list setting is 
		higher than the current include nesting depth

		<a	name="option_m"/>
	-m       Motorola Hex, Octal and Bit Notation

		-m flag is for	$hex
				@octal
				%bit-pattern

		Labels beginning $ and @ are then only
		recognised if they are in quotes "$xxx", except:

                $xxx @xxx names in the command field are recognised
                without quotes

		-m does not switch off other number notations
		guided by the $hex and $octal directives and the
		C-Syntax flag -c

                standard masmx behaviour so interprets number
		expressions in source code that leading zero means
		hex and any other leading digit means decimal.

		If $octal directive is issued leading zero means
		instead octal, until $hex directive is issued.

		Therefore by default

		1000 and 03e8 both mean one thousand

		However with -m flag $3e8 also gives the value 1000.

		See also <a href="#option_c">-c flag</a> which may be asserted as well.

		If -m flag is asserted and not -c, then 03e8 and $3e8
		both mean a thousand.

		If -cm flags are asserted, 0x3e8 and $3e8 both mean 1000.

	-n	list relocation information when listing with option -l

	-o      force filenames to lowercase. This can avoid problems when
		large numbers of output files are checked using Unix tools.
		
	-p      List $proc Text on Expansion when the $plist setting is
		higher than the current macro subassembly nesting depth

		-see <a href="#plist">8.37: $plist Directive</a> 

		-see <a href="#set_interact">8.47.2: Interaction of Run Options and $list / $plist Directives</a>

	        -list macro text when listing labels with <a href="#snap">8.48: $snap 3</a>


	-q      List $func Text on Expansion when the $plist setting is
		higher than the current macro subassembly nesting depth

		-see <a href="#plist">8.37: $plist Directive</a>

		-see <a href="#set_interact">8.47.2: Interaction of Run Options and $list / $plist Directives<a>

	        -list macro text when listing labels with <a href="#snap">8.48: $snap 3</a>


	-r	list $proc or $func text expansion during the first
		assembly pass when the $plist setting is
		higher than the current macro subassembly nesting depth

	        -list macro text when listing labels with <a href="#snap">8.48: $snap 3</a>

		<a	name="option_s"/>
	-s      Generate a source file with all text translations
		applied during the first assembly pass.

		Directly and indirectly included text is inlined.

		This output source file is called temp.msm

		This is the default behaviour when no
		input file is named on the command line.

		temp.msm is then read in the second assembly pass.

		-see <a href="#text">8.52: $text translation directive</a>

	-u      Treat unresolved labels as errors. 
		Otherwise information requesting linker
		resolution is placed in the output file.

                <a	name="option_v"/>	
	-v	of meaning when a breakpoint addresses are encoded
		after start_addresses in a location counter declaration:

		$(67:base_address:breakpoint)

		-v option causes the location counter breakpoint value
		to be written as a segment_index in the load-address
		clauses of the text-encoded binary output.

		Default behaviour is to compute load addresses
		from logical address + breakpoint address - base address,
		i.e. to apply physical load address relocation
		to load strings at assembly time

		-see <a href="#sections">7: Constructing Program Sections</a>
	
		-see <a href="#option_d">-d flag</a>

	-w	silent assembly, unless there are diagnostics.
		Default behaviour is to list summary information	

	-x      List Labels at the end of the assembly.
		-see also <a href="#snap">8.48: $snap directive</a>
			  <a href="#list_0">8.27.2: $list 0, masking names from list/export</a>

	-y      Sort the label list
		-see also <a href="#list_0">8.27.2: $list 0, masking names from list/export</a>

		<a	name="option_z"/>
	-z	Pad aligned quoted strings with zero.
		Default behaviour is to space fill.

		-c option also pads quoted strings with
		zero instead of space, but -zc combined
		pads quoted strings with space

                These four assemblies show the effects
                of -zc options in data word padding


		$ masmx a1 -ln
		MASMX 7r2
		3/a1.msm
*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61312020          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

		$ masmx a1 -lnz
		MASMX 7r2
		3/a1.msm
		*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61310000          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

		$ masmx a1 -lnc
		MASMX 7r2
		3/a1.msm
		*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61310000          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

		$ masmx a1 -lncz
		MASMX 7r2
		3/a1.msm
		*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61312020          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

	-B	trace information about structure member labels
		[L<i>macro_depth<sub>16</sub></i>
		 A<i>owner_macro_depth<sub>16</sub></i>
		 G<i>globality<sub>16</sub></i>
		 V<i>label_type<sub>16</sub></i>
		 P<i>owner_pass_generated<sub>16</sub></i>]<i>owner_name:name</i>

		label type storage indentifier is 127 7F<sub>16</sub>
		other label types may be displayed by assembly

				masmx -x+yk
				$end

		label types 128+ are user-defined

	-D	translate \<i>ESCAPED</i> octal and hex sequences in "strings"
		and in 'integers' in apostrophe if

			-c is opted

			$data_code is asserted

		when $data_code is asserted but -D is not opted
		translate only unescaped quoted symbols

		<a name="optro">
	-E	floating constants are rounded with guard pattern 111
		this is the default

		guard pattern is newly set to 111 on

			$set_option "E"

	-F	floating constants are rounded with guard pattern 110
		instead of 111

		guard pattern is newly set to 110 on

			$set_option "F"

	-G	floating constants are rounded with guard pattern 100
		instead of 111

		guard pattern is newly set to 100 on

			$set_option "G"

		the mantissa is always generated longer than
		it is stored. The OR of three guard pattern bits 
		AND their corresponding truncated bit is carried
		into the mantissa

		The mantissa may outflow as a result of rounding.
		Then the mantissa is shifted right one position to
		normalise again and the exponent is incremented

		The guard pattern is added simply during repositioning
		cycles when translating decimal scales

		 ___________________________________________________
		 |
		 |    mantissa for storage        truncated part
	_ _ _ _ _._______________________________________________
	 	|1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyy|*
	exponent|0000000000000000000000000000000|111000000000000|*++
	_ _ _ _ |_______________________________|_______________|
						 | |
						 |_|____________
						 111
						 110
						 100
						 000

						 possible values of
						 the three rounding
						 guard bits



	-H	floating constants are rounded with guard pattern 000
		instead of 111

		guard pattern is newly set to 000 on

			$set_option "H"

		rounding is towards zero or truncation


	-I	allow a function macro $func..$end to generate code
		inline to current location counter, not by default permitted


	-L	display macro depth, globality and type of labels declared in macros

                label type storage indentifier is 127 7F<sub>16</sub>
                other label types may be displayed by assembly

                                masmx -x+yk
                                $end

                label types 128+ are user-defined


		<a	name="option_Q"/>
        -Q      execute a function name encountered in an
                expression even if it is in quotes

                this concerns user-written function macros
                constructed with

                        name*   $func
                                .
                                .
                                $end
                or with

                        name    $func
                        name1*  $name
                        na...*
                                .
                                .
                                $end


                default behaviour is to execute the function
                name if it is an expression token without
                quotes, but to return an identifying
                value if the the function name is in quotes

                        procedure* $proc
                                .
                                $do     ($t(procedure(1,5))=$func);
                                        **(procedure(1, 5)="lolly")     ;
                                $note   this is lolly
                                .

                                +       procedure(1, 5)

                the first mention usually detects whether the
                parameter token is function macro called lolly

                the second mention causes lolly to happen

                with option -Q the first mention in quotes
                also causes macro lolly to happen instead of
                just identifying it


	-W	reserved


	-X	allow binary inclusions containing label exports
		which are absolute values not addresses

		encountering an exported label not bound to a location counter
		causes a linking assembly without option flag -X to error


	-Y	in $record structures flag fields as signed 
		unless their bit size is suffixed u

		field_name	5u

		if -Y is not opted flag only fields with s suffix as signed

		field-name	5s

		See 5.2.3.4: Signed Bit Fields


        -Z      zero fill buffers declared with $res directive
                (section 8.43)

                without -Z option no code is loaded in
                the $res storage area

                $res intervals in structures generated
                as literals are always zero-filled



	+	option flag -+ includes masmx internal names
		in label table lists

		masmx	-x+y
			$end

		lists the directive and internal function labels
		and names with fixed values

		-see Section 8.28: $list directive
				   $list 0, masking names from list/export



</pre>

<a	name="uclopts"/>
<h2>Appendix A.b: Switch and Trace Option Flags for Developer Use</h2>

Flags -<b>VUOS</b> may be used to switch and trace assembly language code
and may for this purpose also be opted at the command line.<br>Code can examine
command line option flags with masmx function <a href="#oflag">4.7.7: $o()</a>



<a      name="whatsnew"/>
<h1>Appendix B: What's new in 7r3?</h1>

	<blockquote>
	<a href="#stribata">Bit-Aligned Structures</a><br><br>

	<a href="#algors">Run-Time Algorithm Plotter</a><br><br>

	<a href="#path">$path</a> directive adds readability and structure to file inclusion across directory trees
	</blockquote>

<a      name="roadmap"/>
<h1>Appendix C: The masmx Product Road Map</h1>

<p>
The first C compiler generating target-independent macro-assembly
language shall be begun. See <a href="#languages">Appendix D.1:
A Target-Independent Macro-Assembly Language</a>

<p>
A further tool is planned to convert relocatable Text Encoded Binaries
to ELF, because macro language alone cannot quite do this.

<p>
Further output converters like the already-packaged imx (irec)
and mmx (srec) may be distributed on request.

<p>
It is otherwise intended mainly to distribute macro text for new
targets on request.

<p>
All requests to masmx@gmx.ch



<a      name="languages"/>
<h1>Appendix D: masmx's Potential for High Level Languages</h1>

<h2>D.1: A Target-Independent Macro-Assembly language</h2>

<p>
masmx is independent of target architecture. It is possible for
compilers to generate a single macro language for masmx assembly
for any target.

<p>
Compilers therefore need no knowledge of target architecture and
may themselves be target-independent

<p>
Tuning, efficiency, and architectural innovation then become matters
for the implementation of the single macro language per individual target.

<p>
The development of macro language for masmx requires no builds,
compilations or links. Macro Definition is text
<pre>


	__________________		______________________
	| source program |		| high level language |
	| in high level	 |------------->| compiler	      |
	| language       |		|_____________________|
	|________________|			   |
						   |
	_________________		___________|__________
	| macro language |		| application in macro|
	| target specific|		| language common to  |
	| definition     |		| all targets         |
	|________________|		|_____________________|
		 |				   |
		 |				   |
		 |				   |
		 |				   |
		 |				   |
	_________|_________________________________|___________
	|						      |
	|			masmx			      |
	|						      |
	|_____________________________________________________|
				   |
				   |
				   |
			___________|__________
			|		      |
			|  binary application |
			|		      |
			|_____________________|



</pre>
<p>


<h2>D.2: Bit-Aligned Data Structures</h2>

Developers using masmx can assign complex typing to identifiers
with the <b>$equf</b> directive

<p>
Labels of type <b>$equf</b> are generated in bit-aligned structures <b>$record</b>..<b>$root</b>

<p>
Each bit-aligned field is labelled with address, bit offset, bit size, signed attribute
and optionally base-displacement pointer with a single label

<p>
This allows macro language specific to the target to read and
write bit-aligned fields with consistent certainty. In this way masmx solves
a problem which has produced noticeable difficulty for compiler writers

<p>
In addition to compiler support, bit-aligned structuring is intended 
for data which is compressed or formatted in ways which do not map
to the target architecture

<p>
Bit-Aligned structuring can redefine and overlay storage without limit

<p>
Word-aligned structuring <b>$tree</b>..<b>$root</b> is completely analogous to bit-aligned
structuring, but generates all fields at word boundaries

<h2>D.3: RunTime Algorithm Plotting</h2>

Directives <b>$xqt_i</b> and <b>$xqt_fp</b> generate with the help of
target-specific macro text an instruction plan to execute algorithmic
expressions at runtime from variable inputs. Constant sequences within an
integer expression are resolved at assembly time. The compiler need neither
understand the target architecture nor order the expression sequence


<a	name="fixing"/>
<h1>Appendix E: Tuning Macro Language and Fixing Problems</h1>

<a      name="paramrefix"/>
<h2>E.1: Fixing a Macro Parameter Reference</h2>

<p>
If a macro appears unable to reference an actual parameter, equate a
local label to the parameter and reference the label (this problem won't
arise in an example as simple as this one):
<pre>

p	$proc
addo*	$name	0
subo*	$name	1

operand	$equ	p(1, 1)

	format	p(0, 0), operand
	$end

</pre>
<p>
It's in any case advisable to cache the parameters in local labels
if they are being referenced more than once. This is because the
actual parameter is not predictable to the macro, and referencing it
may, for example, cause functions to be called. One case of multiple
references to macro parameters is where range checks are carried out.

<a      name="labelrefix"/>
<h2>E.2: Label Cannot Be Referenced</h2>

<p>
Another possible cause of confusion, is that a label can't be
referenced when it has been declared. This doesn't always mean that
the reference is spelled wrong. The cause is sometimes that the label
has remained local to a macro expansion. To be visible outside the
containing macro, the label must be promoted* with asterisks*
<pre>

p	$proc
generate* $name

"p(1, 1)_generated_name"***	. label is visible three macro nesting
				. levels higher than this level

	.
	.
	.

	$end

</pre>
<a      name="labelrefind"/>
<h2>E.3: Changed Label Value Disappears</h2>

<p>
This is the same problem as the previous one. If you have
<pre>

macro1*	$proc
alabel	$set	SOMETHING
	macro2
	$end

macro2*	$proc
alabel	$set	SOMETHING_ELSE
	$end

</pre>
Calling <b>macro2</b> from <b>macro1</b> does not appear to change
<b>alabel</b>.

<p>
This is because two different labels have the name <b>alabel</b>.
If <b>macro2</b> must set <b>alabel</b> for <b>macro1</b>,
<b>macro2</b> must be coded like this, with an asterisk on <b>alabel*</b>
<pre>

macro2*	$proc
alabel*	$set	SOMETHING_ELSE
	$end

</pre>

<a      name="walkingmacro"/>
<h2>E.4: Tracing Macro Expansion</h2>

<p>
For monitoring the expansion of $proc and $func macros, see especially
Section 8.47.1: Interaction of Run Options and List Directives.

<p>
The path through macro language and presentation of actual parameters
to macros can be traced. <b>-p</b> Flag traces $proc macro steps and
<b>-q</b> Flag traces $func macro steps. Neither are traced unless $plist
directive has set a threshold higher than current macro nest depth:
<pre>

masmx	-lpq

	$plist	5

	.
	.

</pre>
<p>
Where assembly does not advance to the second assembly pass, <b>-r</b> flag
enables macro step display in the first assembly pass. Then the macro
step display is then shown out of listing context, because listings are
only produced on the second assembly pass.

<p>
See also Sections 8.48: $snap directive and 8.53: $trace directive.

<a      name="alias_fun"/>
<h2>E.5: Aliasing masmx Internal Functions</h2>

<p>
If you want to give a new name to a masmx internal function <b>$ $a $b $n
$net $o $r $rel $t</b>
<pre>

absolute	$equ, $function		"$a"

</pre>
<p>
The quotes on the masmx function name, here <b>$a</b>, are necessary.

<p>
Without the quotes, absolute will not have the functional meaning
<b>$a</b>, but instead the value returned from <b>$a</b> at this
point in the assembly

See also <a href="#option_Q">option -Q</a>


<a	name="labelshifted"/>
<h2>E.6: Error Diagnostic about a Label Address or Literal Table Start Address</h2>

This group of problems all stem from code changing in size between the first
and second assembly passes

<p>
It is permissible for code to change in size unless

	<blockquote>
	a storage address label consequently changes in value<br><br>

	the code is followed by a literal table
	</blockquote>

<p>
An error diagnostic is issued like the one in this assembly
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	$list	0
	$include 8051.def
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
        $list   2

first   var     size?

second  var     8

size?   equ     1024
        $end
  :                            646         $list   2
  :                            647 
  :                            648 first   var     size?
  :                            649 

[000000000000000000000000000000000000000000000400]
[000000000000000000000000000000000000000000000800]
Error: -INPUT>> Line 650: SECOND displacement altered
  :                            650 second  var     8
  :                            651 
  :                            652 size?   equ     1024
  :                            653         $end
:$(01):0400:0808 
-INPUT>>: object code 20 bytes: 1 errors: 0 undefined labels

</pre>
<p>
The explanation and solution is: <b>size?</b> must be known when the buffer
<b>first</b> is declared. Sizes cannot be fixed by forward reference.

<p>
The problem is noticed with the label <b>second</b>, but the cause
of the problem is earlier.

<p>
The problem in the next assembly is similar, but the solution is different:
<pre>

$ masmx -l
MASMX 7r2
0/-INPUT>>

	$word	32

early	+	pattern
late	+	99
pattern	$equ	0800000000000
	$end
  :                            1 
  :                            2  $word 32
  :                            3 
00:00000000 0000800000000000  +4 early + pattern
LATE [2000000/1000000]
Error: -INPUT>> Line 5: displacement difference between 1st and 2nd passes
Note: -INPUT>> Line 5: foregoing object has been sized by forward reference
00:00000002 00000063          +5 late + 99
  :                            6 pattern $equ 0800000000000
  :                            7  $end
:$(00):00000000:00000003 
-INPUT>>: object code 71 bytes: 1 errors: 0 undefined labels
 
</pre>
<p>
The size of the integer <b>early</b> is unexpectedly two words.
The solution is to decide what size integer <b>early</b> should be:
<pre>

$ masmx -l
MASMX 7r2
0/-INPUT>>

	$word	32

early	+	pattern:d
late	+	99
pattern	$equ	0800000000000
	$end
  :                            1 
  :                            2  $word 32
  :                            3 
00:00000000 0000800000000000  +4 early + pattern:d
00:00000002 00000063          +5 late + 99
  :                            6 pattern $equ 0800000000000
  :                            7  $end
:$(00):00000000:00000003 
-INPUT>>: object code 71 bytes: 0 errors: 0 undefined labels

</pre>

The following example concerns a target architecture with
more than one instruction size for operands in register or
address space, with or without pointer offset

<p>
Instruction formats have changed on the second pass as a result
of function macros which were not expanded on the first path.
There is then a conflict between the literal table start address
and the code end address

<pre>

f       $func   *
constant_token* $name
__FORMAT* $set	7*/3++2
        $do     f(1, 1:2)=s,    $return literal(ieee754_32 f(1, 1))
        $do	f(1, 1:2)=d,	$return literal(ieee754_64 f(1, 1))
        $end

</pre>

In this case the function must assemble on the first assembly pass
as well as the second (the argument of a single * on <b>$func</b>
directive suppressed first-pass assembly). Then the
second assembly pass generates code matching the size estimated in
the first assembly pass
<pre>

f       $func
constant_token* $name
__FORMAT* $set	7*/3++2
        $do     f(1, 1:2)=s,    $return literal(ieee754_32 f(1, 1))
	$do	f(1, 1:2)=d,	$return literal(ieee754_64 f(1, 1))
        $end

</pre>



<a      name="labelhidden"/>
<h2>E.7: Label fails to be Exported</h2>

<p>
Labels are not catalogued for listing or export if they are declared
or included while <b>$list</b> is zero

<p>
<b>$list</b> must be greater or less than zero when a label is declared
or binary-included for export

<p>
This example is a cumulative link which wants to pass labels in
the output binary. The labels imported from the input binary
<b>rel_file.txo</b> and the new label <b>location_after</b> are exported in
the output binary <b>new_rel.txo</b> because <b>$list</b> is other than 0
<pre>

	$list	0
	$include		linkrule.def
	$list	-1
	$include, $binary	rel_file
location_after*
	$list
	$store			new_rel	

</pre>
<p>
See also <a href="#list_0">8.27.2: $list 0</a>, masking names from list and export


<a      name="targets"/>
<h1>Appendix F: Target Descriptions</h1>


<a      name="8051"/>
<h2>F.1: 8051</h2>


8051.def header include file in this package has been
used with masmx to build mission-critical software for 
a number of prestige clients.


<a      name="powerpc"/>
<h2>F.2: PowerPC</h2> 

The ppc_603.def file in this delivery has been successfully used
to generate a stable, running RT kernel.

<p>
ppc_603.def may be steered to produce absolute or relocatable code.
The equivalent header file for linking relocatables is map_ppc.def
(see Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools)

<p>
Definitions ppc_64.def and ppc64map.def support the development of
giant address assembly and linking technique See Section 9.2: Linking.

<p>
For support developing assembly and link definitions, contact

<p>
masmx@gmx.ch



<a      name="definitions"/>
<h2>F.3: Definition Examples</h2>

  
<a      name="coldfire"/>
<h2>F.3.1: ColdFire</h2>

ColdFire instruction encoding appears formidably intricate, but operand
space may be viewed simply as a set of spaces tagged by the instruction
mode field. Although this  outline is intended as conceptual, it coincides
partly with instruction layout
<pre>

	 15				 5		 2		
	_________________________________________________________________ _ _ _ _ _ _ _ _ _ _ _ _               _ _ _ _ _ _ _ _ _ _ _ _ _
	|  instruction code / register	|      mode	|    register	|		address offset 16 or 32 bits or none		|
	|_______________________________|_______________|_______________| _ _ _ _ _ _ _ _ _ _ _ _		_ _ _ _ _ _ _ _ _ _ _ _ |
									|		16-bit encoding of double-index + 8-bit offset	|
									| _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |


</pre>

Instructions are one, two or three 16-bit words. masmx instruction macros call this function macro in common
in order to determine operand space and address attributes like pointer register and presence or absence of
an offset field. Registers have identifiable categories attached to their name

<pre>

f       $func
$iform* $name
        $do     $t(f(1, 1))=$d_reg,     $return 0++f(1, 1)*/3
        $do     $t(f(1, 1))=$a_reg,     $return 1++f(1, 1)*/3
        $do     $t("f(1, 1)")=$a_reg_@, $return 2++f(1, 1)*/3           ;       $ibase\f(1, 1)*/3
        $do     $t("f(1, 1)")="$a_reg_@+",      $return 3++f(1, 1)*/3   ;       $ibase\f(1, 1)*/3
        $do     $t("f(1, 1)")="$a_reg_@-",      $return 4++"f(1, 1)"*/3 ;       $ibase\f(1, 1)*/3
        $do     $inside\f(1, 1)=2,      $do     $type2\f(1, 1:1)=$special_reg,  |
                                        $do     $id2\f(1, 1)=pc,        $return 7++2*/3
        $do     $inside\f(1, 1)=2,      $return 5++$base_a\f(1, 1)*/3
        $do     $itype\f(1, 1)=$a_reg,  $return 5++$ibase\f(1, 1)*/3
        $do     $inside\f(1, 1)=3,      $do     $type2\f(1, 1:1)=$special_reg,  |
                                        $do     $id2\p(1, 1:1)=pc,      $return 7++3*/3
        $do     $inside\f(1, 1)=3,      $return 6++$base_a\f(1, 1)*/3
"$O"    $equ    f(1, 1)
"$X"    $equ    f(1, 2)
        $do     $o('V'),        $trace  $O
        $do     $o('V'),        $trace  $X
        $do     $X=pc,                                                  $return 7++2*/3
        $do     $X^=0,                  $return 5++$X*/3

        $do     f(1, #1),                                               $return 7++4*/3

        $do     ($t(f(1, 1:2))=$special_reg)**(f(1, 1:2)=l)++|
                ($net($O)<-32768)++|
                ($net($O)>32767),                                       $return 7++1*/3

                                                                        $return 7
        $end


</pre>

Instructions which do not correspond to all operand types mark the assembly in error
for any inappropriate operand

<p>
An instruction example which uses every possible operand type is <b>cmp</b> which this macro assembles
<pre>

p       $proc
cmp.b*  $name   0
cmp.w*  $name   1
cmp.l*  $name   2
cmp*    $name   cmp.w

        $if     $t(p(1, 2))=$d_reg
"$FO"   $set    $iform(p(1, 1))
"$MO"   $set    $FO**7
"$RO"   $set    $FO/*3

        $if     ($MO=0)++($MO=1)++($MO=2)++($MO=3)++($MO=4)
        $i_rr   11, p(1, 2), p(0, 0), $MO, $RO
        $elseif $MO=5
        $i_rm   11, p(1, 2), p(0, 0), 5, $RO, p(1, 1)
        $elseif $MO=6
        $i_rx   11, p(1, 2), p(0, 0), 6, $RO,           |
                $idx_d\p(1, 1:1), $idx_w\p(1, 1:1), 0,  |
                $displacement8\p(1, 1:1)
        $elseif $FO=7
        $i_rm   11, p(1, 2), p(0, 0), 7, 0, p(1, 1)
        $elseif $FO=7++1*/3
        $i_rl   11, p(1, 2), p(0, 0), 7, 1, p(1, 1)
        $elseif $FO=7++4*/3
          $if   p(0, 0)=cmp.l
          $i_rl 11, p(1, 2), p(0, 0), 7, 4, p(1, 1)
          $else
          $i_rm 11, p(1, 2), p(0, 0), 7, 4, p(1, 1)
          $endif
        $elseif $FO=7++2*/3
        $i_rm   11, p(1, 2), p(0, 0), 7, 2, p(1, 1)-$-2
        $elseif $FO=7++3*/3
        $i_rx   11, p(1, 2), p(0, 0), 7, 3,             |
                $idx_d\p(1, 1:1), $idx_w\p(1, 1:1), 0,  |
                $displacement8\p(1, 1:1)-$-2
        $else
        $flag   anomaly no operand style selected
        $endif

        $else
        $flag   must be comparand,d0..d7
        $endif
        $end


</pre>

There are some commands <b>$i_rr $i_rm $i_rx $i_rl</b> and these are instruction layout <b>$form</b>  templates

<pre>

"$i_rr" $form   4, 3, 3, 3, 3
"$i_rm" $form   4, 3, 3, 3, 3, 16
"$i_rl" $form   4, 3, 3, 3, 3, 32
"$i_rx" $form   4, 3, 3, 3, 3, 4, 3, 1, 8
"$i_fp" $form   4, 3, 3, 3, 3, 3, 3, 3, 7
"$i_fm" $form   4, 3, 3, 3, 3, 3, 3, 3, 7, 16
"$i_mq" $form   4, 3, 1, 8

"$b_cs" $form   8, 8
"$b_cl" $form   8, 8, 16

</pre>

<p>
masmx base-displacement addressing for ColdFire uses the program counter at instruction + 2
or a register from a1..a5, for example
<pre>

$(.data:131072,a5)

</pre>
Base-register a0..a7 maps to ColdFire operand space 5. Base-register identifiers are masmx label
type <b>$equf</b>

<p>
The subroutine referenced earlier in section 6.2<b>6.2: Run-Time Floating Algorithm Plotter</b> is
assembled here. It uses masmx base_displacement addressing to assemble instructions with operand
in mode 7.2 space 
<pre>
	
$(.text:262144,pc/$literal)

	lea	table_u+8*307, a0	; equivalent to (table_u+8*307, pc), a0

</pre>
Literals tagged with the label <b>$literal</b> are also mapped to <b>constant_storage_address-$-2, pc</b> in this assembly

<pre>

$ masmx s2double -lnk
MASMX 7r3
3/s2double.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3 	$path
  :                            4: 	$include	ieee754.def
  :                            5 
  :                            6 	;	this demonstration code block
  :                            7 	;	reads a string in ASCII or any other data code
  :                            8 	;	and converts it to 64-bit floating in fp1
  :                            9 
  :                            10 	;	ColdFire floating instructions' ability
  :                            11 	;	to convert and use 8/16/32-bit integer operands 
  :                            12 	;	prompts this conversion directly from string
  :                            13 	;	to double float. That is very feasible, so
  :                            14 	;	there is no attempt to generate and then
  :                            15 	;	convert a long long integer
  :                            16 
  :                            17 scale_10 $equ,$d_reg	d1
  :                            18 
  :                            19 $(0:262144,pc/$literal)
  :                            20 
  :                            21 s2double*
00:00000000 F23A50801458      +22 	fmove.w		$literal(0), fp1
00:00000006 7200              +23 	moveq		#0, scale_10	; decimal scale is accumulated here
  :                            24 s2dscanforit
00:00000008 7000              +25 	moveq		#0, d0
00:0000000A 1018              +26 	move.b		(a0)+, d0
00:0000000C 670000C6          +27 	beq		(eostringx).w
00:00000010 B07C0020          +28 	cmp.w		#' ', d0
00:00000014 67F2              +29 	beq		s2dscanforit	; walk any leading space
  :                            30 					; if there are none it costs nothing
  :                            31 
00:00000016 0680FFFFFFD5      +32 	addi		#-'+', d0	; check for leading sign
00:0000001C 671A              +33 	beq.b		read_1st_digit
00:0000001E 0680FFFFFFFE      +34 	addi		#'+'-'-', d0
00:00000024 6708              +35 	beq.b		s2dnegative
00:00000026 0680FFFFFFF3      +36 	addi		#'-'-'0'-10, d0	; well was it a digit then?
00:0000002C 6014              +37 	bra.b		check_1st_digit
  :                            38 
  :                            39 s2dnegative
00:0000002E 6108              +40 	bsr.b		read_1st_digit	; read the number then switch polarity
00:00000030 F23A50A3142A      +41 	fmul.w		$literal(-1), fp1 ; you can't just invert bits in fp1
00:00000036 4E75              +42 	rts
  :                            43 
  :                            44 read_1st_digit
00:00000038 7000              +45 	moveq		#0, d0
00:0000003A 1018              +46 	move.b		(a0)+, d0
00:0000003C 0680FFFFFFC6      +47 	addi		#-'0'-10, d0	; first is it higher than '9' ?
  :                            48 
  :                            49 check_1st_digit
00:00000042 655E              +50 	bcs.b		high
00:00000044 06800000000A      +51 	addi		#10, d0		; was it then lower than '0' ?
00:0000004A 6420              +52 	bcc.b		low
00:0000004C F20058A2          +53 integer	fadd.b		d0, fp1		; column 1 was in '0'..'9' and is now in 0..9
00:00000050 7000              +54 	moveq.l		#0, d0
00:00000052 1018              +55 	move.b		(a0)+, d0	; read next column
00:00000054 0680FFFFFFC6      +56 	addi		 #-'0'-10, d0	; is it higher than '9' ?
00:0000005A 6546              +57 	bcs.b		high		; if so it's the end of the integral part
00:0000005C 06800000000A      +58 	addi		#10, d0		; was it lower than '0' ?
00:00000062 6408              +59 	bcc.b		low
00:00000064 F23A50A313F8      +60 	fmul.w		$literal(10), fp1 . multiply the accumulation so far
00:0000006A 60E0              +61 	bra		integer		; add the new stripped digit in 0..9
  :                            62 
  :                            63 	$if	'.'<'0'			; data code independent. If period < digit
00:0000006C 068000000002      +64 low	addi		#'0'-'.', d0	; is this the decimal point?
  :                            65 	$else
  :                            66 high	addi		#'0'+10-'.', d0	; otherwise if period > digit was this . ?
  :                            67 	$endif
  :                            68 	
00:00000072 6708              +69 	beq.b		fraction	; whatever the data code, was that decimal point
00:00000074 0680FFFFFFC9      +70 	addi		#'.'-'e', d0	; if it wasn't is this an exponent string?
00:0000007A 602C              +71 	bra.b		estring?
  :                            72 
  :                            73 fraction				; decimal point has been found
00:0000007C 7000              +74 	moveq.l		#0, d0		; read the fraction
00:0000007E 1018              +75 	move.b		(a0)+, d0
00:00000080 0680FFFFFFC6      +76 	addi		#-'0'-10, d0	; higher than '9' ?
00:00000086 651A              +77 	bcs.b		eofraction
00:00000088 06800000000A      +78 	addi		#10, d0		; lower than '0' ?
00:0000008E 6412              +79 	bcc.b		eofraction
  :                            80 					; the accumulation attributes all columns to the
00:00000090 D2BCFFFFFFFF      +81 	add		#-1, scale_10	; integral part, so keep track of the scale
00:00000096 F23A50A313C6      +82 	fmul.w		$literal(10), fp1 ; multiply the accumulation by 10
00:0000009C F20058A2          +83 	fadd.b		d0, fp1		; add the stripped digit to it
00:000000A0 60DA              +84 	bra		fraction	
  :                            85 
  :                            86 	
  :                            87 	$if	'.'<'0'			; data code independent, if period < digit
  :                            88 high					; byte was higher than a digit
  :                            89 eofraction
00:000000A2 0680FFFFFFD5      +90 	addi		#'0'+10-'e', d0	; was it letter 'e' ?
  :                            91 	$else				; periods are higher than digits
  :                            92 low					; byte was lower than a digit
  :                            93 eofraction
  :                            94 	addi		#'0'-'e', d0	; so was it letter 'e' ?
  :                            95 	$endif
  :                            96 
  :                            97 estring?
  :                            98 	$if	'e'^='E'		; are there different code points for 'e' and 'E' ?
00:000000A8 6708              +99 	beq.b		estring!	; if there are and it was an 'e' you've found it
00:000000AA 068000000020      +100 	addi		#'e'-'E', d0	; otherwise was it an 'E' instead?
  :                            101 	$endif
  :                            102 
00:000000B0 6606              +103 	bne.b		eostring	; it wasn't any 'e' or 'E'
  :                            104 estring!
00:000000B2 2F01              +105 	move.l		scale_10, -(a7)	; yes it was, add the e+- number
00:000000B4 6128              +106 	bsr.b		string2i
00:000000B6 D29F              +107 	add		(a7)+, scale_10	; to the scale we already have
  :                            108 
  :                            109 					; the exponent range [ -307 .. +307 ] (15 bits midpoint)
  :                            110 					; is small enough to be handled in a table
  :                            111 
  :                            112 					; listing is off for the 615 constants at table_u
  :                            113 					; generated with
  :                            114 
  :                            115 					; ?       $do     615,    ieee754_64      1.0e?-308
  :                            116 
  :                            117 					; you can't quite have
  :                            118 					;	lea	(table_u+307*8-$-2, pc, scale_10.l*8), a0
  :                            119 					; because table_u+307*8-$-2 is more than 255
  :                            120 
  :                            121 					; so we point a0 to the exponent factor in 2 instructions
  :                            122 
  :                            123 					; table_u is a base-displacement address
  :                            124 					; with the meaning on reference
  :                            125 					;	table_u-$-2, pc
  :                            126 eostring
00:000000B8 B2BCFFFFFECD      +127 	cmp.l		#-307, scale_10	; has the decimal exponent got too low?
00:000000BE 6B16              +128 	bmi.b		outrange	; yes it has, NAN
00:000000C0 B2BC00000134      +129 	cmp.l		#308, scale_10	; has it got too high?
00:000000C6 6A0E              +130 	bpl.b		outrange	; yes it has, NAN
  :                            131 							; the exponent is in range
00:000000C8 41FA09F0          +132 	lea		table_u+307*8, a0		; point to the table location 1.0e0
00:000000CC 41F01E00          +133 	lea		(0, a0, scale_10.l*8), a0	; add the accumulated scale to it
00:000000D0 F21054A3          +134 	fmul.d		(a0), fp1	; multiply by [ 1.0e-307 .. 1.0e+307 ]
  :                            135 
  :                            136 eostringx
00:000000D4 4E75              +137 	rts
  :                            138 outrange				; score a NAN
00:000000D6 F23A54801388      +139 	fmove.d		$literal(-1q), fp1
00:000000DC 4E75              +140 	rts
  :                            141 
  :                            142 string2i				; scan an integer for whatever purpose
00:000000DE 7200              +143 	moveq		#0, d1		; there won't be leading space however
00:000000E0 7000              +144 	moveq		#0, d0
00:000000E2 1018              +145 	move.b		(a0)+, d0
00:000000E4 0680FFFFFFD5      +146 	addi		#-'+', d0	; leading sign?
00:000000EA 6716              +147 	beq.b		istring_next
00:000000EC 0680FFFFFFFE      +148 	addi		#'+'-'-', d0
00:000000F2 6708              +149 	beq.b		istring_minus
00:000000F4 0680FFFFFFF3      +150 	addi		#'-'-'0'-10, d0	; well is it a digit?
00:000000FA 6010              +151 	bra.b		istring_digit?
  :                            152 
  :                            153 istring_minus				; scan the magnitude and negate it
00:000000FC 6104              +154 	bsr.b		istring_next
00:000000FE 4481              +155 	neg		d1
00:00000100 4E75              +156 	rts
  :                            157 
  :                            158 istring_next
00:00000102 7000              +159 	moveq		#0, d0
00:00000104 1018              +160 	move.b		(a0)+, d0
00:00000106 0680FFFFFFC6      +161 	addi		#-'0'-10, d0	; is it > '9' ?
  :                            162 istring_digit?
00:0000010C 6512              +163 	bcs.b		istring_end	; if so, not more
00:0000010E 06800000000A      +164 	addi		#10, d0		; is it < '0' ?
00:00000114 640A              +165 	bcc.b		istring_end	; if so no more
00:00000116 E389              +166 	lsl		#1, d1		; multiply accumulation by 2
00:00000118 D081              +167 	add		d1, d0		; add accumulation to stripped digit
00:0000011A E589              +168 	lsl		#2, d1		; multiply accumulation by 4
00:0000011C D280              +169 	add		d0, d1		; accumulation = accumulation * 10 + digit
00:0000011E 60E2              +170 	bra		istring_next
  :                            171 
  :                            172 istring_end
00:00000120 4E75              +173 	rts
  :                            174 					; the table is not quadword-aligned
  :                            175 table_u				; but is only read once per conversion
  :                            178 	$list
*EOF*
00:0000145a+0000
00:0000145c+FFFF
00:0000145e+000A
00:00001460+FFFFFFFFFFFFFFFF
:$(00):00040000:00041468 


</pre>


The following kernel assembly lists header file excerpts to show

	<blockquote>
	tokens like <b>-(a7)</b> and <b>w*4</b> may be labels. Labels have a class or type.
	Different instructions may share one mnemonic name, and label types enable the
	assembly to pick the correct instruction code for storage operands and for multiple
	categories of registers
<p>
	Macro language uses quotes to declare and reference labels which could not otherwise
	be intentified
<pre>

	"-(a7)"		$equ,"$a_reg_@-" 	7

	"w*4"		$equ,$special_reg	0*/2++2

			$do	$t("p(1, 1)")="$a_reg_@+",	$formX	p(0, 0), p(1, 2), 3, +"p(1, 1)"

</pre>
<p>
	This prevents <b>-(a7)</b> from meaning minus <b>(a7)</b>, and for example <b>l*8</b> from meaning eight times <b>l</b>

<p>
	When a macro actual parameter is inserted in a <b>$form</b> as an instruction field, unsigned
	quotes would produce a character string. The addition of a unary sign <b>+"p(1, 1)"</b>
	produces a label value instead

<p>
	Application source code references labels like <b>l*8</b> and <b>-(a4)</b> without quotes 
<pre>

		move.w	(displacement, a0, d3.l*8), -(a4)

</pre>
<pre>

$ masmx -lnkV coldfire
MASMX 7r3
3/coldfire.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1: 	$include	"coldfire.def"
  :                            1 	$do	$o('V'),	$list	2
Note: coldfire.def Line 2: snapshot start of coldfire.def
  :                            2 	$do	$o('V'),	$note	snapshot start of coldfire.def
  :                            3 
  :                            4 	$word	16
  :                            5 	$awidth	32
  :                            6 	$quantum 8
  :                            7 	$byte	 8
  :                            8 
  :                            9 	$cont_char	'|'
  :                            10 	$lterm		';'
  :                            11 	$sterm		'.'
  :                            12 
  :                            13 	$set_option	"c"
  :                            14 
  :                            15 "$d_reg" 	$equ	128
  :                            16 "$a_reg" 	$equ	129
  :                            17 "$a_reg_@"	$equ	130
  :                            18 "$a_reg_@+" 	$equ	131
  :                            19 "$a_reg_@-"	$equ	132
  :                            20 "$special_reg"	$equ	133
  :                            21 "$fp_reg"	$equ	134
  :                            22 
  :                            23 d0	$equ,"$d_reg"	0
  :                            24 d1	$equ,"$d_reg"	1
  :                            25 d2	$equ,"$d_reg"	2
  :                            26 
  :                            52 	$do	$o('V'),	$list	2
Note: coldfire.def Line 53: snapshot equates in coldfire.def
  :                            53 	$do	$o('V'),	$note	snapshot equates in coldfire.def
  :                            54 
  :                            55 "(a5)"	$equ,"$a_reg_@"	5
  :                            56 "(a6)"	$equ,"$a_reg_@"	6
  :                            57 "(a7)"	$equ,"$a_reg_@"	7
  :                            58 
  :                            59 "-(a0)"	$equ,"$a_reg_@-"	0
  :                            60 "-(a1)"	$equ,"$a_reg_@-"	1
  :                            61 "-(a2)"	$equ,"$a_reg_@-"	2
  :                            62 
  :                            109 	$do	$o('V'),	$list	2
Note: coldfire.def Line 110: snapshot equates in coldfire.def
  :                            110 	$do	$o('V'),	$note	snapshot equates in coldfire.def
  :                            111 
  :                            112 "a5@+"	$equ,"$a_reg_@+"	5
  :                            113 "a6@+"	$equ,"$a_reg_@+"	6
  :                            114 "a7@+"	$equ,"$a_reg_@+"	7
  :                            115 
  :                            116 fp0	$equ,"$fp_reg"		0
  :                            117 fp1	$equ,"$fp_reg"		1
  :                            118 fp2	$equ,"$fp_reg"		2
  :                            119 
  :                            141 	$do	$o('V'),	$list	2
Note: coldfire.def Line 142: snapshot equates in coldfire.def
  :                            142 	$do	$o('V'),	$note	snapshot equates in coldfire.def
  :                            143 
  :                            144 "l*2"	$equ,"$special_reg"	1*/2++1
  :                            145 "l*4"	$equ,"$special_reg"	1*/2++2
  :                            146 "l*8"	$equ,"$special_reg"	1*/2++3
  :                            147 
  :                            148 ;	[ w l ] are only encoded [ 0 1 ]
  :                            149 ;	in the index width construct (a0, d0.w[ *1 *2 *4 *8])
  :                            150 
  :                            151 ;	and otherwise get their encoding values
  :                            152 ;	from instruction names, for example  move.[b w l]
  :                            153 
  :                            154 ;	however their values here combined with type $special_reg
  :                            155 ;	can be used for recognition in macro language
  :                            156 ;	and are used in the set [ b w l s d ]
  :                            157 
  :                            158 b	$equ,$special_reg	2*/2
  :                            159 s	$equ,$special_reg	3*/2
  :                            160 d	$equ,$special_reg	4*/2
  :                            161 
  :                            186 	$do	$o('V'),	$list	2
Note: coldfire.def Line 187: operand attribute scan in coldfire.def
  :                            187 	$do	$o('V'),	$note	operand attribute scan in coldfire.def
  :                            188 
  :                            189 f	$func
  :                            190 ;
  :                            191 ;	when no displacement is coded outside the parentheses
  :                            192 ;
  :                            193 "$inside"*	$name
  :                            194 	$return	f(1)
  :                            195 
  :                            196 "$displacement8"*	$name
  :                            197 	$do	f(1, 1)<-128,	$flag	displacement too low
  :                            198 	$do	f(1, 1)>127,	$flag	displacement too high
  :                            199 "$displacement"*	$name
  :                            200 	$return	f(1, 1)
  :                            201 
  :                            202 "$base_a"*	$name
  :                            203 	$do	$t(f(1, 2))^=$a_reg,	$flag base register not a0..a7
  :                            204 	$do	$t(f(1, 2))^=$a_reg,	$trace f(1, 2)
  :                            205 	$return	f(1, 2)
  :                            206 
  :                            207 "$idx_c"*	$name
  :                            208 	$return	f(1, 3:)	; how many substrings are after (disp, a0,.
  :                            209 
  :                            210 "$idx_d"*	$name		; d-register
  :                            211 	$do	$t(f(1, 3:1))=$a_reg,		$return	8++f(1, 3:1)
  :                            212 	$do	$t(f(1, 3:1))^=$d_reg,		$flag	index not d0..d7/a0..a7
  :                            213 	$return	f(1, 3:1)
  :                            214 
  :                            215 "$idx_w"*	$name		; width++scale
  :                            216 	$do	f(1, 3:)=1,	$return	"l*1"
  :                            217 	$do	$t("f(1, 3:2)")^=$special_reg,	$flag	scale not in scale
  :                            218 	$return	"f(1, 3:2)"
  :                            219 
  :                            220 	$end
  :                            221 
Note: coldfire.def Line 1308: end of include coldfire.def
  :                            2 
  :                            3 
  :                            4 __LINK_POINTER	$equ,"$a_reg"	6
  :                            5 __TCB_LOCATION	$equ		0
  :                            6 
  :                            7 
  :                            8 CPUS		$set	1
  :                            9 PRIORITIES	$set	8
  :                            10 IDLE_STACK	$set	64
  :                            11 
Note: coldfire.msm Line 13: listing off
Note: coldfire.msm Line 14: after all, the kernel structures aren't interesting
  :                            116 	$list	1
  :                            117 
00:00000400 2F08              +118 	move	a0, -(a7)
00:00000402 6100008A          +119 	bsr	p_tcb
  :                            120 
00:00000406 48E87FFF0010      +121 	movem	d0-a6, (tcb.genregs, a0)
  :                            122 
00:0000040C 2248              +123 	move	a0, a1
00:0000040E 205F              +124 	move	(a7)+, a0
00:00000410 23480030          +125 	move	a0, tcb.a_reg_0(a1)
00:00000414 234F004C          +126 	move	a7, tcb.a_reg_7(a1)
  :                            127 
00:00000418 20290004          +128 	move	tcb.h.priority(a1), d0
  :                            129 
00:0000041C 6B4E              +130 	bmi	qaside	$8_bits
00:0000041E 0C8000000007      +131 	cmpi	#PRIORITIES-1, d0
00:00000424 6E46              +132 	bgt	qaside	$8_bits
  :                            133 
Note: coldfire.msm Line 135: listing off
Note: coldfire.msm Line 136: after all, the context switch isn't interesting
  :                            162 	$list	1
  :                            163 
00:00000464 4CE9FFFF0010      +164 	movem	tcb.genregs(a1), d0-a7
00:0000046A 4E73              +165 	rte
  :                            166 
  :                            167 
  :                            168 
(+03)20
00:0000046C 4AB900000124      +169 qaside	tst	(qaside_h).l
00:00000472 670C              +170 	beq	first	$8_bits
(+03)20
00:00000474 207900000128      +171 	move	(qaside_t).l, a0
00:0000047A 21490000          +172 	move	a1, tcb.h.next(a0)
00:0000047E 6006              +173 	bra	last	$8_bits
(+03)20
00:00000480 23C900000124      +174 first	move	a1, (qaside_h).l 	
(+03)20
00:00000486 23C900000128      +175 last	move	a1, (qaside_t).l
00:0000048C 60B2              +176 	bra	pick
  :                            177 
  :                            178 
  :                            179 	$if	__LINK_POINTER
  :                            180 
                                	$do	$t(__LINK_POINTER)^=$a_reg,	|
  :                            182 	$flag	__LINK_POINTER should be a6 or similar
  :                            183 
  :                            184 ;	this is callable from c and returns pointer to tcb
  :                            185 ;	it requires that applications do not use stack frame
  :                            186 ;	link register (often a6) for anything except linking stack frames
  :                            187 
  :                            188 ;	it does not matter if functions do not use stack
  :                            189 ;	frames at all. It matters that nothing but LINK and UNLK
  :                            190 ;	instructions should change the link register
  :                            191 
00:0000048E 2F00              +192 p_tcb*	move	d0, -(a7)
  :                            193 
00:00000490 204E              +194 	move	__LINK_POINTER, a0
00:00000492 6002              +195 	bra	again?	$8_bits
00:00000494 2040              +196 again!	move	d0, a0
00:00000496 2018              +197 again?	move	(a0)+, d0
00:00000498 66FA              +198 	bne	again!
  :                            199 
00:0000049A 201F              +200 	move	(a7)+, d0
00:0000049C 4E75              +201 	rts
  :                            202 
  :                            203 
  :                            204 	$elseif	__TCB_LOCATION
  :                            205 
  :                            206 ;	this is callable from c and returns pointer to tcb
  :                            207 ;	if compilers can be directed to spare an address register,
  :                            208 ;	possibly a5 or a4, then __TCB_LOCATION can be that register
  :                            209 ;	and the encoding at the head of the assembly would be as
  :                            210 ;
  :                            211 ;	__LINK_POINTER	$equ		0
  :                            212 ;	__TCB_LOCATION	$equ,$a_reg	a5
  :                            213 ;
  :                            214 ;	otherwise __TCB_LOCATION may be a longword in RAM
  :                            215 ;	linked in location counter 3 (static data), but not if
  :                            216 ;	more than one core is running in the execution space
  :                            217 
  :                            218 	$if	$t(__TCB_LOCATION)=$a_reg
  :                            219 	$note	tcb pointer is an address register
  :                            220 	$else
  :                            221 	$note	tcb pointer is not at address register
  :                            222 	$endif
  :                            223 
  :                            224 p_tcb*	move	__TCB_LOCATION, a0
  :                            225 	rts
  :                            226 
  :                            227 	$else
  :                            228 
  :                            229 	$flag	you must have __LINK_POINTER or __TCB_LOCATION
  :                            230 
  :                            231 	$endif
*EOF*
:$(00):00000400:0000049E :$(03):00000000:0000012C :$(43):00000000:00000058 

</pre>
The same macro language can assemble an alternative Motorola syntax with tokens [] a4@ a0@+ a7@-
<pre>

$ masmx -lnk coldfir@
MASMX 7r3
3/coldfir@.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1: 	$include	"coldfire.def"
  :                            2 
  :                            3 __LINK_POINTER	$equ,"$a_reg"	6
  :                            4 __TCB_LOCATION	$equ		0
  :                            5 
  :                            6 
  :                            7 CPUS		$set	1
  :                            8 PRIORITIES	$set	8
  :                            9 IDLE_STACK	$set	64
  :                            10 
  :                            11 
Note: coldfir@.msm Line 14: listing off
Note: coldfir@.msm Line 15: after all, the kernel structures aren't interesting
  :                            115 	$list	1
  :                            116 
00:00000400 2F08              +117 	move	a0, a7@-
00:00000402 6100008A          +118 	bsr	p_tcb
  :                            119 
00:00000406 48E87FFF0010      +120 	movem	d0-a6, [tcb.genregs, a0]
  :                            121 
00:0000040C 2248              +122 	move	a0, a1
00:0000040E 205F              +123 	move	a7@+, a0
00:00000410 23480030          +124 	move	a0, [tcb.a_reg_0, a1]
00:00000414 234F004C          +125 	move	a7, [tcb.a_reg_7, a1]
  :                            126 
00:00000418 20290004          +127 	move	[tcb.h.priority, a1], d0
  :                            128 
00:0000041C 6B4E              +129 	bmi	qaside	$8_bits
00:0000041E 0C8000000007      +130 	cmpi	#PRIORITIES-1, d0
00:00000424 6E46              +131 	bgt	qaside	$8_bits
  :                            132 
  :                            133 
Note: coldfir@.msm Line 136: listing off
Note: coldfir@.msm Line 137: after all, the context switch isn't interesting
  :                            163 	$list	1
  :                            164 
00:00000464 4CE9FFFF0010      +165 	movem	[tcb.genregs, a1], d0-a7
00:0000046A 4E73              +166 	rte
  :                            167 
  :                            168 
  :                            169 
(+03)20
00:0000046C 4AB900000124      +170 qaside	tst	(qaside_h).l
00:00000472 670C              +171 	beq	first	$8_bits
(+03)20
00:00000474 207900000128      +172 	move	(qaside_t).l, a0
00:0000047A 21490000          +173 	move	a1, [tcb.h.next, a0]
00:0000047E 6006              +174 	bra	last	$8_bits
(+03)20
00:00000480 23C900000124      +175 first	move	a1, (qaside_h).l 	
(+03)20
00:00000486 23C900000128      +176 last	move	a1, (qaside_t).l
00:0000048C 60B2              +177 	bra	pick
  :                            178 
  :                            179 
  :                            180 	$if	__LINK_POINTER
  :                            181 
                                	$do	$t(__LINK_POINTER)^=$a_reg,	|
  :                            183 	$flag	__LINK_POINTER should be a6 or similar
  :                            184 
  :                            185 ;	this is callable from c and returns pointer to tcb
  :                            186 ;	it requires that applications do not use stack frame
  :                            187 ;	link register (often a6) for anything else
  :                            188 
  :                            189 ;	it does not matter if functions do not use stack
  :                            190 ;	frames at all. It matters that nothing but LINK and UNLK
  :                            191 ;	instructions should change the link register
  :                            192 
00:0000048E 2F00              +193 p_tcb*	move	d0, a7@-
  :                            194 
00:00000490 204E              +195 	move	__LINK_POINTER, a0
00:00000492 6002              +196 	bra	again?	$8_bits
00:00000494 2040              +197 again!	move	d0, a0
00:00000496 2018              +198 again?	move	a0@+, d0
00:00000498 66FA              +199 	bne	again!
  :                            200 
00:0000049A 201F              +201 	move	a7@+, d0
00:0000049C 4E75              +202 	rts
  :                            203 
  :                            204 
  :                            205 	$elseif	__TCB_LOCATION
  :                            206 
  :                            207 ;	this is callable from c and returns pointer to tcb
  :                            208 ;	if compilers can be directed to spare an address register,
  :                            209 ;	possibly a5 or a4, then __TCB_LOCATION can be that register
  :                            210 ;	and the encoding at the head of the assembly would be as
  :                            211 ;
  :                            212 ;	__LINK_POINTER	$equ		0
  :                            213 ;	__TCB_LOCATION	$equ,$a_reg	a5
  :                            214 ;
  :                            215 ;	otherwise __TCB_LOCATION may be a longword in RAM
  :                            216 ;	linked in location counter 3 (static data), but not if
  :                            217 ;	more than one core is running in the execution space
  :                            218 
  :                            219 	$if	$t(__TCB_LOCATION)=$a_reg
  :                            220 	$note	tcb pointer is an address register
  :                            221 	$else
  :                            222 	$note	tcb pointer is not at address register
  :                            223 	$endif
  :                            224 
  :                            225 p_tcb*	move	__TCB_LOCATION, a0
  :                            226 	rts
  :                            227 
  :                            228 	$else
  :                            229 
  :                            230 	$flag	you must have __LINK_POINTER or __TCB_LOCATION
  :                            231 
  :                            232 	$endif
*EOF*
:$(00):00000400:0000049E :$(03):00000000:0000012C :$(43):00000000:00000058 

</pre>


<a      name="alignments"/>
<h1>F.4: Byte-Addressing Machines with 32 and 64 Bit Bus:
Managing Alignments</h1>


<p>
If the address quantum of the target is also its word size, then
then the real architectural word size is the only possible $word value.


<p>
Word size set with the $word directive may otherwise not always mean the
architectural word size of the target.


<p>
In masmx $word sets the quantum of data which a line of assembly
can generate. A line may generate no code, a word or some words.

<p>
A target which can fetch instructions from any octet address and can have
instructions one or three or five bytes long must be described as having word
size one octet although its integer registers may be 32 or 64 bits in size
<pre>

	$cont_char	'|'
	$lterm		';'

	$word	8
	$awidth	32	; or however wide an address is

</pre>
<p>
32-bit and 64-bit integers are then described as quadwords and octawords,
for a canonical or a reverse-byte-order target:
<pre>

dl*	$proc
	$if	$BYTE_ORDER_CANONICAL
?	$do	d1(1),	+	d1(1, ?)q
	$else
?	$do	dl(1),	+	dl(1, ?),	dl(1, ?)/*8,	|
				dl(1, ?)/*16,	dl(1, ?)/*24:q
	$endif
	$end


p	$proc
long_long* $name
	$if	$BYTE_ORDER_CANONICAL
?	$do	p(1),	+	p(1, ?)o
	$else
?	$do	p(1),	+	p(1, ?), 	p(1, ?)/*8,	|
				p(1, ?)/*16, 	p(1, ?)/*24,	|
				p(1, ?)/*32, 	p(1, ?)/*40,	|
				p(1, ?)/*48, 	p(1, ?)/*56:o
	$endif
	$end

</pre>
<p>
An integer longer than than an octaword can be described with $form
<pre>

i128	$form	128
i128LE	$form	8,8,8,8, 8,8,8,8, 8,8,8,8, 8,8,8,8

p	$proc
d128*	$name
	$if	$BYTE_ORDER_CANONICAL
?	$do	p(1),	i128	p(1, ?)
	$else
?	$do	p(1),	i128LE	p(1, ?),     p(1, ?)/*8,  p(1, ?)/*16, p(1, ?)/*24,	|
			 	p(1, ?)/*32, p(1, ?)/*40, p(1, ?)/*48, p(1, ?)/*56,	|
	 			p(1, ?)/*64, p(1, ?)/*72, p(1, ?)/*80, p(1, ?)/*88,	|
			 	p(1, ?)/*96, p(1, ?)/*104,p(1, ?)/*112,p(1, ?)/*120
	$endif
	$end

</pre>
<p>
And this would apply to most Intel targets. Aligment directives
or macros are added where needed.

<p>
This does not in any way affect the target's ability to make full use
of its 32-bit or 64-bit data path.

<p>
Some architectures are critical about the alignment of instructions and
integers

<p>
Commands with names .byte .half .ascii .asciiz .space
may leave the next available location xxxxxx01 or xxxxxx10 or xxxxxx11.
 
<p>
load/store instructions may however need xxxxxx00 alignment for 32-bit
loads and stores and xxxxxxx0 alignment for 16-bit loads and stores.

<p>
It may be necessary or an advantage in bus efficiency  to follow up 
.byte or .space with a command often called .align which usually has
a power-2 argument

<p>
This is how .align looks as implemented with a masmx macro. .align
is coded here for PowerPC. The expression token . is location counter
which is otherwise $
<pre>

.align* $proc
granule $set    1*/.align(1,1)
        $res    ((.+granule-1)**-granule)-.
        $end

</pre>

<a      name="disclaimer"/>
<h1>Appendix G: Disclaimer and Contact</h1>


<p>
The executables in this package should not harm any
systems on which you run them. No responsibility is
accepted for them. They carry no guarantee.

<p>
These are free products.

<p>
Assistance can be requested at masmx@gmx.ch

<p>
Tim Cox
<p>
+41 76 383 33 49
<p>
24. April 2015

<i>
<pre>
_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2015
    TimMilesCox@gmx.ch

    This document describes the masmx.7r3A target-independent meta-assembler.

    masmx.7r3A is free software. It is licensed
    under the GNU General Public Licence Version 3

    You can redistribute it and/or modify masmx.7r3A
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    masmx.7r3A is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with masmx.7r3A.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>



</div>
